diff --git a/config/rose_edg_required_macros_and_functions.h.in b/config/rose_edg_required_macros_and_functions.h.in
index 45cc80b..5aac65f 100644
--- a/config/rose_edg_required_macros_and_functions.h.in
+++ b/config/rose_edg_required_macros_and_functions.h.in
@@ -771,6 +771,20 @@ __complex__ long double __builtin_cpowl(const __complex__ long double& __x,const
 #define _GLIBCXX_EXTERN_TEMPLATE 0
 
 /*************************************************
+        CONVEY SPECIFIC SUPPORT
+*************************************************/
+void rhomp_stencil_conv2d (void *grid_dst, void *grid_src,
+                           int grid_dimx, int grid_dimy,
+                           int stencil_dimx, int stencil_dimy, 
+                           int stencil_orgx, int stencil_orgy,
+                           void *kernel, int pipelen);
+void rhomp_stencil_conv2ds (void *grid_dst, void *grid_src,
+                           int grid_dimx, int grid_dimy,
+                           int stencil_dim, void *kernel, 
+                           int pipelen);
+
+
+/*************************************************
         CUDA and OPENCL SPECIFIC SUPPORT
 *************************************************/
 
diff --git a/src/ROSETTA/Grammar/Statement.code b/src/ROSETTA/Grammar/Statement.code
index 7761335..2819de5 100644
--- a/src/ROSETTA/Grammar/Statement.code
+++ b/src/ROSETTA/Grammar/Statement.code
@@ -16847,6 +16847,37 @@ SgOmpTargetDataStatement::post_construction_initialization()
    {}
 SOURCE_OMP_TARGET_DATA_STATEMENT_END
 
+// #ifdef CONVEY
+SOURCE_OMP_DECLARE_TARGET_STATEMENT_START
+void
+SgOmpDeclareTargetStatement::post_construction_initialization()
+   {}
+SOURCE_OMP_DECLARE_TARGET_STATEMENT_END
+
+SOURCE_OMP_END_DECLARE_TARGET_STATEMENT_START
+void
+SgOmpEndDeclareTargetStatement::post_construction_initialization()
+   {}
+SOURCE_OMP_END_DECLARE_TARGET_STATEMENT_END
+
+SOURCE_OMP_TEAMS_STATEMENT_START
+void
+SgOmpTeamsStatement::post_construction_initialization()
+   {}
+SOURCE_OMP_TEAMS_STATEMENT_END
+
+SOURCE_OMP_DISTRIBUTE_STATEMENT_START
+void
+SgOmpDistributeStatement::post_construction_initialization()
+   {}
+SOURCE_OMP_DISTRIBUTE_STATEMENT_END
+SOURCE_OMP_DISTRIBUTE_PARALLEL_FOR_STATEMENT_START
+void
+SgOmpDistributeParallelForStatement::post_construction_initialization()
+   {}
+SOURCE_OMP_DISTRIBUTE_PARALLEL_FOR_STATEMENT_END
+// #endif /* CONVEY */
+
 
 SOURCE_OMP_TASKWAIT_STATEMENT_START
 void
diff --git a/src/ROSETTA/astNodeList b/src/ROSETTA/astNodeList
index 613decc..a12c85e 100644
--- a/src/ROSETTA/astNodeList
+++ b/src/ROSETTA/astNodeList
@@ -760,6 +760,8 @@ SgXorAssignOp
 SgYieldExpression
 Sg_File_Info
 SgTypeCAFTeam
+SgOmpDeclareTargetStatement
+SgOmpEndDeclareTargetStatement
 SgCAFWithTeamStatement
 SgCAFCoExpression
 SgCallExpression
@@ -779,3 +781,9 @@ SgJavaQualifiedType
 SgClassExp
 SgJavaUnionType
 SgJavaParameterType
+SgOmpTeamsStatement
+SgOmpDistributeStatement
+SgOmpDistributeParallelForStatement
+SgOmpThreadLimitClause
+SgOmpNumTeamsClause
+SgOmpDistScheduleClause
diff --git a/src/ROSETTA/src/grammar.C b/src/ROSETTA/src/grammar.C
index 03ecf12..358e569 100644
--- a/src/ROSETTA/src/grammar.C
+++ b/src/ROSETTA/src/grammar.C
@@ -3389,6 +3389,11 @@ Grammar::GrammarNodeInfo Grammar::getGrammarNodeInfo(Terminal* grammarnode) {
         ||nodeName == "SgOmpParallelStatement"
         ||nodeName == "SgOmpSectionsStatement"
         ||nodeName == "SgOmpTargetStatement"
+//#ifdef CONVEY
+        ||nodeName == "SgOmpTeamsStatement"
+        ||nodeName == "SgOmpDistributeStatement"
+        ||nodeName == "SgOmpDistributeParallelForStatement"
+//#endif /* CONVEY */
         ||nodeName == "SgOmpTargetDataStatement"
         ||nodeName == "SgOmpSingleStatement"
         ||nodeName == "SgOmpSimdStatement"
@@ -3687,6 +3692,11 @@ Grammar::buildTreeTraversalFunctions(Terminal& node, StringUtility::FileWithLine
                  ||string(node.getName()) == "SgOmpTaskStatement"
                  ||string(node.getName()) == "SgOmpSectionsStatement"
                  ||string(node.getName()) == "SgOmpTargetStatement"
+//#ifdef CONVEY
+                 ||string(node.getName()) == "SgOmpTeamsStatement"
+                 ||string(node.getName()) == "SgOmpDistributeStatement"
+                 ||string(node.getName()) == "SgOmpDistributeParallelForStatement"
+// #endif /* CONVEY */
                  ||string(node.getName()) == "SgOmpTargetDataStatement"
                  ||string(node.getName()) == "SgOmpForStatement"
                  ||string(node.getName()) == "SgOmpDoStatement"
@@ -3793,6 +3803,11 @@ Grammar::buildTreeTraversalFunctions(Terminal& node, StringUtility::FileWithLine
                  ||string(node.getName()) == "SgOmpTaskStatement"
                  ||string(node.getName()) == "SgOmpSectionsStatement"
                  ||string(node.getName()) == "SgOmpTargetStatement"
+//#ifdef CONVEY
+                 ||string(node.getName()) == "SgOmpTeamsStatement"
+                 ||string(node.getName()) == "SgOmpDistributeStatement"
+                 ||string(node.getName()) == "SgOmpDistributeParallelForStatement"
+// #endif /* CONVEY */
                  ||string(node.getName()) == "SgOmpTargetDataStatement"
                  ||string(node.getName()) == "SgOmpForStatement"
                  ||string(node.getName()) == "SgOmpDoStatement"
diff --git a/src/ROSETTA/src/node.C b/src/ROSETTA/src/node.C
index e6140df..07a088d 100644
--- a/src/ROSETTA/src/node.C
+++ b/src/ROSETTA/src/node.C
@@ -68,11 +68,18 @@ Grammar::setUpNodes ()
      NEW_TERMINAL_MACRO (OmpCollapseClause, "OmpCollapseClause", "OmpCollapseClauseTag" );
      NEW_TERMINAL_MACRO (OmpIfClause, "OmpIfClause", "OmpIfClauseTag" );
      NEW_TERMINAL_MACRO (OmpNumThreadsClause, "OmpNumThreadsClause", "OmpNumThreadsClauseTag" );
-     NEW_TERMINAL_MACRO (OmpDeviceClause, "OmpDeviceClause", "OmpIfDeviceTag" );
+//#ifdef CONVEY
+     NEW_TERMINAL_MACRO (OmpDeviceClause, "OmpDeviceClause", "OmpDeviceTag" );
+     NEW_TERMINAL_MACRO (OmpNumTeamsClause, "OmpNumTeamsClause", "OmpNumTeamsTag" );
+     NEW_TERMINAL_MACRO (OmpThreadLimitClause, "OmpThreadLimitClause", "OmpThreadLimitTag" );
+// #endif /* CONVEY */
      NEW_TERMINAL_MACRO (OmpSafelenClause, "OmpSafelenClause", "OmpSafelenTag" );
 
-     NEW_NONTERMINAL_MACRO (OmpExpressionClause, OmpCollapseClause | OmpIfClause | OmpNumThreadsClause | OmpDeviceClause |
-                            OmpSafelenClause
+     NEW_NONTERMINAL_MACRO (OmpExpressionClause, OmpCollapseClause | OmpIfClause | OmpNumThreadsClause |
+               OmpSafelenClause |
+//#ifdef CONVEY
+               OmpDeviceClause | OmpThreadLimitClause | OmpNumTeamsClause
+// #endif /* CONVEY */
          ,"OmpExpressionClause", "OmpExpressionClauseTag",false );
 
 
@@ -95,8 +102,14 @@ Grammar::setUpNodes ()
          "OmpVariablesClause", "OmpVariablesClauseTag", false);
 
      NEW_TERMINAL_MACRO (OmpScheduleClause, "OmpScheduleClause", "OmpScheduleClauseTag" );
+//#ifdef CONVEY
+     NEW_TERMINAL_MACRO (OmpDistScheduleClause, "OmpDistScheduleClause", "OmpDistScheduleClauseTag" );
+//#endif /* CONVEY */
 
      NEW_NONTERMINAL_MACRO (OmpClause, OmpOrderedClause | OmpNowaitClause | OmpUntiedClause |
+//#ifdef CONVEY
+         OmpDistScheduleClause |
+//#endif /* CONVEY */
          OmpDefaultClause | OmpExpressionClause | OmpVariablesClause | OmpScheduleClause ,
          "OmpClause", "OmpClauseTag", false);
 #endif
@@ -1072,6 +1085,14 @@ Grammar::setUpNodes ()
                                    CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
      OmpScheduleClause.setDataPrototype ( "SgExpression*", "chunk_size", "= NULL",
                        CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, CLONE_PTR);
+
+// #ifdef CONVEY
+     // dist_schedule (kind[, chunksize_exp])
+     OmpDistScheduleClause.setDataPrototype("SgOmpClause::omp_schedule_kind_enum", "kind", "=e_omp_schedule_unknown",
+                                   CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
+     OmpDistScheduleClause.setDataPrototype ( "SgExpression*", "chunk_size", "= NULL",
+                       CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, CLONE_PTR);
+// #endif CONVEY
  
      // clauses with variable lists 
      // Liao 9/27/2010, per user's report, modeling the variable reference use SgVarRefExp
diff --git a/src/ROSETTA/src/statement.C b/src/ROSETTA/src/statement.C
index 164aa5e..18d503c 100644
--- a/src/ROSETTA/src/statement.C
+++ b/src/ROSETTA/src/statement.C
@@ -269,11 +269,20 @@ Grammar::setUpStatements ()
 
     NEW_TERMINAL_MACRO (OmpSimdStatement,    "OmpSimdStatement",     "OMP_SIMD_STMT" );
 
+//#ifdef CONVEY
+    NEW_TERMINAL_MACRO (OmpTeamsStatement,  "OmpTeamsStatement",   "OMP_TEAMS_STMT" );
+    NEW_TERMINAL_MACRO (OmpDistributeStatement,  "OmpDistributeStatement",   "OMP_DISTRIBUTE_STMT" );
+    NEW_TERMINAL_MACRO (OmpDistributeParallelForStatement,  "OmpDistributeParallelForStatement",   "OMP_DISTRIBUTE_PARALLEL_FOR_STMT" );
+//#endif /* CONVEY */
     // A base class for the most commonly formed directives with both clauses and a structured body
     // We treat OmpSectionsStatement separatedly by move the body to a list of SgOmpSectionStatement
     // sensitive to 
     NEW_NONTERMINAL_MACRO (OmpClauseBodyStatement,  OmpParallelStatement | OmpSingleStatement |
               OmpTaskStatement| OmpForStatement| OmpDoStatement | OmpSectionsStatement | OmpTargetStatement| OmpTargetDataStatement |
+//#ifdef CONVEY
+              OmpTeamsStatement | OmpDistributeStatement |
+              OmpDistributeParallelForStatement |
+//#endif /* CONVEY */
               OmpSimdStatement,
         "OmpClauseBodyStatement",   "OMP_CLAUSEBODY_STMT", false );
 
@@ -441,11 +450,19 @@ Grammar::setUpStatements ()
   // Note that this IR nodes is critical to Fortran support for CPP processed generated code.
      NEW_TERMINAL_MACRO (LinemarkerDirectiveStatement,  "LinemarkerDirectiveStatement",  "LINEMARKER_DIRECTIVE_STMT"   );
 
+// #ifdef CONVEY
+    NEW_TERMINAL_MACRO (OmpDeclareTargetStatement,   "OmpDeclareTargetStatement",   "OMP_DECLARE_TARGET_STMT" );
+    NEW_TERMINAL_MACRO (OmpEndDeclareTargetStatement,   "OmpEndDeclareTargetStatement",   "OMP_END_DECLARE_TARGET_STMT" );
+// #endif /* CONVEY */
+
      NEW_NONTERMINAL_MACRO (C_PreprocessorDirectiveStatement,
           IncludeDirectiveStatement     | DefineDirectiveStatement  | UndefDirectiveStatement  | 
           IfdefDirectiveStatement       | IfndefDirectiveStatement  | IfDirectiveStatement     | DeadIfDirectiveStatement   | 
           ElseDirectiveStatement        | ElseifDirectiveStatement  | EndifDirectiveStatement  |
           LineDirectiveStatement        | WarningDirectiveStatement | ErrorDirectiveStatement  | EmptyDirectiveStatement |
+// #ifdef CONVEY
+          OmpDeclareTargetStatement     | OmpEndDeclareTargetStatement      |
+// #endif /* CONVEY */
           IncludeNextDirectiveStatement | IdentDirectiveStatement   | LinemarkerDirectiveStatement,
           "C_PreprocessorDirectiveStatement", "CPP_DIRECTIVE_STMT", false );
 
@@ -3373,6 +3390,14 @@ Grammar::setUpStatements ()
                                              NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
 #endif
 
+// #ifdef CONVEY
+     OmpDeclareTargetStatement.setDataPrototype     ( "std::string"   , "dummyOmpString1", "= \"\"",
+                                             NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
+
+     OmpEndDeclareTargetStatement.setDataPrototype     ( "std::string"   , "dummyOmpString2", "= \"\"",
+                                             NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
+// #endif /* CONVEY */
+
   // Support for C preprocessor declarations within the AST (does not solve the problem of not
   // knowing where they might be expanded within source code (something we can't see).
   // This support allows transformations to introduce their own macros.
@@ -3771,6 +3796,14 @@ Grammar::setUpStatements ()
     OmpForStatement.setFunctionSource            ("SOURCE_OMP_FOR_STATEMENT", "../Grammar/Statement.code" );
     OmpAtomicStatement.setFunctionSource            ("SOURCE_OMP_ATOMIC_STATEMENT", "../Grammar/Statement.code" );
     OmpBarrierStatement.setFunctionSource            ("SOURCE_OMP_BARRIER_STATEMENT", "../Grammar/Statement.code" );
+// #ifdef CONVEY
+    OmpDeclareTargetStatement.setFunctionSource            ("SOURCE_OMP_DECLARE_TARGET_STATEMENT", "../Grammar/Statement.code" );
+    OmpEndDeclareTargetStatement.setFunctionSource            ("SOURCE_OMP_END_DECLARE_TARGET_STATEMENT", "../Grammar/Statement.code" );
+
+    OmpTeamsStatement.setFunctionSource            ("SOURCE_OMP_TEAMS_STATEMENT", "../Grammar/Statement.code" );
+    OmpDistributeStatement.setFunctionSource            ("SOURCE_OMP_DISTRIBUTE_STATEMENT", "../Grammar/Statement.code" );
+    OmpDistributeParallelForStatement.setFunctionSource            ("SOURCE_OMP_DISTRIBUTE_PARALLEL_FOR_STATEMENT", "../Grammar/Statement.code" );
+// #endif /* CONVEY */
     OmpMasterStatement.setFunctionSource            ("SOURCE_OMP_MASTER_STATEMENT", "../Grammar/Statement.code" );
     OmpOrderedStatement.setFunctionSource            ("SOURCE_OMP_ORDERED_STATEMENT", "../Grammar/Statement.code" );
     OmpTaskwaitStatement.setFunctionSource            ("SOURCE_OMP_TASKWAIT_STATEMENT", "../Grammar/Statement.code" );
diff --git a/src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.C b/src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.C
index dd1db24..69cfcff 100644
--- a/src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.C
+++ b/src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.C
@@ -1354,6 +1354,10 @@ UnparseLanguageIndependentConstructs::unparseStatement(SgStatement* stmt, SgUnpa
                     case V_SgOmpSectionStatement:
                     case V_SgOmpTaskwaitStatement:
                     case V_SgOmpBarrierStatement:           unparseOmpSimpleStatement        (stmt, info);break;
+// #ifdef CONVEY
+               case V_SgOmpDeclareTargetStatement:           unparseOmpSimpleStatement        (stmt, info);break;
+               case V_SgOmpEndDeclareTargetStatement:           unparseOmpSimpleStatement        (stmt, info);break;
+// #endif /* CONVEY */
                     case V_SgOmpThreadprivateStatement:     unparseOmpThreadprivateStatement (stmt, info);break;
                     case V_SgOmpFlushStatement:             unparseOmpFlushStatement         (stmt, info);break;
 
@@ -1369,6 +1373,11 @@ UnparseLanguageIndependentConstructs::unparseStatement(SgStatement* stmt, SgUnpa
                     case V_SgOmpSingleStatement:
                     case V_SgOmpTaskStatement:
                     case V_SgOmpSimdStatement:
+// #ifdef CONVEY
+                    case V_SgOmpTeamsStatement:
+                    case V_SgOmpDistributeStatement:
+                    case V_SgOmpDistributeParallelForStatement:
+// #endif /* CONVEY */
                          unparseOmpGenericStatement (stmt, info); 
                          break;
 
@@ -3450,7 +3459,11 @@ UnparseLanguageIndependentConstructs::unparseCharVal(SgExpression* expr, SgUnpar
             // Handle special case of ASCI DEL (decimal 127)
             // case '\177': curprint ( "\'\177\'"; break;
             // case 127: curprint ( "\'\177\'"; break;
+#if 1 // CONVEY-added FIX: the "char(127)" syntax only works for C++, not C.
+               case 127: curprint ( "(char)(127)"); break;
+#else
                case 127: curprint ( "char(127)"); break;
+#endif
             // This case is required since "\\" is the C++ name of the ASCII "\" character
                case '\\': curprint ( "\'\\\\'"); break;
 
@@ -4385,6 +4398,36 @@ void UnparseLanguageIndependentConstructs::unparseOmpScheduleClause(SgOmpClause*
   curprint(string(")"));
 }
 
+void UnparseLanguageIndependentConstructs::unparseOmpDistScheduleClause(SgOmpClause* clause, SgUnparse_Info& info)
+{
+  ROSE_ASSERT(clause != NULL);
+  SgOmpDistScheduleClause* c = isSgOmpDistScheduleClause(clause);
+  ROSE_ASSERT(c!= NULL);
+  curprint (string (" dist_schedule("));
+  SgOmpClause::omp_schedule_kind_enum skind = c-> get_kind ();
+  switch (skind)
+  {
+    case SgOmpClause::e_omp_schedule_static:
+      {
+        curprint(string("static"));
+        break;
+      }
+    default:
+      cerr<<"Error: UnparseLanguageIndependentConstructs::unparseOmpDistScheduleClause() meets unacceptable kind option value:"<<skind<<endl;
+      break;
+  }
+
+  // chunk_size expression
+  SgUnparse_Info ninfo(info);
+  if (c->get_chunk_size())
+  {
+    curprint(string(" , "));
+    unparseExpression(c->get_chunk_size(), ninfo);
+  }
+
+  curprint(string(")"));
+}
+
 #if 1
 //! A helper function to convert reduction operators to strings
 // TODO put into a better place and expose it to users.
@@ -4659,6 +4702,12 @@ void UnparseLanguageIndependentConstructs::unparseOmpExpressionClause(SgOmpClaus
     curprint(string(" if("));
   else if (isSgOmpNumThreadsClause(c))
     curprint(string(" num_threads("));
+  //#ifdef CONVEY
+  else if (isSgOmpThreadLimitClause(c))
+    curprint(string(" thread_limit("));
+  else if (isSgOmpNumTeamsClause(c))
+    curprint(string(" num_teams("));
+  //#endif /* CONVEY */
   else if (isSgOmpDeviceClause(c))
     curprint(string(" device("));
   else {
@@ -4710,10 +4759,19 @@ void UnparseLanguageIndependentConstructs::unparseOmpClause(SgOmpClause* clause,
         unparseOmpScheduleClause(isSgOmpScheduleClause(clause), info);
         break;
       }
+    case V_SgOmpDistScheduleClause:
+      {
+        unparseOmpDistScheduleClause(isSgOmpDistScheduleClause(clause), info);
+        break;
+      }
     case V_SgOmpDeviceClause:
     case V_SgOmpCollapseClause:
     case V_SgOmpIfClause:  
     case V_SgOmpNumThreadsClause:  
+        // #ifdef CONVEY
+    case V_SgOmpThreadLimitClause:  
+    case V_SgOmpNumTeamsClause:  
+        // #endif /* CONVEY */
       //case V_SgOmpExpressionClause: // there should be no instance for this clause
       {
         unparseOmpExpressionClause(isSgOmpExpressionClause(clause), info);
@@ -4884,6 +4942,36 @@ void UnparseLanguageIndependentConstructs::unparseOmpDirectivePrefixAndName (SgS
         curprint(string ("barrier "));
         break;
       }
+// #ifdef CONVEY
+     case V_SgOmpDeclareTargetStatement:
+      {
+        // make this disappear
+        break;
+      }
+     case V_SgOmpEndDeclareTargetStatement:
+      {
+        // make this disappear
+        break;
+      }
+    case V_SgOmpTeamsStatement:
+      {
+        unparseOmpPrefix(info);
+        curprint(string ("teams "));
+        break;
+      }
+    case V_SgOmpDistributeStatement:
+      {
+        unparseOmpPrefix(info);
+        curprint(string ("distribute "));
+        break;
+      }
+    case V_SgOmpDistributeParallelForStatement:
+      {
+        unparseOmpPrefix(info);
+        curprint(string ("distribute parallel for"));
+        break;
+      }
+// #endif /*  CONVEY */
     case V_SgOmpParallelStatement:
       {
         unparseOmpPrefix(info);
diff --git a/src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h b/src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h
index d421280..e8adc88 100644
--- a/src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h
+++ b/src/backend/unparser/languageIndependenceSupport/unparseLanguageIndependentConstructs.h
@@ -318,6 +318,9 @@ class UnparseLanguageIndependentConstructs
           virtual void unparseOmpPrefix                     (SgUnparse_Info& info); // = 0;
           virtual void unparseOmpDefaultClause              (SgOmpClause* clause, SgUnparse_Info& info); 
           virtual void unparseOmpScheduleClause             (SgOmpClause* clause, SgUnparse_Info& info);
+// #ifdef CONVEY
+          virtual void unparseOmpDistScheduleClause         (SgOmpClause* clause, SgUnparse_Info& info);
+ // #endif /* CONVEY */
           virtual void unparseOmpVariablesClause            (SgOmpClause* clause, SgUnparse_Info& info);
           virtual void unparseOmpExpressionClause           (SgOmpClause* clause, SgUnparse_Info& info);
           virtual void unparseOmpClause                     (SgOmpClause* clause, SgUnparse_Info& info);
diff --git a/src/frontend/SageIII/OmpAttribute.C b/src/frontend/SageIII/OmpAttribute.C
index d00619e..6dded5d 100644
--- a/src/frontend/SageIII/OmpAttribute.C
+++ b/src/frontend/SageIII/OmpAttribute.C
@@ -468,7 +468,12 @@ namespace OmpSupport
 
   omp_construct_enum OmpAttribute::getScheduleKind()
   {
-    ROSE_ASSERT(hasClause(e_schedule)==true);
+//#if CONVEY
+      ROSE_ASSERT((hasClause(e_schedule)==true) ||
+                  (hasClause(e_dist_schedule)==true));
+//#else
+//    ROSE_ASSERT(hasClause(e_schedule)==true);
+//#endif /* CONVEY */
     return schedule_kind;
   }
   // OmpSupport::toString()
@@ -479,7 +484,7 @@ namespace OmpSupport
     {
       /*
          case e_: result = ""; break;
-         */
+       */
       //directives
       case e_unknown: result ="unknown" ; break;
       case e_parallel: result = "parallel" ; break;
@@ -508,7 +513,24 @@ namespace OmpSupport
 
       case e_target: result = "target"; break;
       case e_target_declare : result = "target declare"; break;
+      case e_declare_target : result = "declare target"; break;
+// #ifdef CONVEY
+      case e_teams : result = "teams"; break;
+      case e_distribute : result = "distribute"; break;
+      case e_target_teams : result = "target teams"; break;
+      case e_target_teams_distribute : 
+          result = "target teams distribute"; break;
+      case e_target_teams_distribute_parallel_for : 
+          result = "target teams distribute parallel for"; break;
+      case e_teams_distribute : 
+          result = "teams distribute"; break;
+      case e_teams_distribute_parallel_for :
+          result = "teams distribute parallel for"; break;
+      case e_distribute_parallel_for: 
+          result = "distribute parallel for"; break;
+      case e_end_declare_target : result = "end declare target"; break;
       case e_target_data: result = "target data"; break;
+// #endif /* CONVEY */
       case e_target_update: result = "target update"; break;
 
                                 // Fortran only end directives
@@ -537,6 +559,11 @@ namespace OmpSupport
 
       case e_if: result = "if"; break;
       case e_num_threads: result = "num_threads"; break;
+// #ifdef CONVEY
+      case e_num_teams: result = "num_teams"; break;
+      case e_thread_limit: result = "thread_limit"; break;
+      case e_dist_schedule: result = "dist_schedule"; break;
+// #endif /* CONVEY */
       case e_nowait: result = "nowait"; break;
       case e_ordered_clause: result = "ordered"; break;
       case e_reduction: result = "reduction"; break;
@@ -585,9 +612,15 @@ namespace OmpSupport
       case e_schedule_runtime: result = "runtime"; break;
 
       case e_map_alloc: result = "alloc"; break;
-      case e_map_in: result = "in"; break;
-      case e_map_out: result = "out"; break;
-      case e_map_inout: result = "inout"; break;
+// #ifdef CONVEY
+      case e_map_in: result = "to"; break;
+      case e_map_out: result = "from"; break;
+      case e_map_inout: result = "tofrom"; break;
+// #else /* CONVEY */
+//      case e_map_in: result = "in"; break;
+//      case e_map_out: result = "out"; break;
+//      case e_map_inout: result = "inout"; break;
+// #endif /* CONVEY */
 
       case e_simd: result = "simd"; break;
       case e_safelen: result = "safelen"; break;
@@ -649,6 +682,18 @@ namespace OmpSupport
       // Experimental OpenMP Accelerator directives
       case e_target:
       case e_target_declare:
+// #ifdef CONVEY
+      case e_declare_target:
+      case e_end_declare_target:
+      case e_teams:
+      case e_distribute:
+      case e_target_teams:
+      case e_target_teams_distribute: 
+      case e_target_teams_distribute_parallel_for: 
+      case e_teams_distribute: 
+      case e_teams_distribute_parallel_for:
+      case e_distribute_parallel_for: 
+// #endif /* CONVEY */
       case e_target_data:
       case e_target_update: //TODO more later
       case e_simd:
@@ -843,6 +888,17 @@ namespace OmpSupport
       case e_target:
       case e_target_data:
 
+//#if CONVEY
+      case e_teams:
+      case e_distribute:
+      case e_target_teams:
+      case e_target_teams_distribute: 
+      case e_target_teams_distribute_parallel_for: 
+      case e_teams_distribute: 
+      case e_teams_distribute_parallel_for:
+      case e_distribute_parallel_for: 
+//#endif /* CONVEY */
+
       case e_master: 
       case e_critical:
       case e_barrier:
@@ -911,7 +967,12 @@ namespace OmpSupport
 
      // experimental accelerator clauses 
       case e_map:
+//#ifdef CONVEY
       case e_device:
+      case e_num_teams:
+      case e_thread_limit:
+      case e_dist_schedule:
+//#endif /* CONVEY */
       case e_safelen:
       case e_linear:
       case e_uniform:
@@ -1343,7 +1404,18 @@ namespace OmpSupport
       for (riter=attlist->ompAttriList.rbegin(); riter !=attlist->ompAttriList.rend();riter++)
       {
         OmpAttribute* att = *riter; //getOmpAttribute(sg_node);
-        if (att->getOmpDirectiveType() ==e_for ||att->getOmpDirectiveType() ==e_parallel_for)
+        if (att->getOmpDirectiveType() ==e_for ||
+            att->getOmpDirectiveType() ==e_parallel_for
+//#ifdef CONVEY
+            ||
+            att->getOmpDirectiveType() == e_distribute ||
+            att->getOmpDirectiveType() == e_target_teams_distribute || 
+            att->getOmpDirectiveType() == e_target_teams_distribute_parallel_for ||
+            att->getOmpDirectiveType() == e_teams_distribute ||
+            att->getOmpDirectiveType() == e_teams_distribute_parallel_for ||
+            att->getOmpDirectiveType() == e_distribute_parallel_for
+            //#endif /* CONVEY */
+)
           ROSE_ASSERT(isSgForStatement(cur_stmt) != NULL);
 
         string pragma_str= att->toOpenMPString();
@@ -1404,7 +1476,18 @@ namespace OmpSupport
           rtxt = rtxt + os2.str()+"\n";
         }
         OmpAttribute* att = *riter; //getOmpAttribute(sg_node);
-        if (att->getOmpDirectiveType() ==e_for ||att->getOmpDirectiveType() ==e_parallel_for)
+        if (att->getOmpDirectiveType() ==e_for ||
+            att->getOmpDirectiveType() ==e_parallel_for
+//#ifdef CONVEY
+            ||
+            att->getOmpDirectiveType() == e_distribute ||
+            att->getOmpDirectiveType() == e_target_teams_distribute || 
+            att->getOmpDirectiveType() == e_target_teams_distribute_parallel_for ||
+            att->getOmpDirectiveType() == e_teams_distribute ||
+            att->getOmpDirectiveType() == e_teams_distribute_parallel_for ||
+            att->getOmpDirectiveType() == e_distribute_parallel_for
+            //#endif /* CONVEY */
+)
           ROSE_ASSERT(isSgForStatement(cur_stmt) != NULL);
 
         string pragma_str= att->toOpenMPString();
diff --git a/src/frontend/SageIII/OmpAttribute.h b/src/frontend/SageIII/OmpAttribute.h
index 34b58f0..b8c878a 100644
--- a/src/frontend/SageIII/OmpAttribute.h
+++ b/src/frontend/SageIII/OmpAttribute.h
@@ -45,6 +45,18 @@ namespace OmpSupport
     // Liao, 1/15/2013, experimental implementation for the draft OpenMP Accelerator Model technical report 
     e_target, 
     e_target_declare,
+// #ifdef CONVEY
+    e_declare_target,
+    e_end_declare_target,
+    e_teams,
+    e_distribute,
+    e_target_teams,
+    e_target_teams_distribute,
+    e_target_teams_distribute_parallel_for,
+    e_teams_distribute,
+    e_teams_distribute_parallel_for,
+    e_distribute_parallel_for,
+// #endif /* CONVEY */
     e_target_data,
     e_target_update, 
     e_map, // map clauses
@@ -88,6 +100,11 @@ namespace OmpSupport
     //8 misc clauses
     e_if, // used with omp parallel or omp task
     e_num_threads, // for omp parallel only
+    // CONVEY
+    e_num_teams,
+    e_thread_limit,
+    e_dist_schedule,
+    // end CONVEY
     e_nowait,
     e_ordered_clause,
     e_reduction,
diff --git a/src/frontend/SageIII/omp.h b/src/frontend/SageIII/omp.h
index ad8709b..c23eb3c 100644
--- a/src/frontend/SageIII/omp.h
+++ b/src/frontend/SageIII/omp.h
@@ -45,6 +45,11 @@ int omp_get_dynamic(void);
 void omp_set_nested(int n_nested);
 int omp_get_nested(void);
 
+int omp_get_num_devices(void);
+int omp_is_initial_device(void);
+int omp_get_team_num(void);
+int omp_get_num_teams(void);
+
 /* 
  * Timer routine
  */
diff --git a/src/frontend/SageIII/ompAstConstruction.cpp b/src/frontend/SageIII/ompAstConstruction.cpp
index 125f100..8acf00a 100644
--- a/src/frontend/SageIII/ompAstConstruction.cpp
+++ b/src/frontend/SageIII/ompAstConstruction.cpp
@@ -214,12 +214,31 @@ namespace OmpSupport
             //user-defined and compiler-generated OmpAttribute.
             // We attach the attribute redundantly on affected loops also
             // for easier loop handling later on in autoTuning's outlining step (reproducing lost pragmas)
-            if (attribute->getOmpDirectiveType() ==e_for ||attribute->getOmpDirectiveType() ==e_parallel_for)
+            if (attribute->getOmpDirectiveType() ==e_for ||
+                attribute->getOmpDirectiveType() ==e_parallel_for
+//#ifdef CONVEY
+                ||
+                attribute->getOmpDirectiveType() == e_distribute ||
+                attribute->getOmpDirectiveType() == e_target_teams_distribute || 
+                attribute->getOmpDirectiveType() == e_target_teams_distribute_parallel_for ||
+                attribute->getOmpDirectiveType() == e_teams_distribute ||
+                attribute->getOmpDirectiveType() == e_teams_distribute_parallel_for ||
+                attribute->getOmpDirectiveType() == e_distribute_parallel_for
+                //#endif /* CONVEY */
+)
             {
-              SgForStatement* forstmt = isSgForStatement(getNextStatement(pragmaDeclaration));
-              ROSE_ASSERT(forstmt != NULL);
-              //forstmt->addNewAttribute("OmpAttribute",attribute);
-              addOmpAttribute(attribute,forstmt);
+                SgStatement *nextStmt = getNextStatement(pragmaDeclaration);
+                ROSE_ASSERT(nextStmt);
+                if (!isSgForStatement(nextStmt)) {
+                    ROSE_ASSERT(isSgPragmaDeclaration(nextStmt) &&
+                                attribute->getOmpDirectiveType() != e_distribute);
+                    nextStmt = getNextStatement(nextStmt);
+                }
+                SgForStatement *forstmt = isSgForStatement(nextStmt);
+                ROSE_ASSERT(forstmt != NULL);
+
+                //forstmt->addNewAttribute("OmpAttribute",attribute);
+                addOmpAttribute(attribute,forstmt);
             }
 #endif
           }
@@ -329,8 +348,14 @@ namespace OmpSupport
                   ROSE_ASSERT(!macroValue.empty() && it == macroValue.end());
                   
                   newExp = buildIntVal(atoi(macroValue.c_str()));
-                  if(!isSgPragmaDeclaration(old_exp->get_parent()))
+// #ifdef CONVEY
+                  if (old_exp->get_parent() &&
+                     !isSgPragmaDeclaration(old_exp->get_parent()))
                       replaceExpression(old_exp, newExp);
+// ##else /* CONVEY */
+//                  if(!isSgPragmaDeclaration(old_exp->get_parent()))
+//                      replaceExpression(old_exp, newExp);
+// #endif /* CONVEY */
                   macro_replaced = true;
               }
           }
@@ -338,6 +363,15 @@ namespace OmpSupport
       return newExp;
   }
   
+
+// #ifdef CONVEY
+    //
+    // Collect clauses that need to be deleted from the tree because they are
+    // macro references that got expanded.  We cannot delete them on the fly
+    // because they can be processed more than once.
+    std::set<SgExpression *> clausesToDelete;
+// #endif /* CONVEY */
+
   SgExpression* checkOmpExpressionClause( SgExpression* clause_expression, SgGlobal* global, omp_construct_enum clause_type )
   {
       SgExpression* newExp = clause_expression;
@@ -418,6 +452,14 @@ namespace OmpSupport
           }
       }
       
+// #if CONVEY
+// Convey -- remove old expression
+      if (newExp != clause_expression) {
+          // std::cout << "need to delete " << clause_expression->unparseToString() << " " << clause_expression << std::endl;
+          clausesToDelete.insert(clause_expression);
+      }
+// #endif /* CONVEY */
+
       return (returnNewExpression ? newExp : clause_expression);
   }
 
@@ -436,30 +478,68 @@ namespace OmpSupport
         {
           SgExpression* collapseParam = checkOmpExpressionClause( att->getExpression(e_collapse).second, global, e_collapse );
           result = new SgOmpCollapseClause(collapseParam);
+// #if CONVEY
+          // Convey -- set parent
+          collapseParam->set_parent(result);
+// #endif /* CONVEY */
           break;
         }
       case e_if:
         {
           SgExpression* ifParam = checkOmpExpressionClause( att->getExpression(e_if).second, global, e_if );
           result = new SgOmpIfClause(ifParam);
+// #if CONVEY
+          // Convey -- set parent
+          ifParam->set_parent(result);
+// #endif /* CONVEY */
           break;
         }
       case e_num_threads:
         {
           SgExpression* numThreadsParam = checkOmpExpressionClause( att->getExpression(e_num_threads).second, global, e_num_threads );
           result = new SgOmpNumThreadsClause(numThreadsParam);
+// #if CONVEY
+          // Convey -- set parent
+          numThreadsParam->set_parent(result);
+// #endif /* CONVEY */
           break;
         }
+// #if CONVEY
+      case e_num_teams:
+        {
+          SgExpression* numTeamsParam = checkOmpExpressionClause( att->getExpression(e_num_teams).second, global, e_num_teams );
+          result = new SgOmpNumTeamsClause(numTeamsParam);
+          // Convey -- set parent
+          numTeamsParam->set_parent(result);
+          break;
+        }
+      case e_thread_limit:
+        {
+          SgExpression* threadLimitParam = checkOmpExpressionClause( att->getExpression(e_thread_limit).second, global, e_thread_limit );
+          result = new SgOmpThreadLimitClause(threadLimitParam);
+          // Convey -- set parent
+          threadLimitParam->set_parent(result);
+          break;
+        }
+// #endif /* CONVEY */
       case e_device:
         {
           SgExpression* param = checkOmpExpressionClause( att->getExpression(e_device).second, global, e_device );
           result = new SgOmpDeviceClause(param);
+// #if CONVEY
+          // Convey -- set parent
+          param->set_parent(result);
+// #endif /* CONVEY */
           break;
         }
       case e_safelen:
         {
           SgExpression* param = checkOmpExpressionClause( att->getExpression(e_safelen).second, global, e_safelen );
           result = new SgOmpDeviceClause(param);
+// #if CONVEY
+          // Convey -- set parent
+          param->set_parent(result);
+// #endif /* CONVEY */
           break;
         }
  
@@ -545,6 +625,52 @@ namespace OmpSupport
     // ROSE_ASSERT(chunksize_exp != NULL); // chunk size is optional
     // finally build the node
     SgOmpScheduleClause* result = new SgOmpScheduleClause(sg_kind, chunksize_exp);
+
+// #if CONVEY
+    // Convey -- need to set parent pointer
+    if (chunksize_exp) {
+        chunksize_exp->set_parent(result);
+    }
+// #endif /* CONVEY */
+
+    //  setOneSourcePositionForTransformation(result);
+    ROSE_ASSERT(result != NULL);
+    return  result;
+  }
+
+  //Build SgOmpDistScheduleClause from OmpAttribute, if any
+  SgOmpDistScheduleClause* buildOmpDistScheduleClause(OmpAttribute* att)
+  {
+    ROSE_ASSERT(att != NULL);
+    if (!att->hasClause(e_dist_schedule))
+      return NULL;
+    // convert OmpAttribute schedule kind to SgOmpClause schedule kind
+    omp_construct_enum oa_kind = att->getScheduleKind();
+    SgOmpClause::omp_schedule_kind_enum sg_kind;
+    switch (oa_kind)
+    {
+      case e_schedule_static:
+        sg_kind = SgOmpClause::e_omp_schedule_static;
+        break;
+      default:
+        {
+          cerr<<"error: buildOmpDistScheduleClause() Unacceptable schedule kind from OmpAttribute:"
+            <<OmpSupport::toString(oa_kind)<<endl;
+          ROSE_ASSERT(false) ;  
+        }
+    }
+    SgExpression* chunksize_exp = att->getExpression(e_dist_schedule).second;
+    // ROSE_ASSERT(chunksize_exp != NULL); // chunk size is optional
+    // finally build the node
+    SgOmpDistScheduleClause* result = new SgOmpDistScheduleClause(sg_kind, chunksize_exp);
+
+// #if CONVEY
+    // Convey -- need to set parent pointer
+    if (chunksize_exp) {
+        chunksize_exp->set_parent(result);
+    }
+// #endif /* CONVEY */
+
     //  setOneSourcePositionForTransformation(result);
     ROSE_ASSERT(result != NULL);
     return  result;
@@ -754,6 +880,28 @@ namespace OmpSupport
     // since the attribute has dimension info for all map clauses
     //But we don't want to move the dimension info to directive level 
     result->set_array_dimensions(att->array_dimensions);
+
+// #ifdef CONVEY
+    std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > >  dims = att->array_dimensions;
+
+    std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > >::iterator iter;
+    SgGlobal* file = SageInterface::getGlobalScope( att->getNode() );
+
+    for (iter = dims.begin(); iter != dims.end(); iter++) {
+        for (int ad = 0; ad < (*iter).second.size(); ad++) {
+            if ( (*iter).second.at(ad).first ) {
+                // This will delete the expression if it is a macro identifier
+                (*iter).second.at(ad).first = OmpSupport::checkOmpExpressionClause((*iter).second.at(ad).first, file, e_map);
+            }
+            // This will delete the expression if it is a macro identifier
+            if ( (*iter).second.at(ad).second ) {
+                (*iter).second.at(ad).second = OmpSupport::checkOmpExpressionClause((*iter).second.at(ad).second, file, e_map);
+            }
+        }
+    }
+
+// #endif /* CONVEY */
+
     return result;
   }
 
@@ -846,6 +994,11 @@ namespace OmpSupport
           result = buildOmpScheduleClause(att);
           break;
         }
+      case e_dist_schedule:
+        {
+          result = buildOmpDistScheduleClause(att);
+          break;
+        }
       case e_untied:
         {
           result = buildOmpUntiedClause(att); 
@@ -856,6 +1009,10 @@ namespace OmpSupport
       case e_num_threads:
       case e_device:
       case e_safelen:
+//#ifdef CONVEY
+      case e_num_teams:
+      case e_thread_limit:
+//#endif /* CONVEY */
         {
           result = buildOmpExpressionClause(att, c_clause_type);
           break;
@@ -936,6 +1093,17 @@ namespace OmpSupport
         c_clause_type == e_parallel_do||
         c_clause_type == e_simd||
         c_clause_type == e_atomic
+//#ifdef CONVEY
+        ||
+        c_clause_type == e_teams ||
+        c_clause_type == e_distribute ||
+        c_clause_type == e_target_teams ||
+        c_clause_type == e_target_teams_distribute ||
+        c_clause_type == e_target_teams_distribute_parallel_for ||
+        c_clause_type == e_teams_distribute ||
+        c_clause_type == e_teams_distribute_parallel_for ||
+        c_clause_type == e_distribute_parallel_for
+//#endif /* CONVEY */
        )
     {
       ROSE_ASSERT(result!=NULL);
@@ -975,6 +1143,9 @@ namespace OmpSupport
           omp_construct_enum rop = *iter;
           SgOmpClause* sgclause = buildOmpReductionClause(att, rop);
           target->get_clauses().push_back(sgclause);
+// #ifdef CONVEY
+          sgclause->set_parent(target); // is This right?
+// #endif /* CONVEY */
         }
       }
       else if (c_clause == e_map)
@@ -987,6 +1158,9 @@ namespace OmpSupport
           omp_construct_enum rop = *iter;
           SgOmpClause* sgclause = buildOmpMapClause(att, rop);
           target->get_clauses().push_back(sgclause);
+// #ifdef CONVEY
+          sgclause->set_parent(target); // is This right?
+// #endif /* CONVEY */
         }
       }
       else 
@@ -1049,17 +1223,27 @@ namespace OmpSupport
       case e_task:
         result = new SgOmpTaskStatement(NULL, body); 
         break;
-      case e_target:
+        //    case e_target_teams:
+    case e_target:
         result = new SgOmpTargetStatement(NULL, body); 
-        ROSE_ASSERT (result != NULL);
         break;
-       case e_target_data:
+      case e_target_data:
         result = new SgOmpTargetDataStatement(NULL, body); 
-        ROSE_ASSERT (result != NULL);
         break;
       case e_simd:
         result = new SgOmpSimdStatement(NULL, body); 
-        ROSE_ASSERT (result != NULL);
+        break;
+        // Convey -- add teams and distribute
+      case e_teams:
+        result = new SgOmpTeamsStatement(NULL, body); 
+        break;
+        //      case e_target_teams_distribute_parallel_for:
+        //      case e_distribute_parallel_for:
+        //        result = new SgOmpDistributeParallelForStatement(NULL, body); 
+        //        break;
+        //      case e_target_teams_distribute:
+      case e_distribute:
+        result = new SgOmpDistributeStatement(NULL, body); 
         break;
  
        //Fortran  
@@ -1107,7 +1291,14 @@ namespace OmpSupport
     {
       SgInitializedName* iname = isSgInitializedName((*iter).second);
       ROSE_ASSERT(iname !=NULL);
-      result->get_variables().push_back(buildVarRefExp(iname));
+      // #ifdef CONVEY
+// Convey -- need to set parent pointer
+      SgVarRefExp *vr = buildVarRefExp(iname);
+      vr->set_parent(result);
+      result->get_variables().push_back(vr);
+// #else /* CONVEY */
+//      result->get_variables().push_back(buildVarRefExp(iname));
+// #endif /* CONVEY */
     }
     return result;
   }
@@ -1126,11 +1317,19 @@ namespace OmpSupport
     {
       SgInitializedName* iname = isSgInitializedName((*iter).second);
       ROSE_ASSERT(iname !=NULL);
-      result->get_variables().push_back(buildVarRefExp(iname));
+// Convey -- need to set parent pointer
+      SgVarRefExp *vr = buildVarRefExp(iname);
+      vr->set_parent(result);
+      result->get_variables().push_back(vr);
+// #else /* CONVEY */
+//      result->get_variables().push_back(buildVarRefExp(iname));
+// #endif /* CONVEY */
     }
     result->set_definingDeclaration(result);
     return result;
   }
+
+
   //! Build nodes for combined OpenMP directives:
   //    parallel for
   //    parallel sections
@@ -1224,6 +1423,9 @@ namespace OmpSupport
             SgOmpClause* sgclause = buildOmpNonReductionClause(att, c_clause);
             ROSE_ASSERT(sgclause != NULL);
             first_stmt->get_clauses().push_back(sgclause);
+// #if CONVEY
+            sgclause->set_parent(first_stmt); // is This right?
+// #endif /* CONVEY */
             break;
           }
           // unique clauses allocated to omp for
@@ -1247,6 +1449,9 @@ namespace OmpSupport
             ROSE_ASSERT(sgclause != NULL);
             // TODO parallel workshare 
             isSgOmpClauseBodyStatement(second_stmt)->get_clauses().push_back(sgclause);
+// #if CONVEY
+            sgclause->set_parent(second_stmt); // is This right?
+// #endif /* CONVEY */
             break;
           }
         case e_reduction: //special handling for reduction
@@ -1260,6 +1465,9 @@ namespace OmpSupport
               SgOmpClause* sgclause = buildOmpReductionClause(att, rop);
               ROSE_ASSERT(sgclause != NULL);
               isSgOmpClauseBodyStatement(second_stmt)->get_clauses().push_back(sgclause);
+// #if CONVEY
+              sgclause->set_parent(second_stmt); // is This right?
+// #endif /* CONVEY */
             }
             break;
           }
@@ -1275,6 +1483,9 @@ namespace OmpSupport
               SgOmpClause* sgclause = buildOmpMapClause(att, rop);
               ROSE_ASSERT(sgclause != NULL);
               isSgOmpClauseBodyStatement(second_stmt)->get_clauses().push_back(sgclause);
+// #if CONVEY
+              sgclause->set_parent(second_stmt); // is This right?
+// #endif /* CONVEY */
            }
             break;
           }
@@ -1319,6 +1530,474 @@ This is no perfect solution until we handle preprocessing information as structu
     return first_stmt;
   }
 
+
+    // =======================================================
+
+  //! Build nodes for combined OpenMP directives:
+  //    parallel for
+  //    parallel sections
+  //    parallel workshare //TODO fortran later on
+  // We don't provide dedicated Sage node for combined directives, 
+  // so we separate them in the AST as 1st and 2nd directive statement
+  // the first is always parallel and we return it from the function
+      SgOmpClauseBodyStatement* buildOmpStatementsFromCombinedDirectives(OmpAttribute* att)
+  {
+    ROSE_ASSERT(att != NULL);
+
+    SgOmpTargetStatement *target_statement = NULL;
+    SgOmpTeamsStatement *teams_statement = NULL;
+    SgOmpParallelStatement *parallel_statement = NULL;
+    SgOmpForStatement *for_statement = NULL;
+    SgOmpDoStatement *do_statement = NULL;
+    SgOmpWorkshareStatement *workshare_statement = NULL;
+    SgOmpSectionsStatement *sections_statement = NULL;
+    SgOmpDistributeStatement *distribute_statement = NULL;
+
+    SgOmpClauseBodyStatement *root_statement = NULL;
+
+    SgStatement* body = getOpenMPBlockFromOmpAttribute(att);
+    //Must remove the body from its previous parent
+    removeStatement(body);
+    ROSE_ASSERT(body != NULL);
+
+    omp_construct_enum omp_type = att->getOmpDirectiveType();
+
+    switch (omp_type) {
+    case e_target_teams:
+        teams_statement = new SgOmpTeamsStatement(NULL, body);
+        target_statement = new SgOmpTargetStatement(NULL, teams_statement);
+
+        body->set_parent(teams_statement);
+        teams_statement->set_parent(target_statement);
+
+        setOneSourcePositionForTransformation(teams_statement);
+        setOneSourcePositionForTransformation(target_statement);
+        
+        copyStartFileInfo (att->getNode(), teams_statement, att);
+        copyStartFileInfo (att->getNode(), target_statement, att);
+
+        copyEndFileInfo (att->getNode(), teams_statement, att);
+        copyEndFileInfo (att->getNode(), target_statement, att);
+
+        root_statement = target_statement;
+
+        break;
+
+    case e_target_teams_distribute:
+        distribute_statement = new SgOmpDistributeStatement(NULL, body);
+        teams_statement = new SgOmpTeamsStatement(NULL, distribute_statement);
+        target_statement = new SgOmpTargetStatement(NULL, teams_statement);
+
+        body->set_parent(distribute_statement);
+        distribute_statement->set_parent(teams_statement);
+        teams_statement->set_parent(target_statement);
+
+        setOneSourcePositionForTransformation(distribute_statement);
+        setOneSourcePositionForTransformation(teams_statement);
+        setOneSourcePositionForTransformation(target_statement);
+        
+        copyStartFileInfo (att->getNode(), distribute_statement, att);
+        copyStartFileInfo (att->getNode(), teams_statement, att);
+        copyStartFileInfo (att->getNode(), target_statement, att);
+
+        copyEndFileInfo (att->getNode(), distribute_statement, att);
+        copyEndFileInfo (att->getNode(), teams_statement, att);
+        copyEndFileInfo (att->getNode(), target_statement, att);
+
+        root_statement = target_statement;
+
+        break;
+
+    case e_target_teams_distribute_parallel_for:
+
+        distribute_statement = new SgOmpDistributeStatement(NULL, body);
+        for_statement = new SgOmpForStatement(NULL, distribute_statement);
+        parallel_statement = new SgOmpParallelStatement(NULL, for_statement);
+        teams_statement = new SgOmpTeamsStatement(NULL, parallel_statement);
+        target_statement = new SgOmpTargetStatement(NULL, teams_statement);
+
+        body->set_parent(distribute_statement);
+        distribute_statement->set_parent(for_statement);
+        for_statement->set_parent(parallel_statement);
+        parallel_statement->set_parent(teams_statement);
+        teams_statement->set_parent(target_statement);
+
+        setOneSourcePositionForTransformation(distribute_statement);
+        setOneSourcePositionForTransformation(for_statement);
+        setOneSourcePositionForTransformation(parallel_statement);
+        setOneSourcePositionForTransformation(teams_statement);
+        setOneSourcePositionForTransformation(target_statement);
+        
+        copyStartFileInfo (att->getNode(), distribute_statement, att);
+        copyStartFileInfo (att->getNode(), for_statement, att);
+        copyStartFileInfo (att->getNode(), parallel_statement, att);
+        copyStartFileInfo (att->getNode(), teams_statement, att);
+        copyStartFileInfo (att->getNode(), target_statement, att);
+
+        copyEndFileInfo (att->getNode(), distribute_statement, att);
+        copyEndFileInfo (att->getNode(), for_statement, att);
+        copyEndFileInfo (att->getNode(), parallel_statement, att);
+        copyEndFileInfo (att->getNode(), teams_statement, att);
+        copyEndFileInfo (att->getNode(), target_statement, att);
+
+        root_statement = target_statement;
+
+        break;
+
+    case e_teams_distribute:
+        distribute_statement = new SgOmpDistributeStatement(NULL, body);
+        teams_statement = new SgOmpTeamsStatement(NULL, distribute_statement);
+
+        body->set_parent(distribute_statement);
+        distribute_statement->set_parent(teams_statement);
+
+        setOneSourcePositionForTransformation(distribute_statement);
+        setOneSourcePositionForTransformation(teams_statement);
+        
+        copyStartFileInfo (att->getNode(), distribute_statement, att);
+        copyStartFileInfo (att->getNode(), teams_statement, att);
+
+        copyEndFileInfo (att->getNode(), distribute_statement, att);
+        copyEndFileInfo (att->getNode(), teams_statement, att);
+
+        root_statement = teams_statement;
+
+        break;
+
+    case e_teams_distribute_parallel_for:
+
+        distribute_statement = new SgOmpDistributeStatement(NULL, body);
+        for_statement = new SgOmpForStatement(NULL, distribute_statement);
+        parallel_statement = new SgOmpParallelStatement(NULL, for_statement);
+        teams_statement = new SgOmpTeamsStatement(NULL, parallel_statement);
+
+        body->set_parent(distribute_statement);
+        distribute_statement->set_parent(for_statement);
+        for_statement->set_parent(parallel_statement);
+        parallel_statement->set_parent(teams_statement);
+
+        setOneSourcePositionForTransformation(distribute_statement);
+        setOneSourcePositionForTransformation(for_statement);
+        setOneSourcePositionForTransformation(parallel_statement);
+        setOneSourcePositionForTransformation(teams_statement);
+        
+        copyStartFileInfo (att->getNode(), distribute_statement, att);
+        copyStartFileInfo (att->getNode(), for_statement, att);
+        copyStartFileInfo (att->getNode(), parallel_statement, att);
+        copyStartFileInfo (att->getNode(), teams_statement, att);
+
+        copyEndFileInfo (att->getNode(), distribute_statement, att);
+        copyEndFileInfo (att->getNode(), for_statement, att);
+        copyEndFileInfo (att->getNode(), parallel_statement, att);
+        copyEndFileInfo (att->getNode(), teams_statement, att);
+
+        root_statement = teams_statement;
+
+        break;
+
+    case e_distribute_parallel_for:
+
+        distribute_statement = new SgOmpDistributeStatement(NULL, body);
+        for_statement = new SgOmpForStatement(NULL, distribute_statement);
+        parallel_statement = new SgOmpParallelStatement(NULL, for_statement);
+
+        body->set_parent(distribute_statement);
+        distribute_statement->set_parent(for_statement);
+        for_statement->set_parent(parallel_statement);
+
+        setOneSourcePositionForTransformation(distribute_statement);
+        setOneSourcePositionForTransformation(for_statement);
+        setOneSourcePositionForTransformation(parallel_statement);
+        
+        copyStartFileInfo (att->getNode(), distribute_statement, att);
+        copyStartFileInfo (att->getNode(), for_statement, att);
+        copyStartFileInfo (att->getNode(), parallel_statement, att);
+
+        copyEndFileInfo (att->getNode(), distribute_statement, att);
+        copyEndFileInfo (att->getNode(), for_statement, att);
+        copyEndFileInfo (att->getNode(), parallel_statement, att);
+
+        root_statement = parallel_statement;
+
+        break;
+
+    case e_parallel_for:
+
+        for_statement = new SgOmpForStatement(NULL, body);
+        parallel_statement = new SgOmpParallelStatement(NULL, for_statement);
+
+        body->set_parent(for_statement);
+        for_statement->set_parent(parallel_statement);
+
+        setOneSourcePositionForTransformation(for_statement);
+        setOneSourcePositionForTransformation(parallel_statement);
+        
+        copyStartFileInfo (att->getNode(), for_statement, att);
+        copyStartFileInfo (att->getNode(), parallel_statement, att);
+
+        copyEndFileInfo (att->getNode(), for_statement, att);
+        copyEndFileInfo (att->getNode(), parallel_statement, att);
+
+        root_statement = parallel_statement;
+
+        break;
+
+    case e_parallel_sections:
+        sections_statement = new SgOmpSectionsStatement(NULL, body);
+        parallel_statement = new SgOmpParallelStatement(NULL, for_statement);
+
+        body->set_parent(sections_statement);
+        for_statement->set_parent(parallel_statement);
+
+        setOneSourcePositionForTransformation(sections_statement);
+        setOneSourcePositionForTransformation(parallel_statement);
+        
+        copyStartFileInfo (att->getNode(), sections_statement, att);
+        copyStartFileInfo (att->getNode(), parallel_statement, att);
+
+        copyEndFileInfo (att->getNode(), sections_statement, att);
+        copyEndFileInfo (att->getNode(), parallel_statement, att);
+
+        root_statement = parallel_statement;
+
+        break;
+
+    case e_parallel_do:
+        do_statement = new SgOmpDoStatement(NULL, body);
+        parallel_statement = new SgOmpParallelStatement(NULL, do_statement);
+
+        body->set_parent(do_statement);
+        do_statement->set_parent(parallel_statement);
+
+        setOneSourcePositionForTransformation(do_statement);
+        setOneSourcePositionForTransformation(parallel_statement);
+        
+        copyStartFileInfo (att->getNode(), do_statement, att);
+        copyStartFileInfo (att->getNode(), parallel_statement, att);
+
+        copyEndFileInfo (att->getNode(), do_statement, att);
+        copyEndFileInfo (att->getNode(), parallel_statement, att);
+
+        root_statement = parallel_statement;
+
+        break;
+
+    case e_parallel_workshare:
+        workshare_statement = new SgOmpWorkshareStatement(NULL, body);
+        parallel_statement = new SgOmpParallelStatement(NULL, workshare_statement);
+
+        body->set_parent(workshare_statement);
+        workshare_statement->set_parent(parallel_statement);
+
+        setOneSourcePositionForTransformation(workshare_statement);
+        setOneSourcePositionForTransformation(parallel_statement);
+        
+        copyStartFileInfo (att->getNode(), workshare_statement, att);
+        copyStartFileInfo (att->getNode(), parallel_statement, att);
+
+        copyEndFileInfo (att->getNode(), workshare_statement, att);
+        copyEndFileInfo (att->getNode(), parallel_statement, att);
+
+        root_statement = parallel_statement;
+
+        break;
+
+    default:
+        break;
+    }
+
+    // root_stmt is the parallel statement
+
+    // allocate clauses to them, let the 2nd one have higher priority 
+    // if a clause can be allocated to either of them
+    vector<omp_construct_enum> clause_vector = att->getClauses();
+    std::vector<omp_construct_enum>::iterator citer;
+    for (citer = clause_vector.begin(); citer != clause_vector.end(); citer++)
+    {
+      omp_construct_enum c_clause = *citer;
+      if (!isClause(c_clause))
+      {
+        printf ("Found a construct which is not a clause:%s\n within attr:%p\n", OmpSupport::toString(c_clause).c_str(), att);
+        ROSE_ASSERT(isClause(c_clause));
+        continue;
+      }
+      else
+      {
+        // printf ("Found a clause construct:%s\n", OmpSupport::toString(c_clause).c_str());
+      }
+
+      switch (c_clause)
+      {
+// #ifdef CONVEY
+        // num_teams and thread_limit to omp teams
+        case e_num_teams:
+        case e_thread_limit:
+          {
+              if (!teams_statement) {
+                  printf("Error: buildOmpStatementsFromCombinedDirectives(): unacceptable clause for combined pragma\n");
+              att->print();
+              ROSE_ASSERT(false);
+            }
+            SgOmpClause* sgclause = buildOmpNonReductionClause(att, c_clause);
+            teams_statement->get_clauses().push_back(sgclause);
+            sgclause->set_parent(teams_statement);
+            break;
+          }
+          // unique clauses allocated to omp distribute
+        case e_dist_schedule:
+          {
+              if (!distribute_statement) {
+                  printf("Error: buildOmpStatementsFromCombinedDirectives(): unacceptable clauses for combined pragma\n");
+              att->print();
+              ROSE_ASSERT(false);
+            }
+            SgOmpClause* sgclause = buildOmpNonReductionClause(att, c_clause);
+            distribute_statement->get_clauses().push_back(sgclause);
+            sgclause->set_parent(distribute_statement);
+            break;
+          }
+// #endif /* CONVEY */
+
+        // clauses allocated to omp parallel
+        case e_if:
+        case e_num_threads:
+        case e_default:
+        case e_shared:
+        case e_copyin:
+          {
+            if (!parallel_statement) {
+                printf("Error: buildOmpStatementsFromCombinedDirectives(): unacceptable clauses for combined pragma\n");
+            att->print();
+            ROSE_ASSERT(false);
+            }
+            SgOmpClause* sgclause = buildOmpNonReductionClause(att, c_clause);
+            ROSE_ASSERT(sgclause != NULL);
+            parallel_statement->get_clauses().push_back(sgclause);
+// #if CONVEY
+            sgclause->set_parent(parallel_statement); // is This right?
+// #endif /* CONVEY */
+            break;
+          }
+          // unique clauses allocated to omp for
+        case e_schedule:
+        case e_collapse:
+        case e_ordered_clause:
+          {
+              if (!for_statement && !do_statement) {
+                  printf("Error: buildOmpStatementsFromCombinedDirectives(): unacceptable clauses for combined pragma\n");
+              att->print();
+              ROSE_ASSERT(false);
+              }
+              SgOmpClause* sgclause = buildOmpNonReductionClause(att, c_clause);
+              ROSE_ASSERT(sgclause != NULL);
+              
+              for_statement->get_clauses().push_back(sgclause);
+              sgclause->set_parent(for_statement);
+              break;
+          }
+        case e_private:
+        case e_firstprivate:
+          {
+            SgOmpClause* sgclause = buildOmpNonReductionClause(att, c_clause);
+            ROSE_ASSERT(sgclause != NULL);
+            // put on distribute if present; otherwise on for
+            SgOmpClauseBodyStatement *directive_statement = 
+                distribute_statement ? 
+                (SgOmpClauseBodyStatement *)distribute_statement : 
+                (SgOmpClauseBodyStatement *)for_statement;
+
+            directive_statement->get_clauses().push_back(sgclause);
+            sgclause->set_parent(directive_statement);
+            break;
+          }
+        case e_lastprivate:
+          // case e_nowait: // nowait should not appear with combined directives
+          {
+            SgOmpClause* sgclause = buildOmpNonReductionClause(att, c_clause);
+            ROSE_ASSERT(sgclause != NULL);
+            // TODO parallel workshare 
+            for_statement->get_clauses().push_back(sgclause);
+// #if CONVEY
+            sgclause->set_parent(for_statement); // is This right?
+// #endif /* CONVEY */
+            break;
+          }
+        case e_reduction: //special handling for reduction
+          {
+            std::vector<omp_construct_enum> rops  = att->getReductionOperators();
+            ROSE_ASSERT(rops.size()!=0);
+            std::vector<omp_construct_enum>::iterator iter;
+            for (iter=rops.begin(); iter!=rops.end();iter++)
+            {
+              omp_construct_enum rop = *iter;
+              SgOmpClause* sgclause = buildOmpReductionClause(att, rop);
+              ROSE_ASSERT(sgclause != NULL);
+              for_statement->get_clauses().push_back(sgclause);
+// #if CONVEY
+              sgclause->set_parent(for_statement); // is This right?
+// #endif /* CONVEY */
+            }
+            break;
+          }
+#if 0           
+        case e_map: //special handling for map , no such thing for combined parallel directives. 
+          {
+            std::vector<omp_construct_enum> rops  = att->getMapVariants();
+            ROSE_ASSERT(rops.size()!=0);
+            std::vector<omp_construct_enum>::iterator iter;
+            for (iter=rops.begin(); iter!=rops.end();iter++)
+            {
+              omp_construct_enum rop = *iter;
+              SgOmpClause* sgclause = buildOmpMapClause(att, rop);
+              ROSE_ASSERT(sgclause != NULL);
+              isSgOmpClauseBodyStatement(second_stmt)->get_clauses().push_back(sgclause);
+// #if CONVEY
+              sgclause->set_parent(target_stmt); // is This right?
+// #endif /* CONVEY */
+           }
+            break;
+          }
+#endif 
+        default:
+          {
+            cerr<<"error: unacceptable clause for combined parallel for directive:"<<OmpSupport::toString(c_clause)<<endl;
+            ROSE_ASSERT(false);
+          }
+      }
+    } // end clause allocations 
+
+    /*
+       handle dangling #endif  attached to the loop
+       1. original 
+#ifdef _OPENMP
+#pragma omp parallel for  private(i,k)
+#endif 
+for () ...
+
+2. after splitting
+
+#ifdef _OPENMP
+#pragma omp parallel 
+#pragma omp for  private(i,k)
+#endif 
+for () ...
+
+3. We need to move #endif to omp parallel statement 's after position
+transOmpParallel () will take care of it later on
+
+#ifdef _OPENMP
+#pragma omp parallel 
+#pragma omp for  private(i) reduction(+ : j)
+for (i = 1; i < 1000; i++)
+if ((key_array[i - 1]) > (key_array[i]))
+j++;
+#endif
+This is no perfect solution until we handle preprocessing information as structured statements in AST
+*/
+    movePreprocessingInfo(body, root_statement, PreprocessingInfo::before, PreprocessingInfo::after, true);
+    return root_statement;
+  }
+    //===========================================
   //! for C/C++ replace OpenMP pragma declaration with an SgOmpxxStatement
   void replaceOmpPragmaWithOmpStatement(SgPragmaDeclaration* pdecl, SgStatement* ompstmt)
   {
@@ -1411,6 +2090,26 @@ This is no perfect solution until we handle preprocessing information as structu
               omp_stmt = new SgOmpTaskwaitStatement();
               break;
             }
+// #if CONVEY
+          case e_declare_target:
+            {
+                SgOmpDeclareTargetStatement *s =
+                    new SgOmpDeclareTargetStatement();
+                s->set_definingDeclaration(s);
+                omp_stmt = s;
+                break;
+            }
+          case e_end_declare_target:
+            {
+                SgOmpEndDeclareTargetStatement *s =
+                    new SgOmpEndDeclareTargetStatement();
+                s->set_definingDeclaration(s);
+                omp_stmt = s;
+                break;
+            }
+
+// #endif /* CONVEY */
+
             // with variable list
           case e_threadprivate:
             {
@@ -1436,6 +2135,9 @@ This is no perfect solution until we handle preprocessing information as structu
           case e_target: // OMP-ACC directive
           case e_target_data: 
           case e_simd:  // OMP 4.0 SIMD directive
+// #ifdef CONVEY
+          case e_teams:
+          case e_distribute:
             //fortran
           case e_do:
           case e_workshare:
@@ -1443,6 +2145,17 @@ This is no perfect solution until we handle preprocessing information as structu
               omp_stmt = buildOmpBodyStatement(oa);
               break;
             }
+          case e_target_teams:
+          case e_target_teams_distribute:
+          case e_target_teams_distribute_parallel_for:
+          case e_teams_distribute:
+          case e_teams_distribute_parallel_for:
+          case e_distribute_parallel_for:
+            {
+                omp_stmt = buildOmpStatementsFromCombinedDirectives(oa);
+              break;
+            }
+// #endif /* CONVEY */
           case e_parallel_for:
           case e_parallel_sections:
           case e_parallel_workshare://fortran
@@ -1853,6 +2566,11 @@ This is no perfect solution until we handle preprocessing information as structu
       printf ("Processing OpenMP directives \n");
     }
 
+// #ifdef CONVEY
+    // Convey 
+    clausesToDelete.clear();
+// #endif /* CONVEY */
+
     ROSE_ASSERT(sageFilePtr != NULL);
     if (sageFilePtr->get_openmp() == false)
     {
@@ -1879,6 +2597,17 @@ This is no perfect solution until we handle preprocessing information as structu
     // Build OpenMP AST nodes based on parsing results
     build_OpenMP_AST(sageFilePtr);
 
+// #ifdef CONVEY
+    // Convey 
+    // Delete clauses marked for deletion because they are macros that
+    // got replaced.
+    while (!clausesToDelete.empty()) {
+        SgExpression *expr = *(clausesToDelete.begin());
+        clausesToDelete.erase(clausesToDelete.begin());
+        deepDelete(expr);
+    }
+// #endif /* CONVEY */
+
     // stop here if only OpenMP AST construction is requested
     if (sageFilePtr->get_openmp_ast_only())
     {
@@ -1889,7 +2618,7 @@ This is no perfect solution until we handle preprocessing information as structu
       return;
     }
 
-    lower_omp(sageFilePtr);
+    HtOmpSupport::lower_omp(sageFilePtr);
   }
 
 } // end of the namespace
diff --git a/src/frontend/SageIII/omplexer.ll b/src/frontend/SageIII/omplexer.ll
index 9bc9914..fbcf7dd 100644
--- a/src/frontend/SageIII/omplexer.ll
+++ b/src/frontend/SageIII/omplexer.ll
@@ -78,6 +78,10 @@ num_threads     { /*Can be either a clause name or a variable name */
 ordered         { return cond_return ( ORDERED  ); }
 schedule        { return cond_return ( SCHEDULE ); }
 
+num_teams       {return cond_return ( NUM_TEAMS ); }
+dist_schedule   {return cond_return ( DIST_SCHEDULE ); }
+thread_limit    {return cond_return ( THREAD_LIMIT ); }
+
 static          { return ( STATIC ); }  /*keyword in C/C++ */
 dynamic         { return cond_return ( DYNAMIC ); } 
 guided          { return cond_return ( GUIDED ); }
@@ -107,7 +111,11 @@ reduction       { return cond_return ( REDUCTION ); }
 copyin          { return cond_return ( COPYIN ); }
 
 target          {return cond_return ( TARGET ); }
+teams           {return cond_return ( TEAMS ); }
+distribute      {return cond_return ( DISTRIBUTE ); }
+
 declare         {return cond_return ( DECLARE ); }
+end             {return cond_return ( END ); }
 data            {return cond_return ( DATA ); }
 update          {return cond_return ( UPDATE ); }
 map             {return cond_return ( MAP ); }
@@ -116,6 +124,9 @@ alloc           {return cond_return ( ALLOC ); }
 in              {return cond_return ( IN ); }
 out             {return cond_return ( OUT ); }
 inout           {return cond_return ( INOUT ); }
+to              {return cond_return ( TO ); }
+from            {return cond_return ( FROM ); }
+tofrom          {return cond_return ( TOFROM ); }
 simd            {return cond_return ( SIMD ); }
 safelen         {return cond_return ( SAFELEN ); }
 aligned         {return cond_return ( ALIGNED ); }
@@ -135,6 +146,7 @@ notinbranch     {return cond_return ( NOTINBRANCH ); }
 ":"             { return (':'); }
 "+"             { return ('+'); }
 "*"             { return ('*'); }
+"/"             { return ('/'); }
 "-"             { return ('-'); }
 "&"             { return ('&'); }
 "^"             { return ('^'); }
diff --git a/src/frontend/SageIII/ompparser.yy b/src/frontend/SageIII/ompparser.yy
index 1591c22..b875e76 100644
--- a/src/frontend/SageIII/ompparser.yy
+++ b/src/frontend/SageIII/ompparser.yy
@@ -93,10 +93,11 @@ corresponding C type is union name defaults to YYSTYPE.
         }
 
 /*Some operators have a suffix 2 to avoid name conflicts with ROSE's existing types, We may want to reuse them if it is proper. Liao*/
-%token  OMP PARALLEL IF NUM_THREADS ORDERED SCHEDULE STATIC DYNAMIC GUIDED RUNTIME SECTIONS SINGLE NOWAIT SECTION
+%token  OMP PARALLEL IF NUM_THREADS ORDERED SCHEDULE DIST_SCHEDULE STATIC DYNAMIC GUIDED RUNTIME SECTIONS SINGLE NOWAIT SECTION
         FOR MASTER CRITICAL BARRIER ATOMIC FLUSH TARGET UPDATE
         THREADPRIVATE PRIVATE COPYPRIVATE FIRSTPRIVATE LASTPRIVATE SHARED DEFAULT NONE REDUCTION COPYIN 
-        TASK TASKWAIT UNTIED COLLAPSE AUTO DECLARE DATA DEVICE MAP ALLOC IN OUT INOUT
+        TASK TASKWAIT UNTIED COLLAPSE AUTO DECLARE DATA DEVICE END MAP ALLOC IN OUT INOUT NUM_TEAMS THREAD_LIMIT TEAMS DISTRIBUTE
+        TO FROM TOFROM
         SIMD SAFELEN ALIGNED LINEAR UNIFORM ALIGNED INBRANCH NOTINBRANCH 
         '(' ')' ',' ':' '+' '*' '-' '&' '^' '|' LOGAND LOGOR SHLEFT SHRIGHT PLUSPLUS MINUSMINUS PTR_TO '.'
         LE_OP2 GE_OP2 EQ_OP2 NE_OP2 RIGHT_ASSIGN2 LEFT_ASSIGN2 ADD_ASSIGN2
@@ -116,7 +117,7 @@ corresponding C type is union name defaults to YYSTYPE.
               shift_expr additive_expr multiplicative_expr 
               primary_expr incr_expr unary_expr
               device_clause if_clause num_threads_clause
-              simd_clause
+              simd_clause num_teams_clause thread_limit_clause
 
 %type <itype> schedule_kind
 
@@ -146,7 +147,17 @@ openmp_directive : parallel_directive
                  | flush_directive
                  | threadprivate_directive
                  | section_directive
+                 | declare_target_directive
+                 | end_declare_target_directive
                  | target_directive
+                 | teams_directive
+                 | target_teams_directive
+                 | target_teams_distribute_directive
+                 | target_teams_distribute_parallel_for_directive
+                 | teams_distribute_directive
+                 | teams_distribute_parallel_for_directive
+                 | distribute_directive
+                 | distribute_parallel_for_directive
                  | target_data_directive
                  | simd_directive
                  ;
@@ -536,6 +547,16 @@ target_data_clause : device_clause
                 | if_clause
                 ;
 
+declare_target_directive : /* #pragma */  OMP DECLARE TARGET { 
+                      ompattribute = buildOmpAttribute(e_declare_target,gNode,true); 
+                    }
+                  ;
+
+end_declare_target_directive : /* #pragma */  OMP END DECLARE TARGET { 
+                      ompattribute = buildOmpAttribute(e_end_declare_target,gNode,true); 
+                    }
+                  ;
+
 target_directive: /* #pragma */ OMP TARGET {
                        ompattribute = buildOmpAttribute(e_target,gNode,true);
                        omptype = e_target;
@@ -555,9 +576,207 @@ target_clause_seq : target_clause
 target_clause : device_clause 
                 | map_clause
                 | if_clause
-                | num_threads_clause
+                /* RANDY: CONVEY target does not accept num_threads */
+                /* | num_threads_clause */
                 ;
 
+teams_directive: /* #pragma */ OMP TEAMS {
+                       ompattribute = buildOmpAttribute(e_teams,gNode,true);
+                       omptype = e_teams;
+                     }
+                     teams_clause_optseq 
+                   ;
+
+teams_clause_optseq : /* empty */
+                       | teams_clause_seq
+                       ;
+
+teams_clause_seq : teams_clause
+                    | teams_clause_seq teams_clause
+                    | teams_clause_seq ',' teams_clause
+                    ;
+
+unique_teams_clause : num_teams_clause
+                    | thread_limit_clause
+                    ;
+
+teams_clause : unique_teams_clause
+               | data_default_clause
+               | data_privatization_clause
+               | data_privatization_in_clause
+               | data_sharing_clause
+               | data_reduction_clause
+               ;
+
+target_teams_directive: /* #pragma */ OMP TARGET TEAMS {
+                        ompattribute = buildOmpAttribute(e_target_teams,gNode,true);
+                        omptype = e_target_teams;
+                        }
+                        target_teams_clause_optseq 
+                     ;
+
+target_teams_clause_optseq : /* empty */
+                       | target_teams_clause_seq
+                       ;
+
+target_teams_clause_seq : target_teams_clause
+                        | target_teams_clause_seq target_teams_clause
+                        | target_teams_clause_seq ',' target_teams_clause
+                        ;
+
+target_teams_clause : device_clause 
+                      | map_clause
+                      | if_clause
+                      | teams_clause
+                      ;
+
+distribute_directive: /* #pragma */ OMP DISTRIBUTE {
+                       ompattribute = buildOmpAttribute(e_distribute,gNode,true);
+                       omptype = e_distribute;
+                     }
+                     distribute_clause_optseq 
+                   ;
+
+distribute_clause_optseq : /* empty */
+                       | distribute_clause_seq
+                       ;
+
+distribute_clause_seq : distribute_clause
+                    | distribute_clause_seq distribute_clause
+                    | distribute_clause_seq ',' distribute_clause
+                    ;
+
+distribute_clause : data_privatization_clause
+                    | data_privatization_in_clause
+                    | unique_distribute_clause
+                    ;
+
+unique_distribute_clause : DIST_SCHEDULE '(' STATIC ')' { 
+                             ompattribute->addClause(e_dist_schedule);
+                             ompattribute->setScheduleKind(e_schedule_static);
+                             omptype = e_dist_schedule;
+                           } 
+                           | DIST_SCHEDULE '(' STATIC ',' { 
+                             ompattribute->addClause(e_dist_schedule);
+                             ompattribute->setScheduleKind(e_schedule_static);
+                             omptype = e_dist_schedule;
+                           } expression ')' { 
+                             addExpression("");
+                           }
+                           ;
+
+distribute_parallel_for_directive : /* #pragma */ OMP DISTRIBUTE PARALLEL FOR {
+       ompattribute = buildOmpAttribute(e_distribute_parallel_for,gNode, true);
+     } distribute_parallel_for_clauseoptseq
+                       ;
+
+distribute_parallel_for_clauseoptseq : /* empty */
+                          | distribute_parallel_for_clause_seq
+                          ;
+
+distribute_parallel_for_clause_seq : distribute_parallel_for_clause
+       | distribute_parallel_for_clause_seq distribute_parallel_for_clause
+       | distribute_parallel_for_clause_seq ',' distribute_parallel_for_clause
+       ;
+
+distribute_parallel_for_clause : unique_distribute_clause
+                                 | parallel_for_clause
+                                 ;
+
+
+target_teams_distribute_directive: /* #pragma */ OMP TARGET TEAMS DISTRIBUTE {
+        ompattribute = buildOmpAttribute(e_target_teams_distribute,gNode,true);
+	omptype = e_target_teams_distribute;
+	}
+        target_teams_distribute_clause_optseq 
+        ;
+
+target_teams_distribute_clause_optseq : /* empty */
+        | target_teams_distribute_clause_seq
+        ;
+
+target_teams_distribute_clause_seq : target_teams_distribute_clause
+        | target_teams_distribute_clause_seq target_teams_distribute_clause
+        | target_teams_distribute_clause_seq ',' target_teams_distribute_clause
+                    ;
+
+target_teams_distribute_clause : unique_distribute_clause
+                                 | teams_clause
+                                 | device_clause 
+                                 | map_clause
+                                 | if_clause
+                                 ;
+
+
+target_teams_distribute_parallel_for_directive : /* #pragma */ OMP TARGET TEAMS DISTRIBUTE PARALLEL FOR { 
+    ompattribute = buildOmpAttribute(e_target_teams_distribute_parallel_for,
+                                     gNode, true); 
+  } target_teams_distribute_parallel_for_clauseoptseq
+  ;
+
+target_teams_distribute_parallel_for_clauseoptseq : /* empty */
+                          | target_teams_distribute_parallel_for_clause_seq
+                          ;
+
+target_teams_distribute_parallel_for_clause_seq : 
+          target_teams_distribute_parallel_for_clause
+        | target_teams_distribute_parallel_for_clause_seq 
+             target_teams_distribute_parallel_for_clause
+        | target_teams_distribute_parallel_for_clause_seq ',' 
+             target_teams_distribute_parallel_for_clause
+        ;
+
+target_teams_distribute_parallel_for_clause : unique_distribute_clause
+                                            | unique_teams_clause
+                                            | device_clause 
+                                            | map_clause
+                                            | parallel_for_clause
+                                            ;
+
+teams_distribute_directive: /* #pragma */ OMP TEAMS DISTRIBUTE {
+        ompattribute = buildOmpAttribute(e_teams_distribute,gNode,true);
+	omptype = e_teams_distribute;
+	}
+        teams_distribute_clause_optseq 
+        ;
+
+teams_distribute_clause_optseq : /* empty */
+        | teams_distribute_clause_seq
+        ;
+
+teams_distribute_clause_seq : teams_distribute_clause
+        | teams_distribute_clause_seq teams_distribute_clause
+        | teams_distribute_clause_seq ',' teams_distribute_clause
+                    ;
+
+teams_distribute_clause :   unique_distribute_clause
+                          | teams_clause
+                          ;
+
+
+teams_distribute_parallel_for_directive : /* #pragma */ OMP TEAMS DISTRIBUTE PARALLEL FOR { 
+    ompattribute = buildOmpAttribute(e_teams_distribute_parallel_for,
+                                     gNode, true); 
+  } teams_distribute_parallel_for_clauseoptseq
+  ;
+
+teams_distribute_parallel_for_clauseoptseq : /* empty */
+                          | teams_distribute_parallel_for_clause_seq
+                          ;
+
+teams_distribute_parallel_for_clause_seq : 
+          teams_distribute_parallel_for_clause
+        | teams_distribute_parallel_for_clause_seq 
+             teams_distribute_parallel_for_clause
+        | teams_distribute_parallel_for_clause_seq ',' 
+             teams_distribute_parallel_for_clause
+        ;
+
+teams_distribute_parallel_for_clause : unique_distribute_clause
+	                             | unique_teams_clause
+                                     | parallel_for_clause
+                                     ;
+
 device_clause : DEVICE {
                            ompattribute->addClause(e_device);
                            omptype = e_device;
@@ -580,6 +799,23 @@ num_threads_clause: NUM_THREADS {
                             addExpression("");
                          }
                       ;
+
+num_teams_clause: NUM_TEAMS {
+                           ompattribute->addClause(e_num_teams);
+                           omptype = e_num_teams;
+                         } '(' expression ')' {
+                            addExpression("");
+                         }
+                      ;
+
+thread_limit_clause: THREAD_LIMIT {
+                           ompattribute->addClause(e_thread_limit);
+                           omptype = e_thread_limit;
+                         } '(' expression ')' {
+                            addExpression("");
+                         }
+                      ;
+
 map_clause: MAP {
                           ompattribute->addClause(e_map);
                            omptype = e_map; // use as a flag to see if it will be reset later
@@ -591,13 +827,16 @@ map_clause: MAP {
                           ompattribute->setMapVariant(e_map_inout);  omptype = e_map_inout;  
                        }
                      } 
-                     variable_list ')' { b_within_variable_list =false;} 
+                     map_variable_list ')' { b_within_variable_list =false;} 
 
 map_clause_optseq: /* empty, default to be inout */ { ompattribute->setMapVariant(e_map_inout);  omptype = e_map_inout; /*No effect here???*/ }
                     | ALLOC ':' { ompattribute->setMapVariant(e_map_alloc);  omptype = e_map_alloc; } 
                     | IN     ':' { ompattribute->setMapVariant(e_map_in); omptype = e_map_in; } 
                     | OUT    ':' { ompattribute->setMapVariant(e_map_out); omptype = e_map_out; } 
                     | INOUT  ':' { ompattribute->setMapVariant(e_map_inout); omptype = e_map_inout; } 
+                    | TO     ':' { ompattribute->setMapVariant(e_map_in); omptype = e_map_in; } 
+                    | FROM    ':' { ompattribute->setMapVariant(e_map_out); omptype = e_map_out; } 
+                    | TOFROM  ':' { ompattribute->setMapVariant(e_map_inout); omptype = e_map_inout; } 
                     ;
 
 simd_directive: /* # pragma */ OMP SIMD
@@ -974,8 +1213,8 @@ variable_list : ID_EXPRESSION { if (!addVar((const char*)$1)) YYABORT; }
               ;
 
 /* in C++ (we use the C++ version) */ 
-variable_list : id_expression_opt_dimension
-              | variable_list ',' id_expression_opt_dimension
+map_variable_list : id_expression_opt_dimension
+              | map_variable_list ',' id_expression_opt_dimension
               ;
 
 id_expression_opt_dimension: ID_EXPRESSION { if (!addVar((const char*)$1)) YYABORT; } dimension_field_optseq
@@ -983,14 +1222,31 @@ id_expression_opt_dimension: ID_EXPRESSION { if (!addVar((const char*)$1)) YYABO
 
 /* Parse optional dimension information associated with map(a[0:n][0:m]) Liao 1/22/2013 */
 dimension_field_optseq: /* empty */
+		{ 
+fprintf(stderr,"case of dimension_field_optseq empty\n");
+                   assert (array_symbol != NULL);
+                   SgType* t = array_symbol->get_type();
+                   bool isPointer= (isSgPointerType(t) != NULL );
+                   bool isArray= (isSgArrayType(t) != NULL);
+                   if (isPointer || isArray ) {
+fprintf(stderr,"case of dimension_field_optseq isArray\n");
+                      ompattribute->array_dimensions[array_symbol].push_back( std::make_pair (SageBuilder::buildIntVal(-1),
+			SageBuilder::buildIntVal(-1)));
+	                      } 
+                }
+
                       | dimension_field_seq
                       ;
 
 dimension_field_seq : dimension_field
                     | dimension_field_seq dimension_field
                     ;
-dimension_field: '[' expression {lower_exp = current_exp; } 
-                 ':' expression { upper_exp = current_exp;
+dimension_expression_opt: /* empty */
+  	                { current_exp = SageBuilder::buildIntVal(0); }
+                      | expression
+                      ;
+dimension_field: '[' dimension_expression_opt {lower_exp = current_exp; } 
+                 ':' dimension_expression_opt { upper_exp = current_exp;
                       assert (array_symbol != NULL);
                       SgType* t = array_symbol->get_type();
                       bool isPointer= (isSgPointerType(t) != NULL );
diff --git a/src/frontend/SageIII/sage3.h b/src/frontend/SageIII/sage3.h
index e68a1fd..c42b5f4 100644
--- a/src/frontend/SageIII/sage3.h
+++ b/src/frontend/SageIII/sage3.h
@@ -63,6 +63,9 @@
 //include "ArrayRewrite.h"
 // Liao, 8/11/2009, support for OpenMP lowering
 #include "omp_lowering.h" 
+// #ifdef CONVEY
+#include "ht_omp_lowering.h" 
+// #endif /* CONVEY */
 #else
 // DQ (11/12/2011): This is included in the omp_lowering.h and it is needed in sageInterface.C.
 // #include "astQuery.h"
diff --git a/src/frontend/SageIII/sageInterface/sageInterface.C b/src/frontend/SageIII/sageInterface/sageInterface.C
index e0d23cb..d4d6efa 100644
--- a/src/frontend/SageIII/sageInterface/sageInterface.C
+++ b/src/frontend/SageIII/sageInterface/sageInterface.C
@@ -389,6 +389,24 @@ SageInterface::buildDeclarationSets(SgNode* n)
                void visit (SgNode* node)
                   {
                     SgDeclarationStatement* decl = isSgDeclarationStatement(node);
+                    // Convey
+                    // Skip Omp Directives that masquerade as declarations
+                    if (isSgOmpThreadprivateStatement(decl) ||
+                        isSgOmpDeclareTargetStatement(decl) ||
+                        isSgOmpEndDeclareTargetStatement(decl)) {
+                        return;
+                    }
+
+                    // This breaks rose:
+                    // public: 
+                    //   inline CHtHif(struct CHtHifParams *pParams = 0) : 
+                    //              CHtHifBase(pParams)
+                    //          {}
+                    if (isSgCtorInitializerList(decl)) {
+                        return;
+                    }
+
+
                     if (decl != NULL)
                        {
                          declarationSet->addDeclaration(decl);
@@ -1071,6 +1089,14 @@ SageInterface::get_name ( const SgC_PreprocessorDirectiveStatement* directive )
                break;
              }
 
+          // Convey
+          case V_SgOmpDeclareTargetStatement:
+              name = "omp_declare_target";
+              break;
+          case V_SgOmpEndDeclareTargetStatement:
+              name = "omp_end_declare_target";
+              break;
+
           default:
             // name = "default name (default case reached: not handled)";
                printf ("Warning: default case reached in SageInterface::get_name ( const SgC_PreprocessorDirectiveStatement* directive ), directive = %p = %s \n",
@@ -1101,6 +1127,11 @@ SageInterface::get_name ( const SgDeclarationStatement* declaration )
 
      switch (declaration->variantT())
         {
+          // Convey
+        case V_SgOmpThreadprivateStatement:
+            name = "omp_threadprivate";
+            break;
+
        // DQ (12/28/2011): Added seperate support for new design of template IR nodes.
        // DQ (12/4/2011): Added support for template declarations in the AST.
           case V_SgTemplateMemberFunctionDeclaration:
@@ -13194,6 +13225,7 @@ void SageInterface::replaceSubexpressionWithStatement(SgExpression* from, Statem
       case V_SgUnsignedCharVal: return isSgUnsignedCharVal(expr)->get_value();
       case V_SgShortVal: return (long long)(isSgShortVal(expr)->get_value());
       case V_SgUnsignedShortVal: return isSgUnsignedShortVal(expr)->get_value();
+      case V_SgEnumVal: return (long long)(isSgEnumVal(expr)->get_value());
       case V_SgIntVal: return (long long)(isSgIntVal(expr)->get_value());
       case V_SgUnsignedIntVal: return isSgUnsignedIntVal(expr)->get_value();
       case V_SgLongIntVal: return (long long)(isSgLongIntVal(expr)->get_value());
diff --git a/src/frontend/SageIII/sage_support/sage_support.h b/src/frontend/SageIII/sage_support/sage_support.h
index 80dcebb..0c6bd4b 100644
--- a/src/frontend/SageIII/sage_support/sage_support.h
+++ b/src/frontend/SageIII/sage_support/sage_support.h
@@ -22,6 +22,9 @@
 
 #ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
    #include "omp_lowering.h"
+// #ifdef CONVEY
+   #include "ht_omp_lowering.h"
+// #endif /* CONVEY */
 #endif
 
 #include "attachPreprocessingInfo.h"
diff --git a/src/midend/astProcessing/AstProcessing.C b/src/midend/astProcessing/AstProcessing.C
index ef07b07..72f7002 100644
--- a/src/midend/astProcessing/AstProcessing.C
+++ b/src/midend/astProcessing/AstProcessing.C
@@ -13,7 +13,7 @@
 // causes visits to included files, something that happened from time to
 // time with the old version.
 bool 
-SgTreeTraversal_inFileToTraverse(SgNode* node, bool traversalConstraint, SgFile* fileToVisit)
+SgTreeTraversal_inFileToTraverse(SgNode* node, bool traversalConstraint, SgFile* fileToVisit, bool strict)
    {
   // If traversing without constraint, just continue.
   // if (!traversalConstraint)
@@ -94,6 +94,27 @@ SgTreeTraversal_inFileToTraverse(SgNode* node, bool traversalConstraint, SgFile*
                    && !isSgGlobal(node->get_parent())
                    && !isSgNamespaceDefinitionStatement(node->get_parent());
 
+     // Convey
+     // If strict is set, the file must match or be compiler generated.
+     // Do not include isCode.
+
+     if (strict) {
+#if 0
+         if (isSgCaseOptionStmt(node) || 1) {
+             std::cerr << "rightFile==" << isRightFile << " node kind is " << node->sage_class_name() << std::endl;
+             std::cerr << "   tranformation " << node->get_file_info()->isTransformation() << std::endl;
+             std::cerr << "   generated " << node->get_file_info()->isCompilerGenerated() << std::endl;
+         }
+#endif
+#if 0
+         if (!isRightFile && isCompilerGeneratedOrPartOfTransformation) {
+             std::cerr << node->get_file_info()->get_filenameString() << " " <<
+                 node->unparseToString() << std::endl;
+         }
+#endif
+         return (isRightFile || node->get_file_info()->isTransformation());
+     }
+
      bool traverseNode;
      if (isCompilerGeneratedOrPartOfTransformation || isRightFile || isCode)
           traverseNode = true;
diff --git a/src/midend/astProcessing/AstProcessing.h b/src/midend/astProcessing/AstProcessing.h
index 3377f19..094fca5 100644
--- a/src/midend/astProcessing/AstProcessing.h
+++ b/src/midend/astProcessing/AstProcessing.h
@@ -33,7 +33,7 @@
 
 
 ROSE_DLL_API bool 
-SgTreeTraversal_inFileToTraverse(SgNode* node, bool traversalConstraint, SgFile* fileToVisit);
+SgTreeTraversal_inFileToTraverse(SgNode* node, bool traversalConstraint, SgFile* fileToVisit, bool strict=false);
 
 /*
    GB (06/01/2007):
@@ -101,15 +101,18 @@ public:
 
     SynthesizedAttributeType traverse(SgNode* basenode,
             InheritedAttributeType inheritedValue,
-            t_traverseOrder travOrder = preandpostorder);
+            t_traverseOrder travOrder = preandpostorder,
+            bool strict = false);
 
     SynthesizedAttributeType traverseWithinFile(SgNode* basenode,
             InheritedAttributeType inheritedValue,
-            t_traverseOrder travOrder = preandpostorder);
+            t_traverseOrder travOrder = preandpostorder,
+            bool strict = false);
 
     void traverseInputFiles(SgProject* projectNode,
             InheritedAttributeType inheritedValue,
-            t_traverseOrder travOrder = preandpostorder);
+            t_traverseOrder travOrder = preandpostorder,
+            bool strict = false);
 
     // Default destructor/constructor
     virtual ~SgTreeTraversal();
@@ -162,7 +165,8 @@ protected:
 private:
     void performTraversal(SgNode *basenode,
             InheritedAttributeType inheritedValue,
-            t_traverseOrder travOrder);
+                          t_traverseOrder travOrder,
+                          bool strict=false);
     SynthesizedAttributeType traversalResult();
 
     bool useDefaultIndexBasedTraversal;
@@ -449,7 +453,8 @@ void
 SgTreeTraversal<InheritedAttributeType, SynthesizedAttributeType>::
 traverseInputFiles(SgProject* projectNode,
         InheritedAttributeType inheritedValue,
-        t_traverseOrder travOrder)
+                   t_traverseOrder travOrder,
+                   bool strict)
    {
      const SgFilePtrList& fList = projectNode->get_fileList();
 
@@ -463,7 +468,7 @@ traverseInputFiles(SgProject* projectNode,
      for (SgFilePtrList::const_iterator fl_iter = fList.begin(); fl_iter != fList.end(); fl_iter++)
         {
           ROSE_ASSERT(*fl_iter != NULL);
-          traverseWithinFile((*fl_iter), inheritedValue, travOrder);
+          traverseWithinFile((*fl_iter), inheritedValue, travOrder, strict);
         }
    }
 
@@ -662,7 +667,8 @@ SynthesizedAttributeType
 SgTreeTraversal<InheritedAttributeType, SynthesizedAttributeType>::
 traverseWithinFile(SgNode* node,
         InheritedAttributeType inheritedValue,
-        t_traverseOrder treeTraversalOrder)
+        t_traverseOrder treeTraversalOrder,
+        bool strict)
 {
   // DQ (1/18/2006): debugging
      ROSE_ASSERT(this != NULL);
@@ -687,9 +693,9 @@ traverseWithinFile(SgNode* node,
      // comparisons are much cheaper this way
      fileToVisit = filenode;
 
-     ROSE_ASSERT(SgTreeTraversal_inFileToTraverse(node, traversalConstraint, fileToVisit) == true);
+     ROSE_ASSERT(SgTreeTraversal_inFileToTraverse(node, traversalConstraint, fileToVisit, strict) == true);
      
-     SynthesizedAttributeType synth = traverse(node, inheritedValue, treeTraversalOrder);
+     SynthesizedAttributeType synth = traverse(node, inheritedValue, treeTraversalOrder, strict);
      traversalConstraint = false;
      return synth;
 }
@@ -717,7 +723,7 @@ defaultSynthesizedAttribute(InheritedAttributeType inh)
 template <class InheritedAttributeType, class SynthesizedAttributeType>
 SynthesizedAttributeType SgTreeTraversal<InheritedAttributeType, SynthesizedAttributeType>::
 traverse(SgNode *node, InheritedAttributeType inheritedValue,
-        t_traverseOrder treeTraversalOrder)
+         t_traverseOrder treeTraversalOrder, bool strict)
 {
     // make sure the stack is empty
     synthesizedAttributes->resetStack();
@@ -727,7 +733,7 @@ traverse(SgNode *node, InheritedAttributeType inheritedValue,
     atTraversalStart();
 
     // perform the actual traversal
-    performTraversal(node, inheritedValue, treeTraversalOrder);
+    performTraversal(node, inheritedValue, treeTraversalOrder, strict);
 
     // notify the traversal that we are done
     atTraversalEnd();
@@ -743,7 +749,8 @@ void
 SgTreeTraversal<InheritedAttributeType, SynthesizedAttributeType>::
 performTraversal(SgNode* node,
         InheritedAttributeType inheritedValue,
-        t_traverseOrder treeTraversalOrder)
+        t_traverseOrder treeTraversalOrder,
+        bool strict)
    {
     //cout << "In SgNode version" << endl;
   // 1. node can be a null pointer, only traverse it if !
@@ -752,7 +759,7 @@ performTraversal(SgNode* node,
   // 2. inFileToTraverse is false if we are trying to go to a different file (than the input file)
   //    and only if traverseInputFiles was invoked, otherwise it's always true
 
-     if (node && SgTreeTraversal_inFileToTraverse(node, traversalConstraint, fileToVisit))
+       if (node && SgTreeTraversal_inFileToTraverse(node, traversalConstraint, fileToVisit, strict))
         {
        // In case of a preorder traversal call the function to be applied to each node of the AST
        // GB (7/6/2007): Because AstPrePostProcessing was introduced, a
@@ -802,7 +809,7 @@ performTraversal(SgNode* node,
                 
                     
                    
-                        performTraversal(child, inheritedValue, treeTraversalOrder);
+                      performTraversal(child, inheritedValue, treeTraversalOrder, strict);
                         
                 
                    
diff --git a/src/midend/astProcessing/AstSimpleProcessing.C b/src/midend/astProcessing/AstSimpleProcessing.C
index f503e3e..abc1234 100644
--- a/src/midend/astProcessing/AstSimpleProcessing.C
+++ b/src/midend/astProcessing/AstSimpleProcessing.C
@@ -98,36 +98,36 @@ AstSimpleProcessing::traverse(SgNode* node, t_traverseOrder treeTraversalOrder)
 
 // GB: 7/6/2007
 void 
-AstPrePostProcessing::traverseWithinFile(SgNode* node)
+AstPrePostProcessing::traverseWithinFile(SgNode* node, bool strict)
 {
     static DummyAttribute da;
-    SgTreeTraversal<DummyAttribute, DummyAttribute>::traverseWithinFile(node, da, preandpostorder);
+    SgTreeTraversal<DummyAttribute, DummyAttribute>::traverseWithinFile(node, da, preandpostorder, strict);
 }
 
 // MS: 09/30/02
 void 
-AstSimpleProcessing::traverseWithinFile(SgNode* node, t_traverseOrder treeTraversalOrder)
+AstSimpleProcessing::traverseWithinFile(SgNode* node, t_traverseOrder treeTraversalOrder, bool strict)
 {
     static DummyAttribute da;
-    SgTreeTraversal<DummyAttribute, DummyAttribute>::traverseWithinFile(node, da, treeTraversalOrder);
+    SgTreeTraversal<DummyAttribute, DummyAttribute>::traverseWithinFile(node, da, treeTraversalOrder, strict);
 }
 
 // MS: 04/25/02
 void 
-AstPrePostProcessing::traverseInputFiles(SgProject* projectNode)
+AstPrePostProcessing::traverseInputFiles(SgProject* projectNode, bool strict)
 {
     static DummyAttribute da;
     SgTreeTraversal<DummyAttribute, DummyAttribute>::
-        traverseInputFiles(projectNode, da, preandpostorder);
+        traverseInputFiles(projectNode, da, preandpostorder, strict);
 }
 
 // MS: 04/25/02
 void 
-AstSimpleProcessing::traverseInputFiles(SgProject* projectNode, t_traverseOrder treeTraversalOrder)
+AstSimpleProcessing::traverseInputFiles(SgProject* projectNode, t_traverseOrder treeTraversalOrder, bool strict)
 {
     static DummyAttribute da;
     SgTreeTraversal<DummyAttribute, DummyAttribute>::
-        traverseInputFiles(projectNode, da, treeTraversalOrder);
+        traverseInputFiles(projectNode, da, treeTraversalOrder, strict);
 }
 
 // GB: 06/05/2007
diff --git a/src/midend/astProcessing/AstSimpleProcessing.h b/src/midend/astProcessing/AstSimpleProcessing.h
index 7d7b4ff..f61013c 100644
--- a/src/midend/astProcessing/AstSimpleProcessing.h
+++ b/src/midend/astProcessing/AstSimpleProcessing.h
@@ -25,10 +25,10 @@ public:
     void traverse(SgNode *node);
 
     //! traverse only nodes which represent the same file as where the traversal was started
-    void traverseWithinFile(SgNode *node);
+    void traverseWithinFile(SgNode *node, bool strict = false);
 
     //! traverse only nodes which represent files which were specified on the command line (=input files).
-    void traverseInputFiles(SgProject *projectNode);
+    void traverseInputFiles(SgProject *projectNode, bool strict = false);
 
     friend class AstCombinedPrePostProcessing;
 
@@ -66,10 +66,10 @@ public:
     void traverse(SgNode* node, Order treeTraversalOrder);
 
     //! traverse only nodes which represent the same file as where the traversal was started
-    void traverseWithinFile(SgNode* node, Order treeTraversalOrder);
+    void traverseWithinFile(SgNode* node, Order treeTraversalOrder, bool strict = false);
 
     //! traverse only nodes which represent files which were specified on the command line (=input files).
-    void traverseInputFiles(SgProject* projectNode, Order treeTraversalOrder);
+    void traverseInputFiles(SgProject* projectNode, Order treeTraversalOrder, bool strict = false);
 
     friend class AstCombinedSimpleProcessing;
 
diff --git a/src/midend/programTransformation/astInlining/inlinerSupport.C b/src/midend/programTransformation/astInlining/inlinerSupport.C
index 6da16e0..1ca96d1 100644
--- a/src/midend/programTransformation/astInlining/inlinerSupport.C
+++ b/src/midend/programTransformation/astInlining/inlinerSupport.C
@@ -21,6 +21,7 @@ class FlattenBlocksVisitor: public AstSimpleProcessing {
     if (isSgBasicBlock(node)) {
       SgBasicBlock* c = isSgBasicBlock(node);
       SgStatementPtrList newStatements;
+
       for (SgStatementPtrList::const_iterator i = c->get_statements().begin();
            i != c->get_statements().end(); ++i) {
         if (isSgBasicBlock(*i)) {
@@ -47,7 +48,23 @@ class FlattenBlocksVisitor: public AstSimpleProcessing {
         (*i)->set_parent(c);
       }
       c->get_statements() = newStatements;
-      c->get_symbol_table()->get_table()->clear();
+
+
+      // Convey -- HACK ALERT
+
+      // Abandon old symbol table.   Cannot clear it because old symbols
+      // are still left around and will fail the child in parent's children
+      // test.   This is not ideal, and leaves even more "garbage" lying
+      // around.   If the symbol_table is null (rather than empty), 
+      // rebuildSymbolTable() allocates a new one.
+      //
+      // Deleting the symbols that were in the old table before clearing
+      // the table did not work because there are references to them 
+      // still lying around as well.
+
+      // c->get_symbol_table()->get_table()->clear();
+      c->set_symbol_table(0);
+
       SageInterface::rebuildSymbolTable(c);
     }
   }
@@ -60,6 +77,12 @@ void flattenBlocks(SgNode* n) {
   FlattenBlocksVisitor().traverse(n, postorder);
 }
 
+// Convey
+// Same as above, but limited to input files only
+void flattenBlocksInInputFiles(SgProject* n) {
+    FlattenBlocksVisitor().traverseInputFiles(n, postorder, true /* strict */);
+}
+
 // Internal routine to check whether a given variable declaration is a
 // member variable.
 bool isMemberVariable(const SgNode& in) {
diff --git a/src/midend/programTransformation/astInlining/inlinerSupport.h b/src/midend/programTransformation/astInlining/inlinerSupport.h
index 21c0f2b..e92315e 100644
--- a/src/midend/programTransformation/astInlining/inlinerSupport.h
+++ b/src/midend/programTransformation/astInlining/inlinerSupport.h
@@ -28,6 +28,10 @@ ROSE_DLL_API bool hasAddressTaken(SgExpression* expr, SgNode* root);
 //! it may extend variable lifetimes to the end of the outer block of code.
 ROSE_DLL_API void flattenBlocks(SgNode* n);
 
+// Convey
+// Same as above, but limited to input files only
+void flattenBlocksInInputFiles(SgProject* n);
+
 //! Internal routine to check whether a given variable declaration is a
 //! member variable.
 ROSE_DLL_API bool isMemberVariable(const SgNode& in);
diff --git a/src/midend/programTransformation/astOutlining/Check.cc b/src/midend/programTransformation/astOutlining/Check.cc
index 462a9cf..abf73fd 100644
--- a/src/midend/programTransformation/astOutlining/Check.cc
+++ b/src/midend/programTransformation/astOutlining/Check.cc
@@ -25,6 +25,28 @@ checkType (const SgStatement* s)
   if (s)
     switch (s->variantT ())
       {
+// #ifdef CONVEY
+      case V_SgOmpParallelStatement:
+      case V_SgOmpSectionsStatement:
+      case V_SgOmpTaskStatement:
+      case V_SgOmpForStatement:
+      case V_SgOmpDoStatement:
+      case V_SgOmpBarrierStatement:
+      case V_SgOmpFlushStatement:
+      case V_SgOmpThreadprivateStatement:
+      case V_SgOmpTaskwaitStatement:
+      case V_SgOmpSingleStatement:
+      case V_SgOmpMasterStatement:
+      case V_SgOmpAtomicStatement:
+      case V_SgOmpOrderedStatement:
+      case V_SgOmpCriticalStatement:
+      case V_SgOmpTargetStatement:
+      case V_SgOmpTeamsStatement:
+      case V_SgOmpDistributeStatement:
+      case V_SgOmpDistributeParallelForStatement:
+      case V_SgOmpTargetDataStatement:
+// #endif /* CONVEY */
+
       case V_SgArithmeticIfStatement:
       case V_SgAssociateStatement:
       case V_SgBasicBlock:
diff --git a/src/midend/programTransformation/astOutlining/GenerateFunc.cc b/src/midend/programTransformation/astOutlining/GenerateFunc.cc
index cbfc041..8e7bf77 100644
--- a/src/midend/programTransformation/astOutlining/GenerateFunc.cc
+++ b/src/midend/programTransformation/astOutlining/GenerateFunc.cc
@@ -609,6 +609,10 @@ createUnpackDecl (SgInitializedName* param, // the function parameter
         }
     }
 
+// #ifdef CONVEY
+    local_val = 0;
+// #endif /* CONVEY */
+
     SgVariableDeclaration* decl;
     if( isSgArrayType( local_type->stripType( SgType::STRIP_TYPEDEF_TYPE ) ) )
     {   // The original variable was no statically allocated and passed as private or firstprivate
diff --git a/src/midend/programTransformation/ompLowering/Makefile_variables b/src/midend/programTransformation/ompLowering/Makefile_variables
index 2fed06d..99e9c29 100644
--- a/src/midend/programTransformation/ompLowering/Makefile_variables
+++ b/src/midend/programTransformation/ompLowering/Makefile_variables
@@ -1,6 +1,7 @@
 
 mptOmpLowering_la_sources=\
-	$(mptOmpLoweringPath)/omp_lowering.cpp
+	$(mptOmpLoweringPath)/omp_lowering.cpp\
+	$(mptOmpLoweringPath)/ht_omp_lowering.cpp
 
 # avoid using libtool for libxomp.a since it will be directly linked to executable
 mptOmpLowering_lib_ltlibraries=\
@@ -18,6 +19,7 @@ libxomp_la_SOURCES=\
 
 mptOmpLowering_includeHeaders=\
 	$(mptOmpLoweringPath)/omp_lowering.h \
+	$(mptOmpLoweringPath)/ht_omp_lowering.h \
 	$(mptOmpLoweringPath)/libgomp_g.h \
 	$(mptOmpLoweringPath)/libompc.h \
 	$(mptOmpLoweringPath)/libxomp.h \
diff --git a/src/midend/programTransformation/ompLowering/omp_lowering.cpp b/src/midend/programTransformation/ompLowering/omp_lowering.cpp
index 79c09bd..b1463dc 100644
--- a/src/midend/programTransformation/ompLowering/omp_lowering.cpp
+++ b/src/midend/programTransformation/ompLowering/omp_lowering.cpp
@@ -4434,6 +4434,13 @@ static void insertInnerThreadBlockReduction(SgOmpClause::omp_reduction_operator_
       Rose_STL_Container<SgNode*>::iterator loopIter = loops.begin();
       for (; loopIter!= loops.end(); loopIter++)
       {
+        // Convey -- skip null initializiation
+        SgForStatement *fs = isSgForStatement(*loopIter);
+        if (!fs) continue;
+        SgStatementPtrList &init = fs->get_init_stmt();
+        if (init.size() != 1) continue;
+        if (isSgNullStatement(init.front())) continue;
+
         SgInitializedName* index_var = getLoopIndexVariable(*loopIter);
         ROSE_ASSERT (index_var != NULL);
         SgScopeStatement* var_scope = index_var->get_scope();
diff /dev/null b/src/midend/programTransformation/ompLowering/ht_omp_lowering.h
--- /dev/null	2015-02-03 09:04:16.331999156 -0600
+++ b/src/midend/programTransformation/ompLowering/ht_omp_lowering.h	2015-02-09 15:44:18.242471353 -0600
@@ -0,0 +1,201 @@
+#include "ASTtools.hh"
+#include "astQuery.h"
+//#include "sage3basic.h"
+
+/*!
+ * Translation (directive lowering) support for OpenMP 3.0 C/C++
+ *
+ *  Like other OpenMP related work within ROSE, 
+ *  all things go to the OmpSupport namespace to avoid conflicts
+ * Liao, 8/10/2009
+ */
+#ifndef HT_OMP_LOWERING_H
+#define HT_OMP_LOWERING_H 
+namespace HtOmpSupport
+{
+
+  // OpenMP version info.
+  extern bool enable_accelerator;  
+
+  //! makeDataSharingExplicit() can call some of existing functions for some work in OmpSupport namespace by Hongyi 07/16/2012
+  //! TODO: add a function within the OmpSupport namespace, the function should transform the AST, so all variables' data-sharing attributes are explicitied represented in the AST. ROSE has dedicated AST nodes for OpenMP directives and the associated clauses, such as private, shared, reduction.
+
+
+  int patchUpSharedVariables(SgFile* );
+  // TODO:  patchUpDefaultVariables(SgFile* );
+
+  int makeDataSharingExplicit( SgFile* );   
+
+  // last edited by Hongyi on 07/24/2012. 
+
+  //! The type of target runtime libraries (not yet in use)
+  // We support both Omni and GCC OpenMP runtime libraries
+  enum omp_rtl_enum 
+  {
+    e_gomp,
+    e_omni,
+    e_last_rtl
+  };
+  extern unsigned int nCounter; // translation generated variable counter, used to avoid name collision
+
+  extern omp_rtl_enum rtl_type; 
+  typedef std::map<const SgVariableSymbol *, SgVariableSymbol *> VariableSymbolMap_t;
+
+  void commandLineProcessing(std::vector<std::string> &argvList);
+
+  //! The top level interface to translate OpenMP directives
+  void lower_omp(SgSourceFile*);
+
+
+  //! Insert #include "xxx.h", the interface of a runtime library to the compiler
+  void insertRTLHeaders(SgSourceFile*);
+
+  //! Insert runtime init and terminate routines to main() entry
+  void insertRTLinitAndCleanCode(SgSourceFile* ); 
+
+  //! A driver to traverse AST trees and invoke individual translators for OpenMP constructs, (not in use)
+  //! Postorder is preferred. 
+  class translationDriver: public AstSimpleProcessing
+  { 
+    protected:
+      void visit(SgNode*);
+  }; //translationDriver
+
+//! Create a function named 'func_name_str', with a parameter list from 'syms'
+SgFunctionDeclaration *
+generateFunction ( SgBasicBlock* s,  // block to be outlined
+                   const std::string& func_name_str, // function name provided
+                   const ASTtools::VarSymSet_t& syms,
+                   const ASTtools::VarSymSet_t& pdSyms,
+                   const std::set< SgInitializedName *>& restoreVars,
+                   SgClassDeclaration* struct_decl,
+                   SgScopeStatement* scope,
+                   bool add_htc_parameters);
+
+  //! Translate omp parallel
+  void transOmpParallel(SgNode* node);
+
+  //! Translate omp parallel under "omp target"
+  void transOmpTargetParallel(SgNode* node);
+
+  //! Translate omp sections 
+  void transOmpSections(SgNode* node);
+
+  //! Translate omp task
+  void transOmpTask(SgNode* node);
+
+  //! Translate omp for or omp do loops
+  void transOmpLoop(SgNode* node);
+
+  //! Translate omp for or omp do loops affected by the "omp target" directive, Liao 1/28/2013
+  void transOmpTargetLoop(SgNode* node);
+
+  //! Translate Fortran omp do
+  //void transOmpDo(SgNode* node);
+
+  //! Translate "omp target"
+  void transOmpTarget(SgNode* node);
+
+  //! Translate "omp target data"
+  void transOmpTargetData(SgNode* node);
+
+
+  //! Translate omp barrier
+  void transOmpBarrier(SgNode* node);
+
+  //! Translate omp flush 
+  void transOmpFlush(SgNode* node);
+
+  //! Translate omp taskwait
+  void transOmpTaskwait(SgNode* node);
+
+  //! Translate omp threadprivate
+  void transOmpThreadprivate(SgNode* node);
+
+  //! Translate the ordered directive (not the ordered clause)
+  void transOmpOrdered(SgNode* node);
+  //! Translate omp atomic
+  void transOmpAtomic(SgNode* node);
+  //! Translate omp critical 
+  void transOmpCritical(SgNode* node);
+  //! Translate omp master 
+  void transOmpMaster(SgNode* node);
+  //! Translate omp single 
+  void transOmpSingle(SgNode* node);
+
+  //! A helper function to generate implicit or explicit task for either omp parallel or omp task
+  // It calls the ROSE AST outliner internally. 
+  SgFunctionDeclaration* generateOutlinedTask(SgNode* node, std::string& wrapper_name, std::set<SgVariableSymbol*>& syms);
+
+  //! Translate OpenMP variables associated with an OpenMP pragma, such as private, firstprivate, lastprivate, reduction, etc. bb1 is the translation generated code block in which the variable handling statements will be inserted. Original loop upper bound is needed for implementing lastprivate (check if it is the last iteration). withinAcceleratorModel means if we only translate private() variables, used to support accelerator model
+  void transOmpVariables(SgStatement * ompStmt, SgBasicBlock* bb1, SgExpression* orig_loop_upper = NULL, bool withinAcceleratorModel= false);
+
+  //! Collect all variables from OpenMP clauses associated with an omp statement: private, reduction, etc 
+  SgInitializedNamePtrList collectAllClauseVariables (SgOmpClauseBodyStatement * clause_stmt);
+
+  //! Collect variables from a particular type of OpenMP clauses associated with an omp statement: private, reduction, etc 
+  SgInitializedNamePtrList collectClauseVariables (SgOmpClauseBodyStatement * clause_stmt, const VariantT& vt);
+
+  //! Collect variables from given types of OpenMP clauses associated with an omp statement: private, reduction, etc 
+  SgInitializedNamePtrList collectClauseVariables (SgOmpClauseBodyStatement * clause_stmt, const VariantVector& vvt);
+
+  //! Check if a variable is in a variable list of a given clause type
+  bool isInClauseVariableList(SgInitializedName* var, SgOmpClauseBodyStatement * clause_stmt, const VariantT& vt);
+
+  //! Check if a variable is in variable lists of given clause types
+  bool isInClauseVariableList(SgInitializedName* var, SgOmpClauseBodyStatement * clause_stmt, const VariantVector& vvt);
+
+  //! Replace references to oldVar within root with references to newVar, return the number of references replaced.
+  int replaceVariableReferences(SgNode* root, SgVariableSymbol* oldVar, SgVariableSymbol* newVar);
+
+  //! Replace variable references within root based on a map from old symbols to new symbols
+  int replaceVariableReferences(SgNode* root,  VariableSymbolMap_t varRemap);
+  // I decided to reuse the existing Outliner work instead of coding a new one
+  //SgFunctionDeclaration* generateOutlinedFunction(SgNode* node);
+
+  //! Add a variable into a non-reduction clause of an OpenMP statement, create the clause transparently if it does not exist
+  void addClauseVariable(SgInitializedName* var, SgOmpClauseBodyStatement * clause_stmt, const VariantT& vt);
+
+  //! Build a non-reduction variable clause for a given OpenMP directive. It directly returns the clause if the clause already exists
+  SgOmpVariablesClause* buildOmpVariableClause(SgOmpClauseBodyStatement * clause_stmt, const VariantT& vt);
+
+  //! Check if an OpenMP statement has a clause of type vt
+  bool hasClause(SgOmpClauseBodyStatement* clause_stmt, const VariantT & vt);
+
+  //! Get OpenMP clauses from an eligible OpenMP statement
+  Rose_STL_Container<SgOmpClause*>  getClause(SgOmpClauseBodyStatement* clause_stmt, const VariantT & vt);
+
+  //! Check if an omp for/do loop use static schedule or not, including: default schedule, or schedule(static[,chunk_size]) 
+  bool useStaticSchedule(SgOmpClauseBodyStatement* omp_loop);
+
+  //! Return a reduction variable's reduction operation type
+  SgOmpClause::omp_reduction_operator_enum getReductionOperationType(SgInitializedName* init_name, SgOmpClauseBodyStatement* clause_stmt);
+
+  //! Create an initial value according to reduction operator type
+  SgExpression* createInitialValueExp(SgOmpClause::omp_reduction_operator_enum r_operator);
+
+  //! Generate GOMP loop schedule start function's name
+  std::string generateGOMPLoopStartFuncName (bool isOrdered, SgOmpClause::omp_schedule_kind_enum s_kind);
+
+  //! Generate GOMP loop schedule next function's name
+  std::string generateGOMPLoopNextFuncName (bool isOrdered, SgOmpClause::omp_schedule_kind_enum s_kind);
+
+  //! Convert a schedule kind enum value to a small case string
+  std::string toString(SgOmpClause::omp_schedule_kind_enum s_kind);
+
+  //! Patch up private variables for omp for. The reason is that loop indices should be private by default and this function will make this explicit
+  int patchUpPrivateVariables(SgFile*);
+
+  //! Patch up firstprivate variables for omp task. The reason is that the specification 3.0 defines rules for implicitly determined data-sharing attributes and this function will make the firstprivate variable of omp task explicit.
+  int patchUpFirstprivateVariables(SgFile*);
+
+  //! Collect threadprivate variables within the current project, return a set to avoid duplicated elements. No input parameters are needed since it finds match from memory pools
+  std::set<SgInitializedName*> collectThreadprivateVariables();
+
+  //! Special handling when trying to build and insert a variable declaration into a BB within Fortran OpenMP code
+  SgVariableDeclaration * buildAndInsertDeclarationForOmp(const std::string &name, SgType *type, SgInitializer *varInit, SgBasicBlock *orig_scope);
+  //! Find an enclosing parallel region or function definition's body
+  SgBasicBlock* getEnclosingRegionOrFuncDefinition (SgNode *);
+} // end namespace OmpSupport  
+
+#endif //HT_OMP_LOWERING_H
diff /dev/null b/src/midend/programTransformation/ompLowering/ht_omp_lowering.cpp
--- /dev/null	2015-02-03 09:04:16.331999156 -0600
+++ b/src/midend/programTransformation/ompLowering/ht_omp_lowering.cpp	2015-02-09 15:44:18.247471558 -0600
@@ -0,0 +1,5533 @@
+#if 0
+// tps (01/14/2010) : Switching from rose.h to sage3.
+#include "sage3basic.h"
+#include "sageBuilder.h"
+#include "Outliner.hh"
+#include "ht_omp_lowering.h"
+#include "HtcAttributes.h"
+#include "HtSageUtils.h"
+
+using namespace std;
+using namespace SageInterface;
+using namespace SageBuilder;
+
+extern bool htc_do_split;
+
+// SgFunctionDeclaration is an outlined region.   SgStatement is the
+// region or function that encloses it.
+static map<SgFunctionDeclaration *, SgStatement *> enclosing_regions;
+// SgStatement is an SgOmpParallelStmt.   SgFunctionDeclaration is the
+// outlined function created for it.
+static map<SgStatement *, SgFunctionDeclaration *> outlined_regions;
+
+// This is a hack to pass the number of CUDA loop iteration count around
+// When translating "omp target" , we need to calculate the number of thread blocks needed.
+// To do that, we need to know how many CUDA threads are needed.
+// We think the number of CUDA threads is the iteration count of the parallelized CUDA loop (peeled off), assuming increment is always 1
+//TODO  Also, the incremental value should be irrevelvant?
+// The loop will be transformed away when we call transOmpTargtLoop since we use bottom-up translation
+// So the loop iteration count needs to be stored globally before transOmpTarget() is called. 
+static SgExpression* cuda_loop_iter_count_1 = NULL;
+
+// this is another hack to pass the reduction variables for accelerator model directives
+// We use bottom-up translation for AST with both omp parallel and omp for.
+// reduction is implemented using a two level reduction method: inner thread block level + beyond block level
+// We save the per-block variable and its reduction type integer into a map when generating inner block level reduction.
+// We use the map to help generate beyond block level reduction
+static std::map<SgVariableSymbol* , int> per_block_reduction_map;
+
+// we don't know where to insert the declarations when they are generated as part of transOmpTargetLoop
+// we have to save them and insert them later when kernel launch statement is generated as part of transOmpTargetParallel
+static std::vector<SgVariableDeclaration*> per_block_declarations;
+
+#define ENABLE_XOMP 1  // Enable the middle layer (XOMP) of OpenMP runtime libraries
+  //! Generate a symbol set from an initialized name list, 
+  //filter out struct/class typed names
+static void convertAndFilter (const SgInitializedNamePtrList input, ASTtools::VarSymSet_t& output)
+  {
+    for (SgInitializedNamePtrList::const_iterator iter =  input.begin(); iter != input.end(); iter++)
+    {
+      const SgInitializedName * iname = *iter;
+      SgVariableSymbol* symbol = isSgVariableSymbol(iname->get_symbol_from_symbol_table ()); 
+      ROSE_ASSERT (symbol != NULL);
+      if (! isSgClassType(symbol->get_type()))
+        output.insert(symbol);
+    }
+  }
+
+static bool isInTargetRegion(SgNode *node) {
+
+    SgNode *parent = node->get_parent();
+    while (parent && !isSgFunctionDefinition(parent)) {
+        if (isSgOmpTargetStatement(parent) ||
+            isSgOmpTargetDataStatement(parent)) {
+            return true;
+        }
+        parent = parent->get_parent();
+    }
+    
+    return false;
+}
+
+
+namespace HtOmpSupport
+{ 
+  omp_rtl_enum rtl_type = e_gomp; /* default to  generate code targetting gcc's gomp */
+  bool enable_accelerator = false; /* default is to not recognize and lowering OpenMP accelerator directives */
+
+  unsigned int nCounter = 0;
+  //------------------------------------
+  // Add include "xxxx.h" into source files, right before the first statement from users
+  // Lazy approach: assume all files will contain OpenMP runtime library calls
+  // TODO: (low priority) a better way is to only insert Headers when OpenMP is used.
+  // 2/1/2008, try to use MiddleLevelRewrite to parse the content of the header, which
+  //  should generate function symbols used for runtime function calls 
+  //  But it is not stable!
+
+ //! This makeDataSharingExplicit() is added by Hongyi on July/23/2012. 
+ //! Consider private, firstprivate, lastprivate, shared, reduction  is it correct?@Leo
+ //TODO: consider the initialized name of variable in function call or definitions  
+ 
+   /** Algorithm for patchUpSharedVariables edited by Hongyi Ma on August 7th 2012
+   *   1. find all variables references in  parallel region
+   *   2. find all varibale declarations in this parallel region
+   *   3. check whether these variables has been in private or shared clause already
+   *   4. if not, add them into shared clause
+  */
+ 
+  //! function prototypes for  patch up shared variables 
+
+/*    Get name of varrefexp  */
+string getName( SgNode * n )
+{
+    string name;
+    SgVarRefExp * var = isSgVarRefExp( n );
+    if ( var )
+        name = var->get_symbol()->get_name().getString();
+    
+    return name;
+}
+
+   /*    Remove duplicate list entries  */
+void getUnique( Rose_STL_Container< SgNode* > & list )
+{
+    Rose_STL_Container< SgNode* >::iterator start = list.begin();
+    unsigned int size = list.size();
+    unsigned int i, j;
+
+    if ( size > 1 )
+    {
+        for ( i = 0; i < size - 1; i++ )
+        {
+            j = i + 1;
+            while ( j < size )
+            {
+               SgVarRefExp* iis = isSgVarRefExp( list.at(i) );
+               SgVarRefExp* jjs = isSgVarRefExp( list.at(j) );
+
+               SgInitializedName* is = isSgInitializedName( iis->get_symbol()->get_declaration() );
+               SgInitializedName* js = isSgInitializedName( jjs->get_symbol()->get_declaration() );
+                if ( is == js )
+                {
+                    list.erase( start + j );
+                    size--;
+                    continue;
+                }
+
+                j++;
+            }
+        }
+    }
+}
+/* the end of getUnique name */
+
+ /* gather variable references from remaining expressions */
+
+
+void gatherReferences( const Rose_STL_Container< SgNode* >& expr, Rose_STL_Container< SgNode* >& vars)
+{
+ Rose_STL_Container< SgNode* >::const_iterator iter = expr.begin();
+ 
+  while (iter != expr.end() )
+  {
+     
+     Rose_STL_Container< SgNode* > tempList = NodeQuery::querySubTree(*iter, V_SgVarRefExp );
+      
+     Rose_STL_Container< SgNode* >::iterator ti = tempList.begin();
+     while ( ti != tempList.end() )
+       {
+         vars.push_back( *ti );
+         ti++;
+       }
+     iter++;
+         
+ 
+  }
+   /* then remove the duplicate variables */
+   
+  getUnique( vars );
+
+
+
+} 
+
+ /* the end of gatherReferences function*/
+
+  //! end of function prototypes for patch up shared variables
+          
+   //! patch up all variables to make them explicit in data-sharing explicit 
+  
+   int patchUpSharedVariables(SgFile* file)
+        {
+
+
+           int result = 0; // record for the number of shared variables added
+
+           ROSE_ASSERT( file != NULL );
+           Rose_STL_Container< SgNode* > allParallelRegion = NodeQuery::querySubTree( file, V_SgOmpParallelStatement );
+           Rose_STL_Container< SgNode* >::iterator  allParallelRegionItr = allParallelRegion.begin();
+           
+           for( ; allParallelRegionItr != allParallelRegion.end(); allParallelRegionItr++ )
+           {
+             //! gather all expressions statements
+                Rose_STL_Container< SgNode* > expressions = NodeQuery::querySubTree( *allParallelRegionItr, V_SgExprStatement );
+             //! store all variable references
+                Rose_STL_Container< SgNode* > allRef;   
+                gatherReferences(expressions, allRef );
+  
+             //!find all local variables in parallel region 
+               Rose_STL_Container< SgNode* > localVariables = NodeQuery::querySubTree( *allParallelRegionItr, V_SgVariableDeclaration );
+               
+              //! check variables are not local, not variables in clauses already
+             
+              Rose_STL_Container< SgNode* >::iterator allRefItr = allRef.begin();
+              while( allRefItr != allRef.end() )
+               {
+                    SgVarRefExp* item = isSgVarRefExp( *allRefItr );
+                    string varName = item->get_symbol()->get_name().getString();
+                    
+                    Rose_STL_Container< SgNode* >::iterator localVariablesItr = localVariables.begin();
+                   
+                    bool isLocal = false; // record whether this variable should be added into shared clause
+
+                    while( localVariablesItr != localVariables.end() )
+                      {
+                             SgInitializedNamePtrList vars = ((SgVariableDeclaration*)(*localVariablesItr))->get_variables();
+ 
+                            string localName = vars.at(0)->get_name().getString();
+                            if( varName == localName )
+                            {
+                              isLocal = true;
+                            }             
+                         localVariablesItr++;
+                                           
+                      }
+                    
+                    bool isInPrivate = false;
+                    SgInitializedName* reg = isSgInitializedName( item->get_symbol()->get_declaration() );
+                   
+                    isInPrivate = isInClauseVariableList( reg, isSgOmpClauseBodyStatement( *allParallelRegionItr ), V_SgOmpPrivateClause);
+                    
+                    bool isInShared = false;
+                 
+                    isInShared = isInClauseVariableList( reg, isSgOmpClauseBodyStatement( *allParallelRegionItr ), V_SgOmpSharedClause );
+                  
+                    bool isInFirstprivate = false;
+           
+                    isInFirstprivate = isInClauseVariableList( reg, isSgOmpClauseBodyStatement( *allParallelRegionItr ), V_SgOmpFirstprivateClause );
+ 
+                    bool isInReduction = false;
+                  
+                    isInReduction = isInClauseVariableList( reg, isSgOmpClauseBodyStatement( *allParallelRegionItr ), V_SgOmpReductionClause );
+     
+                    if( !isLocal && !isInShared && !isInPrivate && !isInFirstprivate && ! isInReduction )
+                    {
+                     std::cout<<" the insert variable is: "<<item->unparseToString()<<std::endl;
+                      addClauseVariable( reg, isSgOmpClauseBodyStatement( * allParallelRegionItr ), V_SgOmpSharedClause );
+                      result++; 
+                     std::cout<<" successfully !"<<std::endl;
+                    }
+                   allRefItr++;                 
+               }          
+      
+  
+           } // end of all parallel region  
+                  
+             return result;
+       } // the end of patchUpSharedVariables()
+          
+
+
+
+
+  
+
+
+            
+         
+   
+   //! make all data-sharing attribute explicit 
+
+   int makeDataSharingExplicit(SgFile* file)
+    {
+       int result = 0; // to record the number of varbaile added 
+       ROSE_ASSERT(file != NULL );
+       
+       int p = patchUpPrivateVariables(file); // private variable first
+   
+       int f = patchUpFirstprivateVariables(file);// then firstprivate variable
+  
+       int s = patchUpSharedVariables(file);// consider shared variables 
+
+     
+      //TODO:  patchUpDefaultVariables(file);  
+       
+    
+      result = p + f  + s;
+      return result;
+
+   }  //! the end of makeDataSharingExplicit() 
+
+                          
+  void insertRTLHeaders(SgSourceFile* file)
+  {
+    ROSE_ASSERT(file != NULL);    
+    SgGlobal* globalscope = file->get_globalScope() ; //isSgGlobal(*i);
+    ROSE_ASSERT (globalscope != NULL);
+#ifdef ENABLE_XOMP
+      SageInterface::insertHeader("libxomp.h",PreprocessingInfo::after,false,globalscope);
+    if (enable_accelerator)  // include inlined CUDA device codes
+      SageInterface::insertHeader("xomp_cuda_lib_inlined.cu",PreprocessingInfo::after,false,globalscope);
+#else    
+    if (rtl_type == e_omni)
+      SageInterface::insertHeader("ompcLib.h",PreprocessingInfo::after,false,globalscope);
+    else if (rtl_type == e_gomp)
+      SageInterface::insertHeader("libgomp_g.h",PreprocessingInfo::after,false,globalscope);
+    else
+      ROSE_ASSERT(false);
+#endif      
+  }
+
+  //----------------------------
+  //tasks:
+  // * find the main entry for the application
+  // * add (int argc, char *argv[]) if not exist(?)
+  // * add runtime system init code at the begin 
+  // * find all return points and append cleanup code
+  // * add global declarations for threadprivate variables
+  // * add global declarations for lock variables
+
+  void insertRTLinitAndCleanCode(SgSourceFile* sgfile)
+  {
+#ifdef ENABLE_XOMP
+    bool hasMain= false;
+    //find the main entry
+    SgFunctionDefinition* mainDef=NULL;
+    string mainName = "::main";
+    ROSE_ASSERT(sgfile != NULL);
+
+    SgFunctionDeclaration * mainDecl=findMain(sgfile);
+    if (mainDecl!= NULL)
+    {
+      // printf ("Found main function setting hasMain == true \n");
+      mainDef = mainDecl->get_definition();
+      hasMain = true;
+    }
+
+    //TODO declare pointers for threadprivate variables and global lock
+    //addGlobalOmpDeclarations(ompfrontend, sgfile->get_globalScope(), hasMain );
+
+    if (! hasMain) return ;
+    ROSE_ASSERT (mainDef!= NULL); // Liao, at this point, we expect a defining declaration of main() is found
+    // add parameter  int argc , char* argv[] if not exist
+    SgInitializedNamePtrList args = mainDef->get_declaration()->get_args();
+    SgType * intType=  SgTypeInt::createType();
+    SgType *charType=  SgTypeChar::createType();
+
+#if 1   //patch up argc, argv if they do not exit yet
+    if (args.size()==0){
+      SgFunctionParameterList *parameterList = mainDef->get_declaration()->get_parameterList();
+      ROSE_ASSERT(parameterList);
+
+      // int argc
+      SgName name1("argc");
+      SgInitializedName *arg1 = buildInitializedName(name1,intType);
+
+      //char** argv
+      SgName name2("argv");
+      SgPointerType *pType1= buildPointerType(charType);
+      SgPointerType *pType2= buildPointerType(pType1);
+      SgInitializedName *arg2 = buildInitializedName(name2,pType2);
+
+      appendArg(parameterList,arg1);
+      appendArg(parameterList,arg2);
+
+    } // end if (args.size() ==0)
+#endif
+    // add statements to prepare the runtime system
+    //int status=0;
+    SgIntVal * intVal = buildIntVal(0);
+
+    SgAssignInitializer * init2=buildAssignInitializer(intVal);
+    SgName *name1 = new SgName("status"); 
+    SgVariableDeclaration* varDecl1 = buildVariableDeclaration(*name1, SgTypeInt::createType(),init2, mainDef->get_body());
+
+    // cout<<"debug:"<<varDecl1->unparseToString()<<endl;
+
+    //_ompc_init(argc, argv);
+    SgType* voidtype =SgTypeVoid::createType();
+    SgFunctionType *myFuncType= new SgFunctionType(voidtype,false);
+    ROSE_ASSERT(myFuncType != NULL);
+
+    //SgExprListExp, two parameters (argc, argv)
+    // look up symbol tables for symbols
+    SgScopeStatement * currentscope = mainDef->get_body();
+
+    SgInitializedNamePtrList mainArgs = mainDef->get_declaration()->get_parameterList()->get_args();
+    Rose_STL_Container <SgInitializedName*>::iterator i= mainArgs.begin();
+    ROSE_ASSERT(mainArgs.size()==2);
+
+    SgExprListExp * exp_list_exp = buildExprListExp();
+    if (!SageInterface::is_Fortran_language())
+    {
+      SgVarRefExp *var1 = buildVarRefExp(isSgInitializedName(*i), mainDef->get_body());
+      SgVarRefExp *var2 = buildVarRefExp(isSgInitializedName(*++i), mainDef->get_body());
+  
+      appendExpression(exp_list_exp,var1);
+      appendExpression(exp_list_exp,var2);
+    }
+
+    SgExprStatement * expStmt=  buildFunctionCallStmt (SgName("XOMP_init"),
+        buildVoidType(), exp_list_exp,currentscope);
+    //  cout<<"debug:"<<expStmt->unparseToString()<<endl;
+    //prepend to main body
+    // Liao 1/5/2011
+    // This is not safe since it cannot be prepended to an implicit none statement in fortran
+    //prependStatement(expStmt,currentscope);
+    //prependStatement(varDecl1,currentscope);
+   if (SageInterface::is_Fortran_language())
+   {
+    SgStatement *l_stmt = findLastDeclarationStatement(currentscope);
+    if (l_stmt != NULL)
+      insertStatementAfter (l_stmt, varDecl1);
+    else
+      prependStatement(varDecl1,currentscope);
+   }
+   else // C/C++, we can always prepend it.
+    prependStatement(varDecl1,currentscope);
+
+    insertStatementAfter (varDecl1, expStmt);
+    //---------------------- termination part
+
+    //  cout<<"debug:"<<mainDef->unparseToString()<<endl;
+
+    // search all return statements and add terminate() before them
+    //the body of this function is empty in the runtime library
+    // _ompc_terminate(status);
+
+    //SgExprListExp, 1 parameters (status) 
+    SgInitializedName *initName1= varDecl1->get_decl_item(*name1);
+    ROSE_ASSERT(initName1);
+
+    SgVarRefExp *var3 = buildVarRefExp(initName1,currentscope);
+    SgExprListExp * exp_list_exp2 = buildExprListExp();
+    appendExpression(exp_list_exp2,var3);
+
+    //build call exp stmt
+    SgExprStatement * expStmt2= buildFunctionCallStmt (SgName("XOMP_terminate"),
+        buildVoidType(),exp_list_exp2,mainDef->get_body());
+    // find return statement, insert before it
+    Rose_STL_Container<SgNode*> rtList = NodeQuery::querySubTree(mainDef, V_SgReturnStmt);
+    if (rtList.size()>0)
+    {
+      for(Rose_STL_Container<SgNode*>::iterator i= rtList.begin();i!=rtList.end();i++)
+      {
+        SgStatement *targetBB= isSgStatement((*i)->get_parent());
+        ROSE_ASSERT(targetBB != NULL);
+        if (i!=rtList.begin()) // for 2nd, 3rd, etc occurrences. We should always build a new statement instead of sharing a statement! 
+        {
+#if 1 // CONVEY-added FIX: avoid shared ExprListExp below.
+          SgExprListExp * expListCopy = deepCopy(exp_list_exp2);
+#endif
+          expStmt2= buildFunctionCallStmt (SgName("XOMP_terminate"),
+              buildVoidType(),expListCopy,mainDef->get_body());
+        }
+        insertStatement(isSgStatement(*i),expStmt2);
+      }
+    }
+    else //if not found append to function body
+    {
+      appendStatement(expStmt2,currentscope);
+    }
+    // cout<<"debug terminate:"<<expStmt2->unparseToString()<<endl;
+    //   AstPostProcessing(mainDef->get_declaration());
+#endif  // ENABLE_XOMP
+
+    return;
+  }
+
+  //! Replace references to oldVar within root with references to newVar
+  int replaceVariableReferences(SgNode* root, SgVariableSymbol* oldVar, SgVariableSymbol* newVar)
+  {
+    ROSE_ASSERT(oldVar != NULL);
+    ROSE_ASSERT(newVar!= NULL);
+
+    OmpUplevelAttribute *attr = getOmpUplevelAttribute(oldVar);
+    int level = -1;
+    if (attr) {
+        level = attr->getUplevel();
+        setOmpUplevelAttribute(newVar, level, attr->isParameter());
+    }
+
+#if 0
+    std::cerr << "replacing references for symbol " << 
+        oldVar->get_name().getString() <<
+        " at level " <<
+        level << std::endl;
+#endif
+
+    VariableSymbolMap_t varRemap;
+    varRemap.insert(  VariableSymbolMap_t::value_type(oldVar, newVar));
+    return replaceVariableReferences(root, varRemap);
+  }
+
+  //! Replace variable references within root based on a map from old symbols to new symbols
+  /* This function is mostly used by transOmpVariables() to handle private, firstprivate, reduction, etc.
+   *  
+   
+   *   
+   */
+  int replaceVariableReferences(SgNode* root, VariableSymbolMap_t varRemap)
+  {
+    int result =0;
+    typedef Rose_STL_Container<SgNode *> NodeList_t;
+    NodeList_t refs = NodeQuery::querySubTree (root, V_SgVarRefExp);
+    for (NodeList_t::iterator i = refs.begin (); i != refs.end (); ++i)
+    {
+      SgVarRefExp* ref_orig = isSgVarRefExp (*i);
+      ROSE_ASSERT (ref_orig);
+
+      VariableSymbolMap_t::const_iterator iter = 
+          varRemap.find(ref_orig->get_symbol()); 
+
+      if (iter != varRemap.end())
+      {
+        SgVariableSymbol* newSym = iter->second; 
+
+        ref_orig->set_symbol( newSym);
+        result ++;
+      }
+    }
+    return result;
+  }
+
+
+  int replaceVariablesWithPointerDereference(SgNode* root, ASTtools::VarSymSet_t vars)
+  {
+      int result = 0;
+      typedef Rose_STL_Container<SgNode *> NodeList_t;
+      NodeList_t refs = NodeQuery::querySubTree (root, V_SgVarRefExp);
+      for (NodeList_t::iterator i = refs.begin (); i != refs.end (); ++i)
+      {
+          SgVarRefExp* ref_orig = isSgVarRefExp (*i);
+          ROSE_ASSERT (ref_orig);
+          ASTtools::VarSymSet_t::const_iterator ii = vars.find( ref_orig->get_symbol( ) );
+          if( ii != vars.end( ) )
+          {
+              SgExpression * ptr_ref = buildPointerDerefExp( copyExpression(ref_orig) );
+              ptr_ref->set_need_paren(true);
+              SageInterface::replaceExpression( ref_orig, ptr_ref );
+              result ++;
+          }
+      }
+      return result;
+  }
+  
+//------------------------------------------------------------------------------
+
+int walkRegionsToSymbolDefinition(SgStatement *scope, SgVariableSymbol *s) {
+
+    int parallel_regions = 0;
+
+    ASTtools::VarSymSet_t syms;
+
+    ROSE_ASSERT(s);
+
+    VariantVector vvt (V_SgOmpPrivateClause);
+    //    vvt.push_back(V_SgOmpReductionClause);
+    //    vvt.push_back(V_SgOmpFirstprivateClause);
+    //    vvt.push_back(V_SgOmpLastprivateClause);
+
+    SgStatement *n = scope;
+
+    ASTtools::collectDefdVarSyms(n, syms);
+
+    while (!isSgFunctionDefinition(n) && 
+           syms.find(s) == syms.end()) {
+
+        if (isSgOmpParallelStatement(n)) {
+            if (isInClauseVariableList(s->get_declaration(), isSgOmpParallelStatement(n), vvt)) {
+                return parallel_regions;
+            }
+            parallel_regions++;
+        }
+        if (isSgOmpForStatement(n)) {
+            if (isInClauseVariableList(s->get_declaration(), isSgOmpForStatement(n), vvt)) {
+                return parallel_regions;
+            }
+        }
+        n = isSgStatement(n->get_parent());
+        ASTtools::collectDefdVarSyms(n, syms);
+    }
+
+    return parallel_regions;
+}
+
+// ---------------------------------------------------------------
+SgStatement *findEnclosingParallelOrFunction(SgStatement *node) {
+
+    SgStatement *n = isSgStatement(node->get_parent());
+    assert(n);
+
+    while (!isSgFunctionDefinition(n) && !isSgOmpParallelStatement(n)) {
+        n = isSgStatement(n->get_parent());
+        assert(n);
+    }
+
+    return n;
+}
+
+//------------------------------------------------------------------------------
+
+  //! Create a stride expression from an existing stride expression based on the loop iteration's order (incremental or decremental)
+  // The assumption is orig_stride is just the raw operand of the condition expression of a loop
+  // so it has to be adjusted to reflect the real stride: *(-1) if decremental
+  static SgExpression* createAdjustedStride(SgExpression* orig_stride, bool isIncremental)
+  {
+    ROSE_ASSERT(orig_stride);
+    if (isIncremental)
+      return copyExpression(orig_stride); // never share expressions
+    else
+    {
+      /*  I changed the normalization phase to generate consistent incremental expressions
+       *  it should be i+= -1  for decremental loops 
+       *   no need to adjust it anymore.
+       *  */
+//      printf("Found a decremental case: orig_stride is\n");
+//      cout<<"\t"<<orig_stride->unparseToString()<<endl;
+      return copyExpression(orig_stride);
+      //return buildMultiplyOp(buildIntVal(-1),copyExpression(orig_stride));
+    }
+  }
+
+  //! check if an omp for/do loop use static schedule or not
+  // Static schedule include: default schedule, or schedule(static[,chunk_size]) 
+  bool useStaticSchedule(SgOmpClauseBodyStatement* omp_loop)
+  {
+    ROSE_ASSERT(omp_loop);
+    bool result= false; 
+    Rose_STL_Container<SgOmpClause*> clauses = getClause(omp_loop, V_SgOmpScheduleClause);
+    if (clauses.size()==0)
+    {
+      result = true; // default schedule is static
+    }else
+    {
+      ROSE_ASSERT(clauses.size() ==1); 
+      SgOmpScheduleClause* s_clause = isSgOmpScheduleClause(clauses[0]);
+      ROSE_ASSERT(s_clause);
+      if (s_clause->get_kind() == SgOmpClause::e_omp_schedule_static)
+        result = true;
+    }
+    return result;
+  }
+
+  // Chunk size  for dynamic and guided schedule should be 1 if not specified.
+  static SgExpression* createAdjustedChunkSize(SgExpression* orig_chunk_size )
+  {
+    SgExpression* result = NULL;
+    if (orig_chunk_size)
+      result = copyExpression(orig_chunk_size);
+    else
+      result = buildIntVal(1);
+    ROSE_ASSERT(result != NULL);  
+    return result;
+  }
+  // Convert a schedule kind enum value to a small case string
+  string toString(SgOmpClause::omp_schedule_kind_enum s_kind)
+  {
+    string result ;
+    if (s_kind == SgOmpClause::e_omp_schedule_static)
+    {
+      result = "static";
+    } else if (s_kind == SgOmpClause::e_omp_schedule_dynamic)
+    {
+      result = "dynamic";
+    }
+    else if (s_kind == SgOmpClause::e_omp_schedule_guided)
+    {
+      result = "guided";
+    }
+    else if (s_kind == SgOmpClause::e_omp_schedule_runtime)
+    {
+      result = "runtime";
+    }
+    else if (s_kind == SgOmpClause::e_omp_schedule_auto)
+    {
+      //      cerr<<"GOMP does not provide an implementation for schedule(auto)....."<<endl;
+      result = "auto";
+    } else
+    {
+      cerr<<"Error: illegal or unhandled schedule kind:"<< s_kind<<endl;
+      ROSE_ASSERT(false);
+    }
+    return result;
+  }
+#ifdef ENABLE_XOMP 
+  //! Generate XOMP loop schedule init function's name, union from OMNI's 
+  string generateGOMPLoopInitFuncName (bool isOrdered, SgOmpClause::omp_schedule_kind_enum s_kind)
+  {
+    // XOMP_loop_static_init() 
+    // XOMP_loop_ordered_static_init ()
+    // XOMP_loop_dynamic_init () 
+    // XOMP_loop_ordered_dynamic_init ()
+    // .....
+    string result;
+    result = "XOMP_loop_";
+    //Handled ordered
+    if (isOrdered)
+        result +="ordered_";
+    result += toString(s_kind);  
+    result += "_init"; 
+    return result;
+  }
+#endif
+
+  //! Generate GOMP loop schedule start function's name
+  string generateGOMPLoopStartFuncName (bool isOrdered, SgOmpClause::omp_schedule_kind_enum s_kind)
+  {
+    // GOMP_loop_static_start () 
+    // GOMP_loop_ordered_static_start ()
+    // GOMP_loop_dynamic_start () 
+    // GOMP_loop_ordered_dynamic_start ()
+    // .....
+    string result;
+#ifdef ENABLE_XOMP 
+    result = "XOMP_loop_";
+#else    
+    result = "GOMP_loop_";
+#endif    
+    // Handled ordered
+    if (isOrdered)
+      result +="ordered_";
+    result += toString(s_kind);  
+    result += "_start"; 
+    return result;
+  }
+
+  //! Generate GOMP loop schedule next function's name
+  string generateGOMPLoopNextFuncName (bool isOrdered, SgOmpClause::omp_schedule_kind_enum s_kind)
+  {
+    string result;
+    // GOMP_loop_static_next() 
+    // GOMP_loop_ordered_static_next ()
+    // GOMP_loop_dynamic_next () 
+    // GOMP_loop_ordered_dynamic_next()
+    // .....
+
+#ifdef ENABLE_XOMP 
+    result = "XOMP_loop_";
+#else
+    result = "GOMP_loop_";
+#endif    
+    if (isOrdered)
+      result +="ordered_";
+    result += toString(s_kind);  
+    result += "_next"; 
+    return result;
+  }
+
+//! Fortran only action: insert include "libxompf.h" into the function body with calls to XOMP_loop_* functions
+// This is necessary since XOMP_loop_* functions will be treated as returning REAL by implicit rules (starting with X)
+// This function finds the function definition enclosing a start node, check if there is any existing include 'libxompf.h'
+// then insert one if there is none.
+static void insert_libxompf_h(SgNode* startNode)
+{
+  ROSE_ASSERT (startNode != NULL);
+  // This function should not be used for other than Fortran
+  ROSE_ASSERT (SageInterface::is_Fortran_language()  == true);
+  // we don't expect input node is a func def already
+  ROSE_ASSERT (isSgFunctionDefinition(startNode)  == NULL);
+
+#if 0
+  //find enclosing parallel region's body
+  SgBasicBlock * omp_body = NULL;
+  SgOmpParallelStatement * omp_stmt = isSgOmpParallelStatement(getEnclosingNode<SgOmpParallelStatement>(startNode));
+  if (omp_stmt)
+  {
+    omp_body= isSgBasicBlock(omp_stmt->get_body());
+    ROSE_ASSERT(omp_body != NULL);
+  }
+    
+  // Find enclosing function body
+  SgFunctionDefinition* func_def = getEnclosingProcedure (startNode);
+  ROSE_ASSERT (func_def != NULL);
+  SgBasicBlock * f_body = func_def->get_body();
+
+  SgBasicBlock* t_body = (omp_body!=NULL)?omp_body:f_body;
+#endif  
+  SgBasicBlock* t_body = getEnclosingRegionOrFuncDefinition (startNode);
+  ROSE_ASSERT (t_body != NULL);
+  // Try to find an existing include 'libxompf.h'
+  // Assumptions: 
+  //   1. It only shows up at the top level, not within other SgBasicBlock
+  //   2. The startNode is after the include line
+  SgStatement * s_include = NULL ; // existing include 
+  SgStatementPtrList stmt_list = t_body->get_statements();
+  SgStatementPtrList::iterator iter;
+  for (iter = stmt_list.begin(); iter != stmt_list.end(); iter ++)
+  {
+    SgStatement* stmt = *iter;
+    ROSE_ASSERT (stmt != NULL);
+    SgFortranIncludeLine * f_inc = isSgFortranIncludeLine(stmt);
+    if (f_inc)
+     {
+       string f_name = StringUtility::stripPathFromFileName(f_inc->get_filename());
+       if (f_name == "libxompf.h")
+       {
+         s_include = f_inc;
+         break;
+       }
+     } 
+  }
+  if (s_include == NULL)
+  {
+    s_include = buildFortranIncludeLine ("libxompf.h");
+    SgStatement* l_stmt = findLastDeclarationStatement (t_body);
+    if (l_stmt)
+      insertStatementAfter(l_stmt,s_include);
+    else
+      prependStatement(s_include, t_body);
+  } 
+}
+  //! Translate an omp for loop with non-static scheduling clause or with ordered clause ()
+  // bb1 is the basic block to insert the translated loop
+  // bb1 already has compiler-generated variable declarations for new loop control variables
+  /*
+   * start, end, incremental, chunk_size, own_start, own_end            
+   XOMP_loop_static_init(int lower, int upper, int stride, int chunk_size);
+
+   if (GOMP_loop_dynamic_start (orig_lower, orig_upper, adj_stride, orig_chunk, &_p_lower, &_p_upper)) 
+  //  if (GOMP_loop_ordered_dynamic_start (S, E, INCR, CHUNK, &_p_lower, &_p_upper))  
+  { 
+    do                                                       
+    {                                                      
+      for (_p_index = _p_lower; _p_index < _p_upper; _p_index += orig_stride)
+      set_data (_p_index, iam);                                 
+    }                                                      
+    while (GOMP_loop_dynamic_next (&_p_lower, &_p_upper));                
+  // while (GOMP_loop_ordered_dynamic_next (&_p_lower, &_p_upper));     
+  }
+  GOMP_loop_end ();                                          
+  //  GOMP_loop_end_nowait (); 
+  //
+  // More explanation: -------------------------------------------
+     // Omni uses the following translation 
+     _ompc_dynamic_sched_init(_p_loop_lower,_p_loop_upper,_p_loop_stride,5);
+      while(_ompc_dynamic_sched_next(&_p_loop_lower,&_p_loop_upper)){
+        for (_p_loop_index = _p_loop_lower; (_p_loop_index) < _p_loop_upper; _p_loop_index += _p_loop_stride) {
+          k_3++;
+        }
+      }
+    // In order to merge two kinds of translations into one scheme.
+    // we split 
+      while(_ompc_dynamic_sched_next(&_p_loop_lower,&_p_loop_upper)){
+        for (_p_loop_index = _p_loop_lower; (_p_loop_index) < _p_loop_upper; _p_loop_index += _p_loop_stride) {
+          k_3++;
+        }
+      }
+
+  // to 
+     if (_ompc_dynamic_sched_next(&_p_loop_lower,&_p_loop_upper)){
+       do {
+        for (_p_loop_index = _p_loop_lower; (_p_loop_index) < _p_loop_upper; _p_loop_index += _p_loop_stride) {
+          k_3++;
+        }
+       } while (_ompc_dynamic_sched_next(&_p_loop_lower,&_p_loop_upper));
+     }
+  // and XOMP layer will compensate for the difference.
+  */
+  static void transOmpLoop_others(SgOmpClauseBodyStatement* target,  
+      SgVariableDeclaration* index_decl, SgVariableDeclaration* lower_decl,  SgVariableDeclaration* upper_decl, 
+      SgBasicBlock* bb1)
+  {
+    ROSE_ASSERT (target != NULL);
+    ROSE_ASSERT (index_decl != NULL);
+    ROSE_ASSERT (lower_decl != NULL);
+    ROSE_ASSERT (upper_decl != NULL);
+    ROSE_ASSERT (bb1 != NULL);
+
+    SgScopeStatement* p_scope = target->get_scope();
+    ROSE_ASSERT (p_scope != NULL);
+    SgStatement * body =  target->get_body();
+    ROSE_ASSERT(body != NULL);
+    // The OpenMP syntax requires that the omp for pragma is immediately followed by the for loop.
+    SgForStatement * for_loop = isSgForStatement(body);
+    SgFortranDo* do_loop = isSgFortranDo(body);
+    SgStatement * loop = for_loop!=NULL? (SgStatement*)for_loop:(SgStatement*)do_loop;
+
+    SgInitializedName* orig_index; 
+    SgExpression* orig_lower, * orig_upper, * orig_stride; 
+    bool isIncremental = true; // if the loop iteration space is incremental
+    // grab the original loop 's controlling information
+    bool is_canonical = false;
+    if (for_loop)
+      is_canonical = isCanonicalForLoop (for_loop, &orig_index, & orig_lower, &orig_upper, &orig_stride, NULL, &isIncremental);
+    else if (do_loop)
+    {
+      is_canonical = isCanonicalDoLoop (do_loop, &orig_index, & orig_lower, &orig_upper, &orig_stride, NULL, &isIncremental, NULL);
+      insert_libxompf_h (do_loop);
+    }
+    else
+    {
+      cerr<<"error! transOmpLoop_others(). loop is neither for_loop nor do_loop. Aborting.."<<endl;
+      ROSE_ASSERT (false);
+    }  
+    ROSE_ASSERT(is_canonical == true);
+
+    Rose_STL_Container<SgOmpClause*> clauses = getClause(target, V_SgOmpScheduleClause);
+
+    // the case of with the ordered schedule, but without any schedule policy specified
+    // treat it as (static, 0) based on GCC's translation
+    SgOmpClause::omp_schedule_kind_enum s_kind = SgOmpClause::e_omp_schedule_static;
+    SgExpression* orig_chunk_size = NULL;
+    bool hasOrder = false;
+    if (hasClause(target, V_SgOmpOrderedClause))
+      hasOrder = true;
+    ROSE_ASSERT(hasOrder || clauses.size() !=0);
+    // Most cases: with schedule(kind,chunk_size)
+    if (clauses.size() !=0)
+    {  
+      ROSE_ASSERT(clauses.size() ==1);
+      SgOmpScheduleClause* s_clause = isSgOmpScheduleClause(clauses[0]);
+      ROSE_ASSERT(s_clause);
+      s_kind = s_clause->get_kind();
+      orig_chunk_size = s_clause->get_chunk_size();
+
+      // chunk size is 1 for dynamic and guided schedule, if not specified. 
+      if (s_kind == SgOmpClause::e_omp_schedule_dynamic|| s_kind == SgOmpClause::e_omp_schedule_guided)
+      {
+        orig_chunk_size = createAdjustedChunkSize(orig_chunk_size);
+      }
+    }
+    else
+      orig_chunk_size = buildIntVal(0);
+
+    // schedule(auto) does not have chunk size 
+    if (s_kind != SgOmpClause::e_omp_schedule_auto  && s_kind != SgOmpClause::e_omp_schedule_runtime)
+      ROSE_ASSERT(orig_chunk_size != NULL);
+    // (GOMP_loop_static_start (orig_lower, orig_upper, adj_stride, orig_chunk, &_p_lower, &_p_upper)) 
+    // (GOMP_loop_ordered_static_start (orig_lower, orig_upper, adj_stride, orig_chunk, &_p_lower, &_p_upper)) 
+    string func_start_name= generateGOMPLoopStartFuncName(hasOrder, s_kind);
+    // Assembling function call expression's parameters
+    // first three are identical for all cases: 
+    // we generate inclusive upper (-1) bounds after loop normalization, gomp runtime calls expect exclusive upper bounds
+    // so we +1 to adjust it back to exclusive.
+    
+#if 0 // Liao 1/11/2011. I changed XOMP loop functions to use inclusive upper bounds. All adjustments are done within XOMP from now on
+    int upper_adjust = 1;  // we use inclusive bounds, adjust them accordingly 
+    if (!isIncremental) 
+      upper_adjust = -1;
+#endif 
+
+#ifdef ENABLE_XOMP
+    // build function init stmt
+    //  _ompc_dynamic_sched_init(_p_loop_lower,_p_loop_upper,_p_loop_stride,5);
+    SgExprListExp* para_list_i = buildExprListExp(copyExpression(orig_lower), 
+        //buildAddOp(copyExpression(orig_upper), buildIntVal(upper_adjust)),
+        copyExpression(orig_upper), 
+        createAdjustedStride(orig_stride, isIncremental)); 
+    if (s_kind != SgOmpClause::e_omp_schedule_auto && s_kind != SgOmpClause::e_omp_schedule_runtime)
+    {
+      appendExpression(para_list_i, copyExpression(orig_chunk_size));
+    }
+
+    string func_init_name= generateGOMPLoopInitFuncName(hasOrder, s_kind);
+    SgExprStatement* func_init_stmt = buildFunctionCallStmt(func_init_name, buildVoidType(), para_list_i, bb1);
+    appendStatement(func_init_stmt, bb1);
+#endif    
+    //build function start
+    SgExprListExp* para_list = buildExprListExp(copyExpression(orig_lower), 
+         //buildAddOp(copyExpression(orig_upper), buildIntVal(upper_adjust)),
+         copyExpression(orig_upper),
+        createAdjustedStride(orig_stride, isIncremental)); 
+    if (s_kind != SgOmpClause::e_omp_schedule_auto && s_kind != SgOmpClause::e_omp_schedule_runtime)
+    {
+      appendExpression(para_list, orig_chunk_size);
+      //appendExpression(para_list, copyExpression(orig_chunk_size));
+    }
+    if (for_loop)
+    {
+      appendExpression(para_list, buildAddressOfOp(buildVarRefExp(lower_decl)));
+      appendExpression(para_list, buildAddressOfOp(buildVarRefExp(upper_decl)));
+    }
+    else if (do_loop)
+    {
+      appendExpression(para_list, buildVarRefExp(lower_decl));
+      appendExpression(para_list, buildVarRefExp(upper_decl));
+    }
+    SgFunctionCallExp* func_start_exp = NULL;
+    SgBasicBlock * true_body = buildBasicBlock();
+    SgIfStmt* if_stmt = NULL; 
+    if (SageInterface::is_Fortran_language())
+    {
+      // Note for Fortran, we treat the function as returning integer, same type as the rhs of .eq.
+      // Otherwise, unparser will complain.
+      func_start_exp  = buildFunctionCallExp(func_start_name, buildIntType(), para_list, bb1);
+      if_stmt = buildIfStmt(buildEqualityOp(func_start_exp,buildIntVal(1)), true_body, NULL);
+      // if_stmt->set_use_then_keyword(true); 
+      // if_stmt->set_has_end_statement(true); 
+    }
+    else 
+    {
+      func_start_exp  = buildFunctionCallExp(func_start_name, buildBoolType(), para_list, bb1);
+      if_stmt = buildIfStmt(func_start_exp, true_body, NULL);
+    }
+
+    appendStatement(if_stmt, bb1);
+    SgExprListExp * n_exp_list = NULL;
+    if (for_loop)
+    {
+      n_exp_list = buildExprListExp(buildAddressOfOp(buildVarRefExp(lower_decl)), buildAddressOfOp(buildVarRefExp(upper_decl)));
+    }
+    else if (do_loop)
+    {
+      n_exp_list = buildExprListExp(buildVarRefExp(lower_decl), buildVarRefExp(upper_decl));
+    }
+    ROSE_ASSERT (n_exp_list!=NULL);
+    SgExpression* func_next_exp = NULL; 
+
+    // do {} while (GOMP_loop_static_next (&_p_lower, &_p_upper))
+    if (for_loop)
+    { 
+
+       func_next_exp =buildFunctionCallExp(generateGOMPLoopNextFuncName(hasOrder, s_kind), buildBoolType(),
+        n_exp_list, bb1);
+      SgBasicBlock * do_body = buildBasicBlock();
+      SgDoWhileStmt * do_while_stmt = buildDoWhileStmt(do_body, func_next_exp);
+      appendStatement(do_while_stmt, true_body);
+      // insert the loop into do-while
+      appendStatement(loop, do_body);
+    } 
+    // Liao 1/7/2011, Fortran does not support SgDoWhileStmt
+    // We use the following control flow as an alternative:  
+    //   label  continue
+    //          loop_here 
+    //          if (GOMP_loop_static_next (&_p_lower, &_p_upper)) 
+    //             goto label  
+    else if (do_loop)
+    {
+      SgFunctionDefinition * funcDef = getEnclosingFunctionDefinition(bb1);
+      ROSE_ASSERT (funcDef != NULL);
+      // label  CONTINUE
+      SgLabelStatement * label_stmt_1 = buildLabelStatement("", NULL);
+      appendStatement(label_stmt_1, true_body);
+      int l_val = suggestNextNumericLabel(funcDef);
+      setFortranNumericLabel(label_stmt_1, l_val);
+      // loop here
+      appendStatement(loop, true_body);
+      // if () goto label
+       func_next_exp =buildFunctionCallExp(generateGOMPLoopNextFuncName(hasOrder, s_kind), buildIntType(),
+        n_exp_list, bb1);
+      SgIfStmt * if_stmt_2 = buildIfStmt(buildEqualityOp(func_next_exp,buildIntVal(1)), buildBasicBlock(), buildBasicBlock());
+      SgGotoStatement* gt_stmt = buildGotoStatement(label_stmt_1->get_numeric_label()->get_symbol());
+      appendStatement (gt_stmt, isSgScopeStatement(if_stmt_2->get_true_body()));
+      appendStatement(if_stmt_2,true_body);
+      // assertion from unparser
+      SgStatementPtrList & statementList = isSgBasicBlock(if_stmt_2->get_true_body())->get_statements();
+      ROSE_ASSERT(statementList.size() == 1);
+    }
+
+    // Rewrite loop control variables
+    replaceVariableReferences(loop,isSgVariableSymbol(orig_index->get_symbol_from_symbol_table ()), 
+        getFirstVarSym(index_decl));
+#if 0 // Liao 1/11/2011. I changed XOMP loop functions to use inclusive upper bounds. All adjustments are done within XOMP from now on
+    int upperAdjust;
+    if (isIncremental)  // adjust the bounds again, inclusive bound so -1 for incremental loop
+      upperAdjust = -1;
+    else 
+      upperAdjust = 1;
+#endif      
+    SageInterface::setLoopLowerBound(loop, buildVarRefExp(lower_decl));
+    //SageInterface::setLoopUpperBound(loop, buildAddOp(buildVarRefExp(upper_decl),buildIntVal(upperAdjust)));
+    SageInterface::setLoopUpperBound(loop, buildVarRefExp(upper_decl));
+    ROSE_ASSERT (orig_upper != NULL);
+    transOmpVariables(target, bb1, orig_upper); // This should happen before the barrier is inserted.
+    // GOMP_loop_end ();  or GOMP_loop_end_nowait (); 
+#ifdef ENABLE_XOMP
+    string func_loop_end_name = "XOMP_loop_end"; 
+#else    
+    string func_loop_end_name = "GOMP_loop_end"; 
+#endif    
+    if (hasClause(target, V_SgOmpNowaitClause)) 
+    {
+      func_loop_end_name+= "_nowait";
+    }
+    SgExprStatement* end_func_stmt = buildFunctionCallStmt(func_loop_end_name, buildVoidType(), NULL, bb1);
+    appendStatement(end_func_stmt, bb1);
+  }
+
+  // Expected AST
+  // * SgOmpForStatement
+  // ** SgForStatement
+  // Algorithm:
+  // Loop normalization first  for stop condition expressions
+  //   <: for (i= 0;i <20; i++) --> for (i= 0;i <20; i+=1)  [0,20, +1] to pass to runtime calls
+  //  <=: for (i= 0;i<=20; i++) --> for (i= 0;i <21; i+=1) 
+  //   >: for (i=20;i >-1; i--) --> for (i=20;i >-1; i-=1) [20, -1, -1]
+  //  >=: for (i=20;i>= 0; i--) --> for (i=20;i >-1; i-=1)
+  // We have a SageInterface::forLoopNormalization() which does the opposite (normalizing a C loop to a Fortran style loop)
+  // < --> <= and > --> >=, 
+  // GCC-GOMP use compiler-generated statements to schedule loop iterations using static schedule
+  // All other schedule policies use runtime calls instead.
+  // We translate static schedule here and non-static ones in transOmpLoop_others()
+  // 
+  // Static schedule, including:
+  //1. default (static even) case
+  //2. schedule(static[, chunk_size]): == static even if chunk_size is not specified
+  // gomp does not provide a runtime call to calculate loop control values 
+  // for the default (static even) scheduling
+  // compilers have to generate the statements to do this. I HATE THIS!!!
+  // the loop scheduling algorithm for the default case is
+  /*
+  // calculate loop iteration count from lower, upper and stride , no -1 if upper is an inclusive bound
+  int _p_iter_count = (stride + -1 + upper - lower )/stride;  
+  // calculate a proper chunk size
+  // two cases: evenly divisible  20/5 =4
+  //   not evenly divisible 20/3= 6
+  // Initial candidate  
+
+  int _p_num_threads = omp_get_num_threads ();
+  _p_chunk_size = _p_iter_count / _p_num_threads;
+  int _p_ck_temp = (_p_chunk_size * _p_num_threads) != _p_iter_count;
+  // increase the chunk size by 1 if not evenly divisible
+  _p_chunk_size = _p_ck_temp + _p_chunk_size;
+
+  // decide on the lower and upper bound for the current thread
+  int _p_thread_id = omp_get_thread_num ();
+  _p_lower = lower + _p_chunk_size * _p_thread_id * stride;a
+  // -1 if upper is an inclusive bound
+  _p_upper = _p_lower + _p_chunk_size * stride;
+
+  // adjust the upper bound
+  _p_upper = MIN_EXPR <_p_upper, upper>;
+  // _p_upper = _p_upper<upper? _p_upper: upper; 
+  // Note: decremental iteration space needs some minor changes to the algorithm above.
+  // stride should be negated 
+  // MIN_EXP should be MAX_EXP
+  // upper bound adjustment should be +1 instead of -1
+  */
+  void transOmpLoop(SgNode* node)
+  //void transOmpFor(SgNode* node)
+  {
+    ROSE_ASSERT(node != NULL);
+    SgOmpForStatement* target1 = isSgOmpForStatement(node);
+    SgOmpDoStatement* target2 = isSgOmpDoStatement(node);
+
+    SgOmpClauseBodyStatement* target = (target1!=NULL?(SgOmpClauseBodyStatement*)target1:(SgOmpClauseBodyStatement*)target2);
+    ROSE_ASSERT (target != NULL);
+
+    SgScopeStatement* p_scope = target->get_scope();
+    ROSE_ASSERT (p_scope != NULL);
+
+    SgStatement * body =  target->get_body();
+    ROSE_ASSERT(body != NULL);
+    // The OpenMP syntax requires that the omp for pragma is immediately followed by the for loop.
+    SgForStatement * for_loop = isSgForStatement(body);
+    SgFortranDo * do_loop = isSgFortranDo(body);
+    SgStatement* loop = (for_loop!=NULL?(SgStatement*)for_loop:(SgStatement*)do_loop);
+    ROSE_ASSERT (loop != NULL);
+
+    // Step 1. Loop normalization
+    // we reuse the normalization from SageInterface, though it is different from what gomp expects.
+    // the point is to have a consistent loop form. We can adjust the difference later on.
+    if (for_loop) 
+      SageInterface::forLoopNormalization(for_loop);
+    else if (do_loop)
+      SageInterface::doLoopNormalization(do_loop);
+    else
+    {
+      cerr<<"error! transOmpLoop(). loop is neither for_loop nor do_loop. Aborting.."<<endl;
+      ROSE_ASSERT (false); 
+    }
+
+    SgInitializedName * orig_index = NULL;
+    SgExpression* orig_lower = NULL;
+    SgExpression* orig_upper= NULL;
+    SgExpression* orig_stride= NULL;
+    bool isIncremental = true; // if the loop iteration space is incremental
+    // grab the original loop 's controlling information
+    bool is_canonical = false;
+    if (for_loop)
+      is_canonical = isCanonicalForLoop (for_loop, &orig_index, & orig_lower, &orig_upper, &orig_stride, NULL, &isIncremental);
+    else if (do_loop)
+      is_canonical = isCanonicalDoLoop (do_loop, &orig_index, & orig_lower, &orig_upper, &orig_stride, NULL, &isIncremental, NULL);
+    ROSE_ASSERT(is_canonical == true);
+
+    // step 2. Insert a basic block to replace SgOmpForStatement
+    // This newly introduced scope is used to hold loop variables, private variables ,etc
+    SgBasicBlock * bb1 = SageBuilder::buildBasicBlock(); 
+    replaceStatement(target, bb1, true);
+    //TODO handle preprocessing information
+    // Save some preprocessing information for later restoration. 
+    //  AttachedPreprocessingInfoType ppi_before, ppi_after;
+    //  ASTtools::cutPreprocInfo (s, PreprocessingInfo::before, ppi_before);
+    //  ASTtools::cutPreprocInfo (s, PreprocessingInfo::after, ppi_after);
+
+    // Declare local loop control variables: _p_loop_index _p_loop_lower _p_loop_upper , no change to the original stride
+    SgType* loop_var_type  = NULL ;
+#if 0    
+    if (sizeof(void*) ==8 ) // xomp interface expects long* for some runtime calls. 
+     loop_var_type = buildLongType();
+   else 
+     loop_var_type = buildIntType();
+#endif
+     // xomp interface expects long for some runtime calls now, 6/9/2010
+    if (for_loop) 
+      loop_var_type = buildLongType();
+    else if (do_loop)  // No long integer in Fortran
+      loop_var_type = buildIntType();
+    SgVariableDeclaration* index_decl =  NULL; 
+    SgVariableDeclaration* lower_decl =  NULL; 
+    SgVariableDeclaration* upper_decl =  NULL;
+
+   if (SageInterface::is_Fortran_language() )
+   {// special rules to insert variable declarations in Fortran
+     // They have to be inserted to enclosing function body or enclosing parallel region body
+     // and after existing declaration statement sequence, if any.
+     nCounter ++;
+    index_decl = buildAndInsertDeclarationForOmp("p_index_"+StringUtility::numberToString(nCounter), loop_var_type , NULL,bb1); 
+    lower_decl = buildAndInsertDeclarationForOmp("p_lower_"+StringUtility::numberToString(nCounter), loop_var_type , NULL,bb1); 
+    upper_decl = buildAndInsertDeclarationForOmp("p_upper_"+StringUtility::numberToString(nCounter), loop_var_type , NULL,bb1); 
+   }
+   else
+   {  
+    index_decl = buildVariableDeclaration("p_index_", loop_var_type , NULL,bb1); 
+    lower_decl = buildVariableDeclaration("p_lower_", loop_var_type , NULL,bb1); 
+    upper_decl = buildVariableDeclaration("p_upper_", loop_var_type , NULL,bb1); 
+
+    appendStatement(index_decl, bb1);
+    appendStatement(lower_decl, bb1);
+    appendStatement(upper_decl, bb1);
+   } 
+
+    bool hasOrder = false;
+    if (hasClause(target, V_SgOmpOrderedClause))
+      hasOrder = true;
+
+    // Grab or calculate chunk_size
+    SgExpression* my_chunk_size = NULL; 
+    bool hasSpecifiedSize = false;
+    Rose_STL_Container<SgOmpClause*> clauses = getClause(target, V_SgOmpScheduleClause);
+    if (clauses.size() !=0)
+    {
+      SgOmpScheduleClause* s_clause = isSgOmpScheduleClause(clauses[0]);
+      ROSE_ASSERT(s_clause);
+      //SgOmpClause::omp_schedule_kind_enum s_kind = s_clause->get_kind();
+      // ROSE_ASSERT(s_kind == SgOmpClause::e_omp_schedule_static);
+      SgExpression* orig_chunk_size = s_clause->get_chunk_size();  
+    //  ROSE_ASSERT(orig_chunk_size->get_parent() != NULL);
+      if (orig_chunk_size)
+      {
+        hasSpecifiedSize = true;
+        my_chunk_size = orig_chunk_size;
+      }
+    }
+    
+    //  step 3. Translation for omp for 
+    //if (hasClause(target, V_SgOmpScheduleClause)) 
+    if (!useStaticSchedule(target) || hasOrder || hasSpecifiedSize) 
+    {
+       transOmpLoop_others( target,   index_decl, lower_decl,   upper_decl, bb1);
+    }
+    else 
+    {
+     //void XOMP_loop_default(int lower, int upper, int stride, long *n_lower, long * n_upper)
+      // XOMP_loop_default (lower, upper, stride, &_p_lower, &_p_upper );
+      // lower:  copyExpression(orig_lower)
+      // upper: copyExpression(orig_upper)
+      // stride: copyExpression(orig_stride)
+      // n_lower: buildVarRefExp(lower_decl)
+      // n_upper: buildVarRefExp(upper_decl)
+      SgExpression* e4 = NULL; 
+      SgExpression* e5 = NULL; 
+      if (for_loop)
+      {
+        e4= buildAddressOfOp(buildVarRefExp(lower_decl));
+        e5= buildAddressOfOp(buildVarRefExp(upper_decl));
+       }
+       else if (do_loop)
+       {// Fortran, pass-by-reference by default
+        e4= buildVarRefExp(lower_decl);
+        e5= buildVarRefExp(upper_decl);
+       }
+       ROSE_ASSERT (e4&&e5);
+      SgExprListExp* call_parameters = buildExprListExp(copyExpression(orig_lower), copyExpression(orig_upper), copyExpression(orig_stride), 
+                  e4, e5);
+      SgStatement * call_stmt =  buildFunctionCallStmt ("XOMP_loop_default", buildVoidType(), call_parameters, bb1);
+      appendStatement(call_stmt, bb1);
+
+      // add loop here
+      appendStatement(loop, bb1); 
+      // replace loop index with the new one
+      replaceVariableReferences(loop,
+         isSgVariableSymbol(orig_index->get_symbol_from_symbol_table()), getFirstVarSym(index_decl))    ; 
+      // rewrite the lower and upper bounds
+      SageInterface::setLoopLowerBound(loop, buildVarRefExp(lower_decl)); 
+      SageInterface::setLoopUpperBound(loop, buildVarRefExp(upper_decl)); 
+
+      transOmpVariables(target, bb1,orig_upper); // This should happen before the barrier is inserted.
+      // insert barrier if there is no nowait clause
+      if (!hasClause(target, V_SgOmpNowaitClause)) 
+      {
+        //insertStatementAfter(for_loop, buildFunctionCallStmt("GOMP_barrier", buildVoidType(), NULL, bb1));
+#ifdef ENABLE_XOMP
+        appendStatement(buildFunctionCallStmt("XOMP_barrier", buildVoidType(), NULL, bb1), bb1);
+#else   
+        appendStatement(buildFunctionCallStmt("GOMP_barrier", buildVoidType(), NULL, bb1), bb1);
+#endif  
+      }
+    }
+
+    // handle variables 
+    // transOmpVariables(target, bb1); // This should happen before the barrier is inserted.
+  } // end trans omp for
+
+
+  //! Translate omp for or omp do loops affected by the "omp target" directive, Liao 1/28/2013
+  /*
+  
+  Example: 
+  // for (i = 0; i < N; i++)
+  { // top level block, prepare to be outlined.
+     int i ; // = blockDim.x * blockIdx.x + threadIdx.x; // this CUDA declaration can be inserted later
+  // TODO: i = blockDim.x * blockIdx.x + threadIdx.x;
+  
+     if (i<SIZE)  // boundary checking to avoid invalid memory accesses
+   {
+     for (j = 0; j < M; j++)
+      for (k = 0; k < K; k++)
+      c[i][j]= c[i][j]+a[i][k]*b[k][j];
+   }
+  } // end of top level block
+ 
+  Algorithm:
+    * check if it is a OmpTargetLoop
+    * loop normalization
+    * replace OmpForStatement with a block: bb1
+    * declare int _dev_i within bb1;  replace for loop body’s loop index with _dev_i;
+    * build if stmt with correct condition
+    * move loop body to if-stmt’s true body
+    * remove for_loop
+  */
+  void transOmpTargetLoop(SgNode* node)
+{
+  //step 0: Sanity check
+  ROSE_ASSERT(node != NULL);
+  SgOmpForStatement* target1 = isSgOmpForStatement(node);
+  SgOmpDoStatement* target2 = isSgOmpDoStatement(node);
+
+  SgOmpClauseBodyStatement* target = (target1!=NULL?(SgOmpClauseBodyStatement*)target1:(SgOmpClauseBodyStatement*)target2);
+  ROSE_ASSERT (target != NULL);
+
+  SgScopeStatement* p_scope = target->get_scope();
+  ROSE_ASSERT (p_scope != NULL);
+
+  SgStatement * body =  target->get_body();
+  ROSE_ASSERT(body != NULL);
+  // The OpenMP syntax requires that the omp for pragma is immediately followed by the for loop.
+  SgForStatement * for_loop = isSgForStatement(body);
+  SgFortranDo * do_loop = isSgFortranDo(body);
+  SgStatement* loop = (for_loop!=NULL?(SgStatement*)for_loop:(SgStatement*)do_loop);
+  ROSE_ASSERT (loop != NULL);
+
+  // make sure this is really a loop affected by "omp target"
+  //bool is_target_loop = false;
+  SgNode* parent = node->get_parent();
+  ROSE_ASSERT (parent != NULL);
+  if (isSgBasicBlock(parent)) // skip one possible BB between omp parallel and omp for.
+    parent = parent->get_parent();
+  SgNode* grand_parent = parent->get_parent();
+  ROSE_ASSERT (grand_parent != NULL);
+  SgOmpParallelStatement* parent_parallel = isSgOmpParallelStatement (parent) ;
+  SgOmpTargetStatement* grand_target = isSgOmpTargetStatement(grand_parent);
+  ROSE_ASSERT (parent_parallel !=NULL); 
+  ROSE_ASSERT (grand_target !=NULL); 
+
+
+  // Step 1. Loop normalization
+  // For the init statement: for (int i=0;... ) becomes int i; for (i=0;..) 
+  // For test expression: i<x is normalized to i<= (x-1) and i>x is normalized to i>= (x+1) 
+  // For increment expression: i++ is normalized to i+=1 and i-- is normalized to i+=-1 i-=s is normalized to i+= -s 
+  if (for_loop)
+    SageInterface::forLoopNormalization(for_loop);
+  else if (do_loop)
+    SageInterface::doLoopNormalization(do_loop);
+  else
+  {
+    cerr<<"error! transOmpLoop(). loop is neither for_loop nor do_loop. Aborting.."<<endl;
+    ROSE_ASSERT (false);
+  }
+
+  SgInitializedName * orig_index = NULL;
+  SgExpression* orig_lower = NULL;
+  SgExpression* orig_upper= NULL;
+  SgExpression* orig_stride= NULL;
+  bool isIncremental = true; // if the loop iteration space is incremental
+  // grab the original loop 's controlling information
+  bool is_canonical = false;
+  if (for_loop)
+    is_canonical = isCanonicalForLoop (for_loop, &orig_index, & orig_lower, &orig_upper, &orig_stride, NULL, &isIncremental);
+  else if (do_loop)
+    is_canonical = isCanonicalDoLoop (do_loop, &orig_index, & orig_lower, &orig_upper, &orig_stride, NULL, &isIncremental, NULL);
+  ROSE_ASSERT(is_canonical == true);
+
+  // loop iteration space: upper - lower + 1
+  // This expression will be later used to help generate xomp_get_max1DBlock(VEC_LEN), which needs iteration count to calculate max thread block numbers
+  cuda_loop_iter_count_1 = buildAddOp(buildSubtractOp(deepCopy(orig_upper), deepCopy(orig_lower)), buildIntVal(1));
+  // also make sure the loop body is a block
+  // TODO: we consider peeling off 1 level loop control only, need to be conditional on what the spec. can provide at pragma level
+  // TODO: Fortran support later on
+  ROSE_ASSERT (for_loop != NULL);
+  SgBasicBlock* loop_body = ensureBasicBlockAsBodyOfFor (for_loop);
+
+
+  //Step 2. Insert a basic block to replace SgOmpForStatement
+  // This newly introduced scope is used to hold loop variables ,etc
+  SgBasicBlock * bb1 = SageBuilder::buildBasicBlock();
+  replaceStatement(target, bb1, true);
+
+ //Step 3. Using device thread id and replace reference of original loop index with the thread index
+  // Declare device thread id variable
+   //int i = blockDim.x * blockIdx.x + threadIdx.x;
+#if 0
+   // Convey-- Avoid problem with predefined CUDA variables temporarily
+   //TODO: better build of CUDA variables later !!
+  SgAssignInitializer* init_idx =  buildAssignInitializer( 
+                                       buildAddOp( buildMultiplyOp (buildVarRefExp("blockDim.x"), buildVarRefExp("blockIdx.x")) , 
+                                        buildVarRefExp("threadIdx.x", bb1)));
+#endif
+
+  SgVariableDeclaration* dev_i_decl = buildVariableDeclaration("_dev_i", buildIntType(), /* init_idx */ 0, bb1); 
+  prependStatement (dev_i_decl, bb1);
+  SgVariableSymbol* dev_i_symbol = getFirstVarSym (dev_i_decl);
+  ROSE_ASSERT (dev_i_symbol != NULL);
+
+  // replace reference to loop index with reference to device i variable
+  ROSE_ASSERT (orig_index != NULL);
+  SgSymbol * orig_symbol = orig_index ->get_symbol_from_symbol_table () ;
+  ROSE_ASSERT (orig_symbol != NULL);
+
+  Rose_STL_Container<SgNode*> nodeList = NodeQuery::querySubTree(loop_body, V_SgVarRefExp);
+  for (Rose_STL_Container<SgNode *>::iterator i = nodeList.begin(); i != nodeList.end(); i++)
+  {
+    SgVarRefExp *vRef = isSgVarRefExp((*i));
+    if (vRef->get_symbol() == orig_symbol)
+      vRef->set_symbol(dev_i_symbol);
+  }
+
+  
+  // Step 4. build the if () condition statement, move the loop body into the true body
+  // Liao, 2/21/2013. We must be accurate about the range of iterations or the computation may result in WRONG results!!
+  // A classic example is the Jacobi iteration: in which the first and last iterations are not executed to make sure elements have boundaries.
+  // After normalization, we have inclusive lower and upper bounds of the input loop
+  // the condition of if() should look like something: if (_dev_i >=0+1 &&_dev_i <= (n - 1) - 1)  {...}
+  SgBasicBlock* true_body = buildBasicBlock();
+  SgExprStatement* cond_stmt = NULL;
+  if (isIncremental)
+  {
+    SgExpression* lhs = buildGreaterOrEqualOp (buildVarRefExp(dev_i_symbol), deepCopy(orig_lower));
+    SgExpression* rhs = buildLessOrEqualOp (buildVarRefExp(dev_i_symbol), deepCopy(orig_upper));
+    cond_stmt = buildExprStatement (buildAndOp(lhs, rhs));
+  }
+  else
+  {
+    cerr<<"error. transOmpTargetLoop(): decremental case is not yet handled !"<<endl;
+    ROSE_ASSERT (false);
+  }
+  SgIfStmt * if_stmt = buildIfStmt(cond_stmt, true_body, NULL);
+  appendStatement(if_stmt, bb1);
+  moveStatementsBetweenBlocks (loop_body, true_body);  
+  // Peel off the original loop
+  removeStatement (for_loop);
+
+  // handle private variables at this loop level, mostly loop index variables.
+  // TODO: this is not very elegant since the outer most loop's loop variable is still translated.
+  //for reduction
+  per_block_declarations.clear(); // must reset to empty or wrong reference to stale content generated previously
+  transOmpVariables(target, bb1,NULL, true);
+}
+
+  //! Check if an OpenMP statement has a clause of type vt
+  Rose_STL_Container<SgOmpClause*> getClause(SgOmpClauseBodyStatement* clause_stmt, const VariantT & vt)
+  {
+    ROSE_ASSERT(clause_stmt != NULL);
+    Rose_STL_Container<SgOmpClause*> p_clause =
+      NodeQuery::queryNodeList<SgOmpClause>(clause_stmt->get_clauses(),vt);
+    return  p_clause;
+  }
+
+  //! Check if an OpenMP statement has a clause of type vt
+  bool hasClause(SgOmpClauseBodyStatement* clause_stmt, const VariantT & vt)
+  {
+    ROSE_ASSERT(clause_stmt != NULL);
+    Rose_STL_Container<SgOmpClause*> p_clause =
+      NodeQuery::queryNodeList<SgOmpClause>(clause_stmt->get_clauses(),vt);
+    return  (p_clause.size()!= 0) ;
+  }
+
+//! A helper function to generate implicit or explicit task for either omp parallel or omp task
+//  Parameters:  SgNode* node: the OMP Parallel or OMP Parallel
+//               std::string& wrapper_name: for C/C++, structure wrapper is used to wrap all parameters. This is to return the struct name
+//               ASTtools::VarSymSet_t& syms :  all variables to be passed in/out the outlined function
+//               ASTtools::VarSymSet_t&pdSyms3 : variables which must be passed by references, used to guide the creation of struct wrapper: member using base type vs. using pointer type.  The algorithm to generate this set is already very conservative: after transOmpVariables() , the only exclude firstprivate. In the context of OpenMP, it is equivalent to say this is a set of variables which are to be passed by references. 
+// Algorithms:
+//    Set flags of the outliner to indicate desired behaviors: parameter wrapping or not?
+//    translate OpenMP variables (first private, private, reduction, etc) so the code to be outlined is already as simple as possible (without OpenMP-specific semantics)
+//
+// It calls the ROSE AST outliner internally. 
+SgFunctionDeclaration* generateOutlinedTask(SgNode* node, std::string& wrapper_name, ASTtools::VarSymSet_t& syms, ASTtools::VarSymSet_t&pdSyms3)
+//SgFunctionDeclaration* generateOutlinedTask(SgNode* node, std::string& wrapper_name, ASTtools::VarSymSet_t& syms, std::set<SgInitializedName*>& readOnlyVars, ASTtools::VarSymSet_t&pdSyms3)
+{
+  ROSE_ASSERT(node != NULL);
+  SgOmpClauseBodyStatement* target = isSgOmpClauseBodyStatement(node);  
+  ROSE_ASSERT (target != NULL);
+
+  // must be either omp task or omp parallel
+  SgOmpTaskStatement* target1 = isSgOmpTaskStatement(node);
+  SgOmpParallelStatement* target2 = isSgOmpParallelStatement(node);
+  ROSE_ASSERT (target1 != NULL || target2 != NULL);
+
+  SgStatement * body =  target->get_body();
+  ROSE_ASSERT(body != NULL);
+  SgFunctionDeclaration* result= NULL;
+  //Initialize outliner
+  Outliner::enable_classic = false; // we need use parameter wrapping, which is not classic behavior of outlining
+  if (SageInterface::is_Fortran_language())
+  {
+    //We pass one variable per parameter, at least for Fortran 77
+    Outliner::useParameterWrapper = false;
+//    Outliner::enable_classic = true; // use subroutine's parameters directly
+  }
+  else 
+  {
+    // C/C++ : always wrap parameters into a structure for outlining used during OpenMP translation
+    Outliner::useParameterWrapper = true; 
+    Outliner::useStructureWrapper = true;
+  }
+
+  //TODO there should be some semantics check for the regions to be outlined
+  //for example, multiple entries or exists are not allowed for OpenMP
+  //This is however of low priority since most vendor compilers have this already.
+  SgBasicBlock* body_block = Outliner::preprocess(body);
+
+  //---------------------------------------------------------------
+  //  Key step: handling special variables BEFORE actual outlining is done!!
+  // Variable handling is done after Outliner::preprocess() to ensure a basic block for the body,
+  // but before calling the actual outlining 
+  // This simplifies the outlining since firstprivate, private variables are replaced 
+  //with their local copies before outliner is used 
+  transOmpVariables (target, body_block); 
+
+  // variable set pointer dereferencing (pd)
+  ASTtools::VarSymSet_t pdSyms;
+
+  string func_name = Outliner::generateFuncName(target);
+  SgGlobal* g_scope = SageInterface::getGlobalScope(body_block);
+  ROSE_ASSERT(g_scope != NULL);
+
+   //-----------------------------------------------------------------
+  // Generic collection of variables to be passed as parameters of the outlined functions
+  // semantically equivalent to shared variables in OpenMP
+  Outliner::enable_debug = false;
+  Outliner::collectVars(body_block, syms);
+
+  // Now decide on the parameter convention for all the parameters: pass-by-value vs. pass-by-reference (pointer dereferencing)
+   
+  //     SageInterface::collectReadOnlyVariables(body_block,readOnlyVars);
+  // We choose to be conservative about the variables needing pointer dereferencing first
+  // AllParameters - readOnlyVars  - private -firstprivate 
+  // Union ASTtools::collectPointerDereferencingVarSyms(body_block, pdSyms) 
+
+  // Assume all parameters need to be passed by reference/pointers first
+  std::copy(syms.begin(), syms.end(), std::inserter(pdSyms,pdSyms.begin()));
+
+  //exclude firstprivate variables: they are read only in fact
+  //TODO keep class typed variables!!!  even if they are firstprivate or private!! 
+  SgInitializedNamePtrList fp_vars = collectClauseVariables (target, V_SgOmpFirstprivateClause);
+  ASTtools::VarSymSet_t fp_syms, pdSyms2;
+  convertAndFilter (fp_vars, fp_syms);
+  set_difference (pdSyms.begin(), pdSyms.end(),
+      fp_syms.begin(), fp_syms.end(),
+      std::inserter(pdSyms2, pdSyms2.begin()));
+ //  ROSE_ASSERT (pdSyms.size() == pdSyms2.size());  this means the previous set_difference is neccesary !
+ 
+  pdSyms3 = pdSyms2;
+
+  // lastprivate and reduction variables cannot be excluded  since write access to their shared copies
+
+  // Sara Royuela 24/04/2012
+  // When unpacking array variables in the outlined function, it is needed to have access to the size of the array.
+  // When this size is a variable (or a operation containing variables), this variable must be added to the arguments of the outlined function.
+  // Example:
+  //    Input snippet:                      Outlined function:
+  //        int N = 1;                          static void OUT__1__5493__(void *__out_argv) {
+  //        int a[N];                               int (*a)[N] = (int (*)[N])(((struct OUT__1__5493___data *)__out_argv) -> a_p);
+  //        #pragma omp task shared(a)              ( *a)[0] = 1;
+  //            a[0] = 1;                       }
+  ASTtools::VarSymSet_t new_syms;
+  for (ASTtools::VarSymSet_t::const_iterator i = syms.begin (); i != syms.end (); ++i)
+  {
+    SgType* i_type = (*i)->get_declaration()->get_type();
+
+    while (isSgArrayType(i_type))
+    {
+      // Get most significant dimension
+      SgExpression* index = ((SgArrayType*) i_type)->get_index();
+
+      // Get the variables used to compute the dimension
+      // FIXME We insert a new statement and delete it afterwards in order to use "collectVars" function
+      //       Think about implementing an specific function for expressions
+      ASTtools::VarSymSet_t a_syms, a_pSyms;
+      SgExprStatement* index_stmt = buildExprStatement(index);
+      appendStatement(index_stmt, body_block);
+      Outliner::collectVars(index_stmt, a_syms);
+      SageInterface::removeStatement(index_stmt);
+      for(ASTtools::VarSymSet_t::iterator j = a_syms.begin(); j != a_syms.end(); ++j)
+      {
+        const SgVariableSymbol* s = *j;
+        new_syms.insert(s);   // If the symbol is not in the symbol list, it is added
+      }
+      
+      // Advance over the type
+      i_type = ((SgArrayType*) i_type)->get_base_type();
+    }
+  }
+
+  for (ASTtools::VarSymSet_t::const_iterator i = new_syms.begin (); i != new_syms.end (); ++i)
+  {
+    const SgVariableSymbol* s = *i;
+    syms.insert(s);
+  }
+
+  for (ASTtools::VarSymSet_t::const_iterator i = syms.begin (); i != syms.end (); ++i)
+  {
+      SgVariableSymbol *s = (SgVariableSymbol *)(*i);
+      int level = walkRegionsToSymbolDefinition(body_block, s);
+      bool is_parm = s->attributeExists("is_parameter");
+      setOmpUplevelAttribute(s, level, is_parm);
+  }
+
+  
+  ASTtools::VarSymSet_t pdSymsEmpty; // store all variables which should be passed by references (pd means pointer dereferencing)
+
+  // a data structure used to wrap parameters
+  SgClassDeclaration* struct_decl = NULL; 
+  if (SageInterface::is_Fortran_language())
+    struct_decl = NULL;  // We cannot use structure for Fortran
+  else {
+      //      struct_decl = Outliner::generateParameterStructureDeclaration (body_block, func_name, syms, pdSyms3, g_scope);
+
+      // Convey
+      struct_decl = NULL;
+  }
+  // ROSE_ASSERT (struct_decl != NULL); // can be NULL if no parameters to be passed
+
+  //Generate the outlined function
+  /* Parameter list
+       SgBasicBlock* s,  // block to be outlined
+       const string& func_name_str, // function name
+       const ASTtools::VarSymSet_t& syms, // parameter list for all variables to be passed around
+       const ASTtools::VarSymSet_t& pdSyms, // variables must use pointer dereferencing (pass-by-reference)
+       const ASTtools::VarSymSet_t& psyms, // private or dead variables (not live-in, not live-out)
+       SgClassDeclaration* struct_decl,  // an optional wrapper structure for parameters
+    Depending on the internal flag, unpacking/unwrapping statements are generated inside the outlined function to use wrapper parameters.
+  */
+  std::set< SgInitializedName *> restoreVars;
+
+  // Convey
+  // We do not want any symbols to be used by reference (pointer)
+  pdSyms3 = pdSymsEmpty;
+
+  result = HtOmpSupport::generateFunction(body_block, func_name, syms, pdSyms3, restoreVars, struct_decl, g_scope, true);
+
+  // Save enclosing region and region to function mapping information (Convey)
+  SgStatement *region_stmt = isSgStatement(node);
+  assert(region_stmt);
+  enclosing_regions[result] = findEnclosingParallelOrFunction(region_stmt);
+  outlined_regions[region_stmt] = result;
+  
+  if (isInTargetRegion(node)) {
+      attachComment (result, "This outlined function is for the coprocessor");
+  }
+  
+  Outliner::insert(result, g_scope, body_block);
+
+#if 0
+  // Convey
+
+  // Generate packing statements
+  // must pass target , not body_block to get the right scope in which the declarations are inserted
+  if (!SageInterface::is_Fortran_language()) 
+    wrapper_name= Outliner::generatePackingStatements(target,syms,pdSyms3, struct_decl);
+#endif
+
+  ROSE_ASSERT (result != NULL);
+
+  // 12/7/2010
+  // For Fortran outlined subroutines, 
+  // add INCLUDE 'omp_lib.h' in case OpenMP runtime routines are called within the outlined subroutines
+  if (SageInterface::is_Fortran_language() )
+  {
+    SgBasicBlock * body =  result->get_definition()->get_body();
+    ROSE_ASSERT (body != NULL);
+    SgFortranIncludeLine * inc_line = buildFortranIncludeLine("omp_lib.h");
+    prependStatement(inc_line, body);
+  }
+  return result;
+}
+
+  /* GCC's libomp uses the following translation method: 
+   * 
+   * 
+#include "libgomp_g.h"
+#include <stdio.h>
+#include "omp.h"
+
+  //void main_omp_fn_0 (struct _omp_data_s_0* _omp_data_i);
+  void main_omp_fn_0 (void ** __out_argv);
+
+  int main (void)
+  {
+  int i;
+  //  struct _omp_data_s_0 _omp_data_o_1;
+
+  i = 0;
+  // wrap shared variables
+  //  _omp_data_o_1.i = i;
+  void *__out_argv1__5876__[1];
+  __out_argv1__5876__[0] = ((void *)(&i));
+
+  //GOMP_parallel_start (main_omp_fn_0, &_omp_data_o_1, 0);
+  GOMP_parallel_start (main_omp_fn_0, &__out_argv1__5876__, 0); // must use & here!!!
+  //main_omp_fn_0 (&_omp_data_o_1);
+  //main_omp_fn_0 ((void *)__out_argv1__5876__); //best type match
+  main_omp_fn_0 (__out_argv1__5876__);
+  GOMP_parallel_end ();
+
+  // grab the changed value
+  //  i = _omp_data_o_1.i;
+  return 0;
+  }
+
+  //void main_omp_fn_0(void *__out_argvp)
+  void main_omp_fn_0(void **__out_argv)
+  //void OUT__1__5876__(void **__out_argv)
+  {
+  // void **__out_argv = (void **) __out_argvp;
+  int *i = (int *)(__out_argv[0]);
+   *i = omp_get_thread_num();
+   printf("Hello,world! I am thread %d\n", *i);
+   }
+   */
+  void transOmpParallel (SgNode* node)
+  {
+    ROSE_ASSERT(node != NULL);
+    SgOmpParallelStatement* target = isSgOmpParallelStatement(node);
+    ROSE_ASSERT (target != NULL);
+
+// Test if the file info has been corrected transferred to SgOmpParallelStatement
+//    target->get_startOfConstruct()->display();
+//    target->get_endOfConstruct()->display();
+     
+    // Liao 12/7/2010
+    // For Fortran code, we have to insert EXTERNAL OUTLINED_FUNC into 
+    // the function body containing the parallel region
+    SgFunctionDefinition * func_def = NULL;
+    if (SageInterface::is_Fortran_language() )
+    {
+      func_def = getEnclosingFunctionDefinition(target);
+      ROSE_ASSERT (func_def != NULL);
+    }
+    SgStatement * body =  target->get_body();
+    ROSE_ASSERT(body != NULL);
+    // Save preprocessing info as early as possible, avoiding mess up from the outliner
+    AttachedPreprocessingInfoType save_buf1, save_buf2, save_buf_inside;
+    cutPreprocessingInfo(target, PreprocessingInfo::before, save_buf1) ;
+    cutPreprocessingInfo(target, PreprocessingInfo::after, save_buf2) ;
+   
+    // some #endif may be attached to the body, we should not move it with the body into
+    // the outlined funcion!!
+     // cutPreprocessingInfo(body, PreprocessingInfo::before, save_buf_body) ;
+
+    // 1/15/2009, Liao, also handle the last #endif, which is attached inside of the target
+    cutPreprocessingInfo(target, PreprocessingInfo::inside, save_buf_inside) ;
+
+    //-----------------------------------------------------------------
+    // step 1: generated an outlined function as the task
+    std::string wrapper_name;
+    ASTtools::VarSymSet_t syms; // store all variables in the outlined task ???
+    ASTtools::VarSymSet_t pdSyms3; // store all variables which should be passed by references (pd means pointer dereferencing)
+    std::set<SgInitializedName*> readOnlyVars; // not used since OpenMP provides all variable controlling details already. side effect analysis is essentially not being used. 
+    SgFunctionDeclaration* outlined_func = generateOutlinedTask (node, wrapper_name, syms, pdSyms3);
+
+    if (SageInterface::is_Fortran_language() )
+    { // EXTERNAL outlined_function , otherwise the function name will be interpreted as a integer/real variable
+      ROSE_ASSERT (func_def != NULL);
+      SgBasicBlock * func_body = func_def->get_body();
+      ROSE_ASSERT (func_body != NULL);
+      SgAttributeSpecificationStatement* external_stmt1 = buildAttributeSpecificationStatement(SgAttributeSpecificationStatement::e_externalStatement); 
+      SgFunctionRefExp *func_ref1 = buildFunctionRefExp (outlined_func); 
+      external_stmt1->get_parameter_list()->prepend_expression(func_ref1);
+      func_ref1->set_parent(external_stmt1->get_parameter_list());
+      // must put it into the declaration statement part, after possible implicit/include statements, if any
+      SgStatement* l_stmt = findLastDeclarationStatement (func_body); 
+      if (l_stmt)
+        insertStatementAfter(l_stmt,external_stmt1);
+      else  
+        prependStatement(external_stmt1, func_body);
+    }
+
+    SgScopeStatement * p_scope = target->get_scope();
+    ROSE_ASSERT(p_scope != NULL);
+
+    //-----------------------------------------------------------------
+    // step 2: generate call to the outlined function
+#ifndef ENABLE_XOMP  // direct use of gomp needs an explicit call to the task in the original sequential process
+    // generate a function call to it
+
+    SgStatement* func_call = Outliner::generateCall (outlined_func, syms, readOnlyVars, wrapper_name,p_scope);
+    ROSE_ASSERT(func_call != NULL);  
+
+    // Replace the parallel region with the function call statement
+    // TODO should we introduce another level of scope here?
+    SageInterface::replaceStatement(target,func_call, true);
+#endif
+
+    // Generate the parameter list for the call to the XOMP runtime function
+    SgExprListExp* parameters  = NULL;
+    // pass ifClauseValue: set to the expression of if-clause, otherwise set to 1
+    SgExpression* ifClauseValue = NULL; 
+    if (hasClause(target, V_SgOmpIfClause))
+    {
+      Rose_STL_Container<SgOmpClause*> clauses = getClause(target, V_SgOmpIfClause);
+      ROSE_ASSERT (clauses.size() ==1); // should only have one if ()
+      SgOmpIfClause * if_clause = isSgOmpIfClause (clauses[0]);
+      ROSE_ASSERT (if_clause->get_expression() != NULL);
+      ifClauseValue = copyExpression(if_clause->get_expression());
+    }
+    else
+      ifClauseValue = buildIntVal(1);  
+    // pass num_threads_specified: 0 if not, otherwise set to the expression of num_threads clause  
+    SgExpression* numThreadsSpecified = NULL;
+    if (hasClause(target, V_SgOmpNumThreadsClause))
+    {
+      Rose_STL_Container<SgOmpClause*> clauses = getClause(target, V_SgOmpNumThreadsClause);
+      ROSE_ASSERT (clauses.size() ==1); // should only have one if ()
+      SgOmpNumThreadsClause * numThreads_clause = isSgOmpNumThreadsClause (clauses[0]);
+      ROSE_ASSERT (numThreads_clause->get_expression() != NULL);
+      numThreadsSpecified = copyExpression(numThreads_clause->get_expression());
+    }
+    else
+      numThreadsSpecified = buildIntVal(0);  
+
+    if (SageInterface::is_Fortran_language())
+    { // The parameter list for Fortran is little bit different from C/C++'s XOMP interface 
+      // since we are forced to pass variables one by one in the parameter list to support Fortran 77
+       // void xomp_parallel_start (void (*func) (void *), unsigned * ifClauseValue, unsigned* numThread, int * argcount, ...)
+      //e.g. xomp_parallel_start(OUT__1__1527__,0,2,S,K)
+      SgExpression * parameter4 = buildIntVal (pdSyms3.size()); //TODO double check if pdSyms3 is the right set of variables to be passed
+      parameters = buildExprListExp(buildFunctionRefExp(outlined_func), ifClauseValue, numThreadsSpecified, parameter4);
+
+      ASTtools::VarSymSet_t::iterator iter = pdSyms3.begin();
+      for (; iter!=pdSyms3.end(); iter++)
+      {
+        const SgVariableSymbol * sb = *iter;
+        appendExpression (parameters, buildVarRefExp(const_cast<SgVariableSymbol *>(sb)));
+      }
+    }
+    else 
+    { 
+      // C/C++ case: 
+      //add GOMP_parallel_start (OUT_func_xxx, &__out_argv1__5876__, 0);
+      // or GOMP_parallel_start (OUT_func_xxx, 0, 0); // if no variables need to be passed
+      SgExpression * parameter2 = NULL;
+      if (syms.size()==0 || 1)  /// Convey
+        parameter2 = buildIntVal(0);
+      else
+        parameter2 =  buildAddressOfOp(buildVarRefExp(wrapper_name, p_scope));
+     parameters = buildExprListExp(buildFunctionRefExp(outlined_func), parameter2, ifClauseValue, numThreadsSpecified); 
+    }
+
+    ROSE_ASSERT (parameters != NULL);
+
+#ifdef ENABLE_XOMP
+  // extern void XOMP_parallel_start (void (*func) (void *), void *data, unsigned ifClauseValue, unsigned numThreadsSpecified);
+  // * func: pointer to a function which will be run in parallel
+  // * data: pointer to a data segment which will be used as the arguments of func
+  // * ifClauseValue: set to if-clause-expression if if-clause exists, or default is 1.
+  // * numThreadsSpecified: set to the expression of num_threads clause if the clause exists, or default is 0
+  // Liao 3/11/2013, additional file location info, at least for C/C++  for now
+  if (!SageInterface::is_Fortran_language())
+  {
+    string file_name = target->get_startOfConstruct()->get_filenameString();
+    int line = target->get_startOfConstruct()->get_line();
+    parameters->append_expression(buildStringVal(file_name));
+    parameters->append_expression(buildIntVal(line));
+  }
+
+    SgExprStatement * s1 = buildFunctionCallStmt("XOMP_parallel_start", buildVoidType(), parameters, p_scope); 
+    SageInterface::replaceStatement(target, s1 , true);
+#else
+   ROSE_ASSERT (false); //This portion of code should never be used anymore. Kept for reference only.
+//    SgExprStatement * s1 = buildFunctionCallStmt("GOMP_parallel_start", buildVoidType(), parameters, p_scope); 
+//    SageInterface::insertStatementBefore(func_call, s1); 
+#endif
+    // Keep preprocessing information
+    // I have to use cut-paste instead of direct move since 
+    // the preprocessing information may be moved to a wrong place during outlining
+    // while the destination node is unknown until the outlining is done.
+   // SageInterface::moveUpPreprocessingInfo(s1, target, PreprocessingInfo::before); 
+   pastePreprocessingInfo(s1, PreprocessingInfo::before, save_buf1); 
+    // add GOMP_parallel_end ();
+#ifdef ENABLE_XOMP
+
+    SgExprListExp*  parameters2 = buildExprListExp();
+    if (!SageInterface::is_Fortran_language())
+    {
+      string file_name = target->get_endOfConstruct()->get_filenameString();
+      int line = target->get_endOfConstruct()->get_line();
+      parameters2->append_expression(buildStringVal(file_name));
+      parameters2->append_expression(buildIntVal(line));
+    }
+
+    //SgExprStatement * s2 = buildFunctionCallStmt("XOMP_parallel_end", buildVoidType(), NULL, p_scope); 
+    SgExprStatement * s2 = buildFunctionCallStmt("XOMP_parallel_end", buildVoidType(), parameters2, p_scope); 
+    SageInterface::insertStatementAfter(s1, s2);  // insert s2 after s1
+#else
+    SgExprStatement * s2 = buildFunctionCallStmt("GOMP_parallel_end", buildVoidType(), NULL, p_scope); 
+    SageInterface::insertStatementAfter(func_call, s2); 
+#endif
+   // SageInterface::moveUpPreprocessingInfo(s2, target, PreprocessingInfo::after); 
+   pastePreprocessingInfo(s2, PreprocessingInfo::after, save_buf2); 
+   // paste the preprocessing info with inside position to the outlined function's body
+   pastePreprocessingInfo(outlined_func->get_definition()->get_body(), PreprocessingInfo::inside, save_buf_inside); 
+
+    // some #endif may be attached to the body, we should not move it with the body into
+    // the outlined funcion!!
+   // move dangling #endif etc from the body to the end of s2
+   movePreprocessingInfo(body,s2,PreprocessingInfo::before, PreprocessingInfo::after); 
+
+   // SageInterface::deepDelete(target);
+  }
+  
+//! A helper function to categorize variables collected from map clauses
+static   
+void categorizeMapClauseVariables( const SgInitializedNamePtrList & all_vars, // all variables collected from map clauses
+          std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > >&  array_dimensions, // array bounds  info
+                                    std::set<SgSymbol*>& array_syms, // variable symbols which are array types (explicit or as a pointer)
+                                    std::set<SgSymbol*>& atom_syms) // variable symbols which are non-aggregate types: scalar, pointer, etc
+  {
+   // categorize the variables:
+    for (SgInitializedNamePtrList::const_iterator iter = all_vars.begin(); iter != all_vars.end(); iter ++)
+    {
+      SgInitializedName* i_name = *iter;
+      ROSE_ASSERT (i_name != NULL);
+
+      // In C/C++, an array can have a pointer type or SgArrayType. 
+      // We collect SgArrayType for sure. But for pointer type, we consult the array_dimension to decide.
+      SgSymbol* sym = i_name ->get_symbol_from_symbol_table ();
+      ROSE_ASSERT (sym != NULL);
+      SgType * type = sym->get_type ();
+
+      // TODO handle complex types like structure, typedef, cast, etc. here
+      if (isSgArrayType(type))
+        array_syms.insert (sym);
+      else if (isSgPointerType(type))
+      {
+        if (array_dimensions[sym].size()!=0) // if we have bound information for the pointer type, it represents an array
+          array_syms.insert (sym);
+        else // otherwise a pointer pointing to non-array types
+          atom_syms.insert (sym);
+      }
+      else if (isScalarType(type))
+      {
+        atom_syms.insert (sym);
+      }
+      else
+      {
+        cerr<<"Error. transOmpMapVariables() of omp_lowering.cpp: unhandled map clause variable type:"<<type->class_name()<<endl;
+      }
+    }
+   // make sure the categorization is complete
+    ROSE_ASSERT (all_vars.size() == (array_syms.size() + atom_syms.size()) );
+  }
+
+ //! generate expression calculating the size of a linearized array
+ // e.g. row_size * sizeof(double)* column_size
+ static
+ SgExpression * generateSizeCalculationExpression(SgType* element_type,  // element's type, used to generate sizeof(type)
+                     const std::vector < std::pair <SgExpression*, SgExpression*> >& dimensions) // dimensions of an array
+ {
+   SgExpression* result =NULL;
+   ROSE_ASSERT (element_type != NULL);
+   ROSE_ASSERT (dimensions.size()>0);
+
+   result = buildSizeOfOp(element_type);
+   for (std::vector < std::pair <SgExpression*, SgExpression*> >::const_iterator iter = dimensions.begin(); iter != dimensions.end(); iter++)
+   {
+     std::pair <SgExpression*, SgExpression*> bound_pair = *iter; 
+     SgExpression* lower_bound = bound_pair.first;
+     SgExpression* upper_bound = bound_pair.second;
+    // * ( (upper - lower) + 1): assuming inclusive lower bound and non-inclusive upper bound
+     //result = buildMultiplyOp(result, buildAddOp( buildSubtractOp (deepCopy(upper_bound), deepCopy(lower_bound)), buildIntVal(1) ));
+     result = buildMultiplyOp(result,  buildSubtractOp (deepCopy(upper_bound), deepCopy(lower_bound)));
+   }
+   return result; 
+ }                    
+
+  // Check if a variable is in the clause's variable list
+// TODO: move to header
+ static bool isInClauseVariableList(SgOmpClause* cls, SgSymbol* var)
+{
+  ROSE_ASSERT (cls && var); 
+  SgOmpVariablesClause* var_cls = isSgOmpVariablesClause(cls);
+  ROSE_ASSERT (var_cls); 
+  SgVarRefExpPtrList refs = isSgOmpVariablesClause(var_cls)->get_variables();
+
+  std::vector<SgSymbol*> var_list;
+  for (size_t j =0; j< refs.size(); j++)
+    var_list.push_back(refs[j]->get_symbol());
+
+  if (find(var_list.begin(), var_list.end(), var) != var_list.end() )
+    return true;
+  else
+    return false;
+}
+
+ // ! Replace all references to original symbol with references to new symbol
+// return the number of references being replaced. 
+ // TODO: move to SageInterface
+//static int replaceVariableReferences(SgNode* subtree, const SgVariableSymbol* origin_sym, SgVariableSymbol* new_sym )
+static int replaceVariableReferences(SgNode* subtree, std::map <SgVariableSymbol*, SgVariableSymbol*> symbol_map)
+{
+  int result = 0;
+  Rose_STL_Container<SgNode*> nodeList = NodeQuery::querySubTree(subtree, V_SgVarRefExp);
+  for (Rose_STL_Container<SgNode *>::iterator i = nodeList.begin(); i != nodeList.end(); i++)
+  {
+    SgVarRefExp *vRef = isSgVarRefExp((*i));
+    SgVariableSymbol * orig_sym = vRef->get_symbol();
+    if (symbol_map[orig_sym] != NULL)
+    {
+     result ++;
+#if 0
+     std::cerr << "replacing references for symbol " << 
+         orig_sym->get_name().getString() << std::endl;
+#endif
+
+     vRef->set_symbol(symbol_map[orig_sym]);
+    }
+  }
+  return result;
+}
+
+//TODO: move to sageinterface, the current one has wrong reference type, and has undesired effect!!
+// grab the list of dimension sizes for an input array type, store them in the vector container
+static void getArrayDimensionSizes(const SgArrayType*  array_type, std::vector<SgExpression*>& result)
+{
+  ROSE_ASSERT (array_type != NULL);
+
+  const SgType* cur_type = array_type;
+  do
+  {
+    ROSE_ASSERT (isSgArrayType(cur_type) != NULL);
+    SgExpression* index_exp = isSgArrayType(cur_type)->get_index();
+    result.push_back(index_exp); // could be NULL, especially for the first dimension
+    cur_type = isSgArrayType(cur_type)->get_base_type();
+  }
+  while (isSgArrayType(cur_type));
+}
+
+
+//TODO move to SageInterface
+// Liao 2/8/2013
+// rewrite array reference using multiple-dimension subscripts to a reference using one-dimension subscripts
+// e.g. a[i][j] is changed to a[i*col_size +j]
+//      a [i][j][k]  is changed to a [(i*col_size + j)*K_size +k]
+// The parameter is the array reference expression to be changed     
+// Note the array reference expression must be the top one since there will be inner ones for a multi-dimensional array references in AST.
+static void linearizeArrayAccess(SgPntrArrRefExp* top_array_ref)
+{
+  //Sanity check
+  // TODO check language compatibility for C/C++ only: row major storage
+  ROSE_ASSERT( top_array_ref != NULL);
+  //ROSE_ASSERT (top_array_ref->get_lhs_operand_i() != NULL);
+  ROSE_ASSERT (top_array_ref->get_parent() != NULL );
+  ROSE_ASSERT (isSgPntrArrRefExp(top_array_ref->get_parent()) == NULL ); // top ==> must not be a child of a higher level array ref exp
+
+  // must be a canonical array reference, not like (a+10)[10]
+  SgExpression* arrayNameExp = NULL;
+  std::vector<SgExpression*>* subscripts = new vector<SgExpression*>;
+  bool is_array_ref = isArrayReference (top_array_ref, &arrayNameExp, &subscripts);
+  ROSE_ASSERT (is_array_ref);
+  SgInitializedName * i_name = convertRefToInitializedName(arrayNameExp);
+  ROSE_ASSERT (i_name != NULL);
+  SgType* var_type = i_name->get_type();
+  SgArrayType * array_type = isSgArrayType(var_type);
+  SgPointerType * pointer_type = isSgPointerType(var_type);
+  // pointer type can also be used as pointer[i], which is represented as SgPntrArrRefExp.
+  // In this case, we don't need to linearized it any more
+  if (pointer_type != NULL)
+     return; 
+  if (array_type == NULL)
+  {
+    cerr<<"Error. linearizeArrayAccess() found unhandled variable type:"<<var_type->class_name()<<endl;
+  }
+
+  ROSE_ASSERT (array_type!= NULL);
+
+  std::vector <SgExpression*> dimensions ; 
+  getArrayDimensionSizes (array_type, dimensions);
+  
+  ROSE_ASSERT ((*subscripts).size() == dimensions.size());
+  //  ROSE_ASSERT ((*subscripts).size()>1); // we only accept 2-D or above for processing. Caller should check this in advance
+  // Convey: commented out above and replaced with following
+  if (!((*subscripts).size()>1)) {
+      return;
+  }
+
+  // left hand operand
+  SgExpression* new_lhs = buildVarRefExp(i_name);
+  SgExpression* new_rhs = deepCopy((*subscripts)[0]); //initialized to be i; 
+
+  // build rhs, like (i*col_size + j)*K_size +k
+  for (size_t i =1; i<dimensions.size(); i++) // only repeat dimension count -1 times
+  {
+     new_rhs = buildAddOp( buildMultiplyOp(new_rhs, deepCopy(dimensions[i]) ) , deepCopy((*subscripts)[i]) ) ; 
+  }
+
+  // set new lhs and rhs for the top ref
+  deepDelete(top_array_ref->get_lhs_operand_i()) ;  
+  deepDelete(top_array_ref->get_rhs_operand_i()) ;  
+
+  top_array_ref->set_lhs_operand_i(new_lhs);
+  new_lhs->set_parent(top_array_ref);
+
+  top_array_ref->set_rhs_operand_i(new_rhs);
+  new_rhs->set_parent(top_array_ref);
+
+}
+
+
+// Find all top level array references within the body block, 
+// we do the following:
+//   if it is within the set of arrays (array_syms) to be rewritten: arrays on map() clause,
+//   if it is more than 1-D
+//   change it to be linearized subscript access
+static void rewriteArraySubscripts(SgBasicBlock* body_block, const std::set<SgSymbol*> mapped_array_syms)
+{
+  std::vector<SgPntrArrRefExp* > candidate_refs; // store eligible references 
+  Rose_STL_Container<SgNode*> nodeList = NodeQuery::querySubTree(body_block, V_SgPntrArrRefExp);
+  for (Rose_STL_Container<SgNode *>::iterator i = nodeList.begin(); i != nodeList.end(); i++)
+  {
+    SgPntrArrRefExp* vRef = isSgPntrArrRefExp((*i));
+    ROSE_ASSERT (vRef != NULL);
+    SgNode* parent = vRef->get_parent();
+    // if it is top level ref?
+    if (isSgPntrArrRefExp(parent)) // has a higher level array ref, skip it
+      continue;
+   //TODO: move this logic into a function in SageInterface   
+    // If it is a canonical array reference we can handle?
+    vector<SgExpression *>  *subscripts = new vector<SgExpression*>;
+    SgExpression* array_name_exp = NULL;
+    isArrayReference(vRef, &array_name_exp, &subscripts);
+    SgInitializedName* a_name = convertRefToInitializedName (array_name_exp);
+    if  (a_name == NULL)
+      continue; 
+    // if it is within the mapped array set?  
+    ROSE_ASSERT (a_name != NULL);
+    SgSymbol* array_sym = a_name->get_symbol_from_symbol_table ();
+    ROSE_ASSERT (array_sym != NULL);
+
+    if (mapped_array_syms.find(array_sym)!= mapped_array_syms.end()) 
+      candidate_refs.push_back(vRef);
+  } 
+
+  // To be safe, we use reverse order iteration when changing them
+  for (std::vector<SgPntrArrRefExp* >::reverse_iterator riter = candidate_refs.rbegin(); riter != candidate_refs.rend(); riter ++)
+    linearizeArrayAccess (*riter);
+}
+
+// Liao, 2/28/2013
+// A helper function to collect variables used within a code portion
+// To facilitate faster query into the variable collection, we use a map.
+// TODO : move to SageInterface ?
+std::map <SgVariableSymbol *, bool> collectVariableAppearance (SgNode* root)
+{
+  std::map <SgVariableSymbol *, bool> result; 
+  ROSE_ASSERT (root != NULL);
+  Rose_STL_Container<SgNode*> nodeList = NodeQuery::querySubTree(root, V_SgVarRefExp);
+  for (Rose_STL_Container<SgNode *>::iterator i = nodeList.begin(); i != nodeList.end(); i++)
+  {
+    SgVarRefExp *vRef = isSgVarRefExp((*i));
+    SgVariableSymbol * sym = vRef -> get_symbol();
+    ROSE_ASSERT (sym != NULL);
+    result [sym] = true;
+  }
+  return result;
+}
+
+  
+  // Liao, 2/4/2013
+  // Translate the map clause variables associated with "omp target"
+  // TODO: move to the header
+  // Input: 
+  //
+  //  map(alloc|in|out|inout:var_list)
+  //  array variable in var_list should have dimension bounds information like [0:N-1][0:K-1]
+  //  
+  //  Essentially, we have to decide if we need to do the following steps for each variable
+  //
+  //  Data handling: declaration, allocation, and copy
+  //    1. declared a pointer type to the device copy : pass by pointer type vs. pass by value
+  //    2. allocate device copy using the dimension bound info: for array types (pointers used for linearized arrays)
+  //    3. copy the data from CPU to the device (GPU) copy: 
+  //       
+  //    4. replace references to the CPU copies with references to the GPU copy
+  //    5. replace original multidimensional element indexing with linearized address indexing (for 2-D and more dimension arrays) 
+  //
+  //  Data handling: copy back, de-allocation
+  //    6. copy GPU_copy back to CPU variables
+  //    7. de-allocate the GPU variables
+  //
+  //   Step 1,2,3 and 6, 7 should generate statements before or after the SgOmpTargetStatement
+  //   Step 4 and 5 should change the body of the affected SgOmpParallelStatement
+  //
+  //  Algorithm 1: 
+  //   collect all variables in map clauses: they should be either scalar or arrays with bound info.
+  //   For each array variable, 
+  //       we generate memory handling statements for them: declaration, allocation, copy back-forth, de-allocation
+  //   For the use of array variable, 
+  //       we replace the original references with references to new pointer typed variables
+  //       Linearize the access when 2-D or more dimensions are used.
+  //                        
+  //   Based on the mapped variables, we output the variables to be passed to the outlined function to be generated later on
+  //         variables which will be passed by their original data types
+  //         variables which will be passed by their address of type: pointer type pointing to their original data type 
+  //
+  //  Revised Algorithm (version 2):  To translate "omp target" + "omp parallel for" enclosed within "omp target data" region:
+  //  New facts:
+  //        the map clauses are now associated with "omp target data" instead of "omp target"
+  //        Only a subset of all mapped variables at "omp target data" level will be used within "omp target": 
+  //           a single data region contains multiple "omp target" regions
+  //        When translating "omp target" + "omp parallel for", we don't need to generate data handling statements
+  //            but we need to refer to the declarations for device variables.
+  //        Memory declaration, allocation, copy back-forth, de-allocation is generated within the body of the "omp target data" region.
+  //            we can still try to generate them when translating "omp parallel for" under "omp target", if not yet generated before.
+  void transOmpMapVariables(SgOmpTargetStatement* target_directive_stmt, //the "omp target"
+                         SgOmpParallelStatement* target_parallel_stmt, //the affected "omp parallel"
+                         SgBasicBlock* body_block, // the body of the affected "omp parallel"
+                         ASTtools::VarSymSet_t & all_syms, // collect all generated or remaining variables to be passed to the outliner
+                         ASTtools::VarSymSet_t & addressOf_syms // generated or remaining variables should be passed by using their addresses
+                         )
+  {
+    ROSE_ASSERT (target_directive_stmt != NULL);
+    //    ROSE_ASSERT (target_parallel_stmt!= NULL);
+    ROSE_ASSERT (body_block!= NULL);
+    
+   // we should use inner scope , instead of the scope of target-directive-stmt.
+   // this will avoid name collisions when there are multiple "omp target" within one big scope
+    SgScopeStatement* top_scope = 
+        isSgScopeStatement( target_directive_stmt->get_body()); 
+    ROSE_ASSERT (top_scope!= NULL);
+    ROSE_ASSERT (isSgBasicBlock (top_scope));
+
+    std::map <SgVariableSymbol *, bool> variable_map = 
+        //        collectVariableAppearance (target_parallel_stmt);
+        collectVariableAppearance (body_block);
+    // two cases: map variables are provided by 
+    // case 1: "omp target" 
+    // case 2: "omp target data"
+    // we have to figure which case is true for the current affected "omp parallel"
+    SgOmpTargetDataStatement* target_data_stmt = 
+        getEnclosingNode <SgOmpTargetDataStatement> (target_directive_stmt);
+    SgBasicBlock * target_data_stmt_body = NULL;
+    SgStatement* target_data_child_stmt = NULL;
+    if (target_data_stmt != NULL)
+    {
+        target_data_stmt_body = 
+            ensureBasicBlockAsBodyOfOmpBodyStmt (target_data_stmt);
+      ROSE_ASSERT (target_data_stmt_body != NULL);
+      target_data_child_stmt = (target_data_stmt_body->get_statements())[0];
+    }
+   
+    // collect map clauses and their variables 
+    // ----------------------------------------------------------
+    // Some notes for the relevant AST input: 
+    // we store a map clause for each variant/operator (alloc, in, out, and 
+    // inout), so there should be up to 4 SgOmpMapClause.
+    //    SgOmpClause::omp_map_operator_enum
+    // each map clause has 
+    //   a variable list (SgVarRefExp), accessible through get_variables()
+    //   a pointer to array_dimensions, accessible through get_array_dimensions(). the array_dimensions is identical among all map clause of a same "omp target"
+    //     std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > >  array_dimensions
+    
+    Rose_STL_Container<SgOmpClause*> map_clauses; 
+    // Convey -- also collect device clauses so they can be removed
+    Rose_STL_Container<SgOmpClause*> device_clauses; 
+    if (target_data_stmt != NULL) {
+        map_clauses = getClause(target_data_stmt, V_SgOmpMapClause);
+        device_clauses = getClause(target_data_stmt, V_SgOmpDeviceClause);
+    } else {
+        map_clauses = getClause(target_directive_stmt, V_SgOmpMapClause);
+        device_clauses = getClause(target_directive_stmt, V_SgOmpDeviceClause);
+    }
+
+    // Convey
+    // We don't care about device clauses.
+    // The expression attached to the device clause gets warnings that
+    // it is not in parent pointer's child list.   So we just delete it
+    // from the tree as an avoidance.
+    if (device_clauses.size()) {
+        Rose_STL_Container<SgOmpClause*>::const_iterator iter;
+        for (iter = device_clauses.begin(); iter != device_clauses.end(); 
+             iter++) {
+            SgOmpDeviceClause* d_cls = isSgOmpDeviceClause (*iter);
+            SgExpression *dev = d_cls->get_expression();
+
+            deepDelete(dev);
+        }
+    }
+
+    // Convey -- do not return because we need to default to/from
+    // for variables referenced but not in a map.
+#if 0
+    if ( map_clauses.size() == 0) return; // stop if no map clauses at all
+#endif
+
+    // store each type of map clause explicitly
+    SgOmpMapClause* map_alloc_clause = NULL;
+    SgOmpMapClause* map_in_clause = NULL;
+    SgOmpMapClause* map_out_clause = NULL;
+    SgOmpMapClause* map_inout_clause = NULL;
+    // dimension map is the same for all the map clauses under the same 
+    // omp target directive
+    std::map<SgSymbol*, std::vector< std::pair <SgExpression*, SgExpression*> > >  array_dimensions; 
+
+   // a map between original symbol and its device version (replacement) 
+   std::map <SgVariableSymbol*, SgVariableSymbol*>  cpu_gpu_var_map; 
+    
+    // store all variables showing up in any of the map clauses
+    SgInitializedNamePtrList all_vars ;
+    if (target_data_stmt != NULL)
+      all_vars = collectClauseVariables (target_data_stmt, VariantVector(V_SgOmpMapClause)); 
+    else 
+      all_vars = collectClauseVariables (target_directive_stmt, VariantVector(V_SgOmpMapClause));
+
+    // set the scope and anchor statement we will focus on based on the availability of an enclosing target data region
+    SgBasicBlock* insertion_scope = NULL; // the body 
+    SgStatement* insertion_anchor_stmt = NULL; // the single statement within the body
+    bool need_generate_data_stmt  = false; // We don't always need to generate the declaration, allocation, copy, de-allocation of device data.
+
+    if (target_data_stmt != NULL) {
+        insertion_scope = target_data_stmt_body;
+        insertion_anchor_stmt = (insertion_scope->get_statements())[0];
+    } else {
+        insertion_scope = isSgBasicBlock(target_directive_stmt->get_scope());
+        insertion_anchor_stmt = target_directive_stmt;
+    }
+    
+    ROSE_ASSERT (insertion_scope!= NULL);
+    ROSE_ASSERT (insertion_anchor_stmt!= NULL);
+
+    for (Rose_STL_Container<SgOmpClause*>::const_iterator iter = map_clauses.begin(); iter != map_clauses.end(); iter++)
+     {
+       SgOmpMapClause* m_cls = isSgOmpMapClause (*iter);
+       ROSE_ASSERT (m_cls != NULL);
+       if (iter == map_clauses.begin()) // retrieve once is enough
+         array_dimensions = m_cls->get_array_dimensions();
+
+       SgOmpClause::omp_map_operator_enum map_operator = m_cls->get_operation();
+       if (map_operator == SgOmpClause::e_omp_map_alloc)
+         map_alloc_clause = m_cls;
+       else if (map_operator == SgOmpClause::e_omp_map_in)  
+         map_in_clause = m_cls;
+       else if (map_operator == SgOmpClause::e_omp_map_out)  
+         map_out_clause = m_cls;
+       else if (map_operator == SgOmpClause::e_omp_map_inout)  
+         map_inout_clause = m_cls;
+       else 
+       {
+         cerr<<"Error. transOmpMapVariables() from omp_lowering.cpp: found unacceptable map operator type:"<< map_operator <<endl;
+         ROSE_ASSERT (false);
+       }
+     }  // end for
+
+    std::set<SgSymbol*> array_syms; // store clause variable symbols which are array types (explicit or as a pointer)
+    std::set<SgSymbol*> atom_syms; // store clause variable symbols which are non-aggregate types: scalar, pointer, etc
+
+    // -- Convey: any variables referenced but not declared in the target
+    //           region that are not in any map clause need to be treated
+    //           as implicitly mapped to_from (inout).
+    std::map<SgVariableSymbol *, bool>::iterator varmapiter;
+    for (varmapiter = variable_map.begin(); varmapiter != variable_map.end();
+         varmapiter++) {
+        bool found = false;
+        SgVariableSymbol *sym = (*varmapiter).first;
+        SgInitializedName *iname = sym->get_declaration();
+        SgScopeStatement *sym_scope = iname->get_scope();
+
+        for (SgInitializedNamePtrList::const_iterator iter = all_vars.begin();
+             iter != all_vars.end(); iter ++) {
+            if (*iter == iname) {
+                found = true;
+                break;
+            }
+        }
+        if (!found &&
+            !(top_scope == sym_scope) &&
+            !isAncestor(top_scope, sym_scope)) {
+            all_vars.push_back(sym->get_declaration());
+        }
+    }
+    
+   // categorize the variables:
+   categorizeMapClauseVariables (all_vars, array_dimensions, array_syms, atom_syms);
+
+  // handle array variables showing up in the map clauses:   
+  for (std::set<SgSymbol*>::const_iterator iter = array_syms.begin(); iter != array_syms.end(); iter ++)
+   {
+     SgSymbol* sym = *iter; 
+     ROSE_ASSERT (sym != NULL);
+     SgType* orig_type = sym->get_type();
+
+    // Step 1: declare a pointer type to array variables in map clauses, we linearize all arrays to be a 1-D pointer
+    //   Element_type * _dev_var; 
+    //   e.g.: double* _dev_array; 
+    // I believe that all array variables need allocations on GPUs, regardless their map operations (alloc, in, out, or inout)
+ 
+     // TODO: is this a safe assumption here??
+     SgType* element_type = orig_type->findBaseType(); // recursively strip away non-base type to get the bottom type
+     string orig_name = (sym->get_name()).getString();
+     string dev_var_name = "_dev_"+ orig_name; 
+     
+    // Again, two cases: map clauses come from 1) omp target vs. 2) omp target data 
+    // For the combined "omp target" + "omp parallel for " code portion
+    // We generate declarations within the body of "omp target". So we don't concerned about name conflicts. 
+    //
+    // For "omp target data", 
+     // It is possible that there are two consecutive "omp target"+"omp parallel for" regions.
+     // So we have to check the existence of a declaration before creating a brand new one.
+     SgVariableDeclaration* dev_var_decl = NULL; 
+     SgVariableSymbol* dev_var_sym = insertion_scope ->lookup_variable_symbol(dev_var_name);
+     if (dev_var_sym == NULL)
+     {
+       need_generate_data_stmt = true; // this will trigger a set to data handling statements to be generated later on
+       dev_var_decl = buildVariableDeclaration(dev_var_name, buildPointerType(element_type), NULL, insertion_scope);
+       insertStatementBefore (insertion_anchor_stmt, dev_var_decl); 
+     }
+     else 
+       dev_var_decl = isSgVariableDeclaration(dev_var_sym->get_declaration()->get_declaration());
+
+     ROSE_ASSERT (dev_var_decl != NULL);
+
+     SgVariableSymbol* orig_sym = isSgVariableSymbol(sym);
+     ROSE_ASSERT (orig_sym != NULL);
+     SgVariableSymbol* new_sym = getFirstVarSym(dev_var_decl);
+     cpu_gpu_var_map[orig_sym]= new_sym; // store the mapping, this is always needed to guide the outlining
+
+     // Not all map variables from "omp target data" will be used within the current parallel region
+     // We only need to find out the used ones.
+     
+     // linearized array pointers should be directly passed to the outliner later on, without adding & operator in front of them
+     if (target_data_stmt != NULL)
+     {
+         if (variable_map[orig_sym]) {
+             all_syms.insert(new_sym);
+         }
+     }
+     else
+     {
+       all_syms.insert(new_sym);
+       ROSE_ASSERT (variable_map[orig_sym] == true);// the map variable must show up within the parallel region
+     }
+
+     // Convey:  We only want to initialize the device variable from the
+     //          host variable.   No alloc.
+     if (need_generate_data_stmt) {
+         SgExprStatement *assign = 
+             buildAssignStatement(
+                 buildVarRefExp(dev_var_name, insertion_scope),
+                 buildCastExp (buildVarRefExp(orig_name, insertion_scope),
+                               buildPointerType(element_type)));
+         insertStatementBefore (insertion_anchor_stmt, assign); 
+     }
+   }  // end for
+
+   // Step 5. TODO  replace indexing element access with address calculation (only needed for 2/3 -D)
+   // We switch the order of 4 and 5 since we want to rewrite the subscripts before the arrays are replaced
+    rewriteArraySubscripts (body_block, array_syms); 
+   
+   // Step 4. replace references to old with new variables, 
+    replaceVariableReferences (body_block, cpu_gpu_var_map);
+
+   // TODO handle scalar, separate or merged into previous loop ?
+    
+  // store remaining variables so outliner can readily use this information
+   // for pointers to linearized arrays, they should passed by their original form, not using & operator, regardless the map operator types (in|out|alloc|inout)
+   // for a scalar, two cases: in vs. out |inout
+   // if in only, pass by value is good
+   // if either out or inout:  
+   // two possible solutions:
+   // 1) we need to treat it as an array of size 1 or any other choices. TODO!!
+   //  we also have to replace the reference to scalar to the array element access: be cautious about using by value (a) vs. using by address  (&a)
+   // 2) try to still pass by value, but copy the final value back to the CPU version 
+   // right now we assume they are not on out|inout , until we face a real input applications with map(out:scalar_a)
+   // For all scalars, we directly copy them into all_syms for now
+   for (std::set<SgSymbol*> ::iterator iter = atom_syms.begin(); iter != atom_syms.end(); iter ++)
+   {
+     SgVariableSymbol * var_sym = isSgVariableSymbol(*iter);
+     if (variable_map[var_sym] == true) // we should only collect map variables which show up in the current parallel region
+     all_syms.insert (var_sym);
+   }
+
+  } // end transOmpMapVariables()
+
+
+  // Translate a parallel region under "omp target"
+  /*
+    
+   call customized outlining, the generateTask() for omp task or regular omp parallel is not compatible
+   since we want to use the classic outlining support: each variable is passed as a separate parameter.
+
+   We also use the revised generateFunc() to explicitly specify pass by original type vs. pass using pointer type
+
+   */
+  void transOmpTargetParallel (SgNode* node)
+  {
+    // Sanity check first
+    ROSE_ASSERT(node != NULL);
+    SgOmpParallelStatement* target = isSgOmpParallelStatement(node);
+    ROSE_ASSERT (target != NULL);
+
+    // must be a parallel region directly under "omp target"
+    SgNode* parent = node->get_parent();
+    ROSE_ASSERT (parent != NULL);
+   if (isSgBasicBlock(parent)) //skip the possible block in between
+      parent = parent->get_parent();
+    SgOmpTargetStatement* target_directive_stmt = isSgOmpTargetStatement(parent);
+    ROSE_ASSERT (target_directive_stmt != NULL);
+
+    // Now we need to ensure that "omp target " has a basic block as its body
+   // so we can insert declarations into an inner block, instead of colliding declarations within the scope of "omp target"
+   // This is important since we often have consecutive "omp target" regions within one big scope
+   // We cannot just insert things into that big scope.
+    SgBasicBlock* omp_target_stmt_body_block = ensureBasicBlockAsBodyOfOmpBodyStmt (target_directive_stmt);
+    ROSE_ASSERT (isSgBasicBlock(target_directive_stmt->get_body()));
+    ROSE_ASSERT (node->get_parent() == target_directive_stmt->get_body()); // OMP PARALLEL should be within the body block now
+
+//    SgFunctionDefinition * func_def = NULL;
+
+    // For Fortran code, we have to insert EXTERNAL OUTLINED_FUNC into 
+    // the function body containing the parallel region
+#if 0
+    if (SageInterface::is_Fortran_language() )
+    {
+      cerr<<"Error. transOmpTargetParallel() does not support Fortran yet. "<<endl; 
+      ROSE_ASSERT (false);
+      func_def = getEnclosingFunctionDefinition(target);
+      ROSE_ASSERT (func_def != NULL);
+    }
+#endif
+    SgStatement * body =  target->get_body();
+    ROSE_ASSERT(body != NULL);
+    // Save preprocessing info as early as possible, avoiding mess up from the outliner
+    AttachedPreprocessingInfoType save_buf1, save_buf2, save_buf_inside;
+    cutPreprocessingInfo(target, PreprocessingInfo::before, save_buf1) ;
+    cutPreprocessingInfo(target, PreprocessingInfo::after, save_buf2) ;
+
+    // 1/15/2009, Liao, also handle the last #endif, which is attached inside of the target
+    cutPreprocessingInfo(target, PreprocessingInfo::inside, save_buf_inside) ;
+
+    //-----------------------------------------------------------------
+    // step 1: generated an outlined function and make it a CUDA function
+    SgOmpClauseBodyStatement * target_parallel_stmt = isSgOmpClauseBodyStatement(node);
+    ROSE_ASSERT (target_parallel_stmt);
+
+    // Prepare the outliner
+    Outliner::enable_classic = true;
+
+    SgBasicBlock* body_block = Outliner::preprocess(body);
+    // translator OpenMP 3.0 and earlier variables.
+    transOmpVariables (target, body_block);
+
+    ASTtools::VarSymSet_t all_syms; // all generated or remaining variables to be passed to the outliner
+    ASTtools::VarSymSet_t addressOf_syms; // generated or remaining variables should be passed by using their addresses
+    transOmpMapVariables (target_directive_stmt, target, body_block, all_syms, addressOf_syms);
+    ASTtools::VarSymSet_t per_block_reduction_syms; // translation generated per block reduction symbols with name like _dev_per_block within the enclosed for loop
+
+    // collect possible per block reduction variables introduced by transOmpTargetLoop()
+    // we rely on the pattern of such variables: _dev_per_block_*     
+    // these variables are arrays already, we pass them by their original types, not addressOf types
+    Rose_STL_Container<SgNode*> nodeList = NodeQuery::querySubTree(body_block,V_SgVarRefExp);
+    for (Rose_STL_Container<SgNode *>::iterator i = nodeList.begin(); i != nodeList.end(); i++)
+    {
+      SgVarRefExp *vRef = isSgVarRefExp((*i));
+      SgName var_name = vRef-> get_symbol()->get_name();
+      string var_name_str = var_name.getString();
+      if (var_name_str.find("_dev_per_block_",0) == 0)
+      {
+        all_syms.insert( vRef-> get_symbol());
+        per_block_reduction_syms.insert (vRef-> get_symbol());
+      }
+    }
+
+    string func_name = Outliner::generateFuncName(target);
+    SgGlobal* g_scope = SageInterface::getGlobalScope(body_block);
+    ROSE_ASSERT(g_scope != NULL);
+
+    std::set< SgInitializedName *> restoreVars;
+    SgFunctionDeclaration* result = 
+        HtOmpSupport::generateFunction(body_block, func_name, all_syms, 
+                                       addressOf_syms, restoreVars, NULL, 
+                                       g_scope, htc_do_split);
+
+    // Save enclosing region and region to function mapping information (Convey)
+    SgStatement *region_stmt = isSgStatement(node);
+    assert(region_stmt);
+    enclosing_regions[result] = findEnclosingParallelOrFunction(region_stmt);
+    outlined_regions[region_stmt] = result;
+  
+
+
+    SgFunctionDeclaration* result_decl = isSgFunctionDeclaration(result->get_firstNondefiningDeclaration());
+    ROSE_ASSERT (result_decl != NULL);
+    result_decl->get_functionModifier().setCudaKernel(); // add __global__ modifier
+    result->get_functionModifier().setCudaKernel();
+
+     // This one is not desired. It inserts the function to the end and prepend a prototype
+    // Outliner::insert(result, g_scope, body_block); 
+    // TODO: better interface to specify where exactly to insert the function!
+    //Custom insertion:  insert right before the enclosing function of "omp target"
+    SgFunctionDeclaration* target_func = const_cast<SgFunctionDeclaration *>
+       (SageInterface::getEnclosingFunctionDeclaration (target));
+     ROSE_ASSERT(target_func!= NULL);
+    insertStatementBefore (target_func, result);
+
+    attachComment (result, "This outlined function is for the coprocessor");
+
+    // TODO: this really should be done within Outliner::generateFunction()
+    // TODO: we have to patch up first nondefining function declaration since custom insertion is used
+    SgGlobal* glob_scope = getGlobalScope(target);
+    ROSE_ASSERT (glob_scope!= NULL);
+    SgFunctionSymbol * func_symbol = glob_scope->lookup_function_symbol(result->get_name());
+    ROSE_ASSERT (func_symbol != NULL);
+    //SgFunctionDeclaration * proto_decl = func_symbol->get_declaration();
+    //ROSE_ASSERT (proto_decl != NULL);
+    //ROSE_ASSERT (proto_decl != result );
+    //result->set_firstNondefiningDeclaration(proto_decl);
+
+    //SgScopeStatement * p_scope = target_directive_stmt ->get_scope(); // the scope of "omp parallel" will be destroyed later, so we use scope of "omp target"
+    SgScopeStatement * p_scope = omp_target_stmt_body_block ; // the scope of "omp parallel" will be destroyed later, so we use scope of "omp target"
+    ROSE_ASSERT(p_scope != NULL);
+   // insert dim3 threadsPerBlock(xomp_get_maxThreadsPerBlock()); 
+    // Convey -- do not do Cuda stuff
+#if 0
+   // TODO: for 1-D mapping, int type is enough,  //TODO: a better interface accepting expression as initializer!!
+    SgVariableDeclaration* threads_per_block_decl = buildVariableDeclaration ("_threads_per_block_", buildIntType(), 
+                  buildAssignInitializer(buildFunctionCallExp("xomp_get_maxThreadsPerBlock",buildIntType(), NULL, p_scope)), 
+                  p_scope);
+    //insertStatementBefore (target_directive_stmt, threads_per_block_decl);
+    insertStatementBefore (target, threads_per_block_decl);
+    attachComment(threads_per_block_decl, string("Launch CUDA kernel ..."));
+
+    // dim3 numBlocks (xomp_get_max1DBlock(VEC_LEN));
+    // TODO: handle 2-D or 3-D using dim type
+    ROSE_ASSERT (cuda_loop_iter_count_1 != NULL);
+    SgVariableDeclaration* num_blocks_decl = buildVariableDeclaration ("_num_blocks_", buildIntType(), 
+                  buildAssignInitializer(buildFunctionCallExp("xomp_get_max1DBlock",buildIntType(), buildExprListExp(cuda_loop_iter_count_1), p_scope)),
+                  p_scope);
+    //insertStatementBefore (target_directive_stmt, num_blocks_decl);
+    insertStatementBefore (target, num_blocks_decl);
+
+    // Now we have num_block declaration, we can insert the per block declaration used for reduction variables
+    SgExpression* shared_data = NULL; // shared data size expression for CUDA kernel execution configuration
+    for (std::vector<SgVariableDeclaration*>::iterator iter = per_block_declarations.begin(); iter != per_block_declarations.end(); iter++)
+    {
+       SgVariableDeclaration* decl = *iter;
+       insertStatementAfter (num_blocks_decl, decl);
+       SgVariableSymbol* sym = getFirstVarSym (decl);
+       SgPointerType * pointer_type = isSgPointerType(sym->get_type());
+       ROSE_ASSERT (pointer_type != NULL);
+       SgType* base_type = pointer_type->get_base_type();
+       if (per_block_declarations.size()>1)
+       {
+        cerr<<"Error. multiple reduction variables are not yet handled."<<endl;
+         ROSE_ASSERT (false);
+         // threadsPerBlock.x*sizeof(REAL)  //TODO: how to handle multiple shared data blocks, each for a reduction variable??   
+       }
+       shared_data = buildMultiplyOp (buildVarRefExp(threads_per_block_decl), buildSizeOfOp (base_type) );
+    }
+    // generate the cuda kernel launch statement
+    //e.g.  axpy_ompacc_cuda <<<numBlocks, threadsPerBlock>>>(dev_x,  dev_y, VEC_LEN, a);
+#endif // Convey
+   
+    //func_symbol = isSgFunctionSymbol(result->get_firstNondefiningDeclaration()->get_symbol_from_symbol_table ());
+    ROSE_ASSERT (func_symbol != NULL);
+    SgExprListExp* exp_list_exp = SageBuilder::buildExprListExp();
+
+    std::set<SgInitializedName*>  varsUsingOriginalForm; 
+    for (ASTtools::VarSymSet_t::const_iterator iter = all_syms.begin(); iter != all_syms.end(); iter ++)
+    {
+      const SgVariableSymbol * current_symbol = *iter;
+      if (addressOf_syms.find(current_symbol) == addressOf_syms.end()) // not found in Address Of variable set
+        varsUsingOriginalForm.insert (current_symbol->get_declaration());
+    }
+    // TODO: alternative mirror form using varUsingAddress as parameter
+    Outliner::appendIndividualFunctionCallArgs (all_syms, varsUsingOriginalForm, exp_list_exp);
+    // TODO: builder interface without _nfi, and match function call exp builder interface convention: 
+
+#if 0 // Convey
+    SgCudaKernelExecConfig * cuda_exe_conf = buildCudaKernelExecConfig_nfi (buildVarRefExp(num_blocks_decl), buildVarRefExp(threads_per_block_decl), shared_data, NULL);
+    setOneSourcePositionForTransformation (cuda_exe_conf);
+    // SgExpression* is not clear, change to SgFunctionRefExp at least!!
+    SgExprStatement* cuda_call_stmt = buildExprStatement(buildCudaKernelCallExp_nfi (buildFunctionRefExp(result), exp_list_exp, cuda_exe_conf) );
+    setSourcePositionForTransformation (cuda_call_stmt);
+    //insertStatementBefore (target_directive_stmt, cuda_call_stmt);
+    insertStatementBefore (target, cuda_call_stmt);
+#else
+    // Convey version
+      SgFunctionCallExp* dispatch_call = 
+          buildFunctionCallExp ("HTC_COPROC_CALL", buildVoidType(), buildExprListExp(buildFunctionRefExp(result), exp_list_exp), p_scope);
+      insertStatementBefore (target, buildExprStatement(dispatch_call));
+#endif
+
+   // insert the beyond block level reduction statement
+   // error = xomp_beyond_block_reduction_float (per_block_results, numBlocks.x, XOMP_REDUCTION_PLUS);
+    for (ASTtools::VarSymSet_t::const_iterator iter = per_block_reduction_syms.begin(); iter != per_block_reduction_syms.end(); iter ++)
+    {
+      const SgVariableSymbol * current_symbol = *iter;
+      SgPointerType* pointer_type = isSgPointerType(current_symbol->get_type());// must be a pointer to simple type
+      ROSE_ASSERT (pointer_type != NULL);
+      SgType * orig_type = pointer_type->get_base_type();
+      ROSE_ASSERT (orig_type != NULL);
+
+      string per_block_var_name = (current_symbol->get_name()).getString();
+      // get the original var name by stripping of the leading "_dev_per_block_"
+      string leading_pattern = string("_dev_per_block_");
+      string orig_var_name = per_block_var_name.substr(leading_pattern.length(), per_block_var_name.length() - leading_pattern.length());
+//      cout<<"debug: "<<per_block_var_name <<" after "<< orig_var_name <<endl;
+      SgExprListExp * parameter_list = buildExprListExp (buildVarRefExp(const_cast<SgVariableSymbol*>(current_symbol)), buildVarRefExp("_num_blocks_",target_directive_stmt->get_scope()), buildIntVal(per_block_reduction_map[const_cast<SgVariableSymbol*>(current_symbol)]) );
+      SgFunctionCallExp* func_call_exp = buildFunctionCallExp ("xomp_beyond_block_reduction_"+ orig_type->unparseToString(), buildVoidType(), parameter_list, target_directive_stmt->get_scope()); 
+     //insertStatementBefore (target_directive_stmt, buildExprStatement(func_call_exp));
+      SgStatement* assign_stmt = buildAssignStatement (buildVarRefExp(orig_var_name, omp_target_stmt_body_block )  ,func_call_exp);
+     ROSE_ASSERT (target->get_scope () == target_directive_stmt->get_body()); // there is a block in between 
+     ROSE_ASSERT (omp_target_stmt_body_block  == target_directive_stmt->get_body()); // just to make sure
+     //insertStatementBefore (target_directive_stmt, buildExprStatement(func_call_exp2));
+     insertStatementBefore (target, assign_stmt );
+
+     // insert memory free for the _dev_per_block_variables
+     // TODO: need runtime support to automatically free memory 
+      SgFunctionCallExp* func_call_exp2 = buildFunctionCallExp ("xomp_freeDevice", buildVoidType(), buildExprListExp(buildVarRefExp(const_cast<SgVariableSymbol*>(current_symbol))),  omp_target_stmt_body_block);
+     //insertStatementBefore (target_directive_stmt, buildExprStatement(func_call_exp2));
+     insertStatementBefore (target, buildExprStatement(func_call_exp2));
+    }
+
+    //------------now remove omp parallel since everything within it has been outlined to a function
+    removeStatement (target);
+  }
+
+
+  /*
+   * Expected AST layout: 
+   *  SgOmpSectionsStatement
+   *    SgBasicBlock
+   *      SgOmpSectionStatement (1 or more section statements here)
+   *        SgBasicBlock
+   *          SgStatement 
+   *
+   * Example translated code: 
+      int _section_1 = XOMP_sections_init_next (3);
+      while (_section_1 >=0) // This while loop is a must
+      {
+        switch (_section_1) {
+          case 0:
+            printf("hello from section 1\n");
+            break;
+          case 1:
+            printf("hello from section 2\n");
+            break;
+          case 2:
+            printf("hello from section 3\n");
+            break;
+          default:
+            printf("fatal error: XOMP_sections_?_next() returns illegal value %d\n", _section_1);
+            abort();
+        }
+        _section_1 = XOMP_sections_next ();  // next round for the current thread: deal with possible number of threads < number of sections
+     }
+    
+      XOMP_sections_end();   // Or  XOMP_sections_end_nowait ();    
+   * */
+  void transOmpSections(SgNode* node)
+  {
+//    cout<<"Entering transOmpSections() ..."<<endl;
+    ROSE_ASSERT(node != NULL );
+    // verify the AST is expected
+    SgOmpSectionsStatement * target = isSgOmpSectionsStatement(node); 
+    ROSE_ASSERT(target != NULL );
+    SgScopeStatement * scope = target->get_scope();
+    ROSE_ASSERT(scope != NULL );
+    SgStatement * body = target->get_body();
+    ROSE_ASSERT(body != NULL);
+
+    SgBasicBlock *  bb1 = buildBasicBlock();
+   
+    SgBasicBlock * sections_block = isSgBasicBlock(body);
+    ROSE_ASSERT (sections_block != NULL);
+       // verify each statement under sections is SgOmpSectionStatement
+    SgStatementPtrList section_list = sections_block-> get_statements();
+    int section_count = section_list.size();
+    for  (int i =0; i<section_count; i++)
+    {
+      SgStatement* stmt = section_list[i];
+      ROSE_ASSERT (isSgOmpSectionStatement(stmt));
+    }
+   
+    // int _section_1 = XOMP_sections_init_next (3);
+    std::string sec_var_name;
+    if (SageInterface::is_Fortran_language() )
+      sec_var_name ="_section_";
+    else  
+      sec_var_name ="xomp_section_";
+
+    sec_var_name += StringUtility::numberToString(++gensym_counter);
+    
+    SgAssignInitializer* initializer = buildAssignInitializer (
+                         buildFunctionCallExp("XOMP_sections_init_next", buildIntType(),buildExprListExp(buildIntVal(section_count)), scope), 
+                                        buildIntType());
+    replaceStatement(target, bb1, true);
+    //Declare a variable to store the current section id
+    //Only used to support lastprivate
+    SgVariableDeclaration* sec_var_decl_save = NULL;
+    if (hasClause(target, V_SgOmpLastprivateClause))
+    {
+      sec_var_decl_save = buildVariableDeclaration(sec_var_name+"_save", buildIntType(), NULL, bb1);
+      appendStatement(sec_var_decl_save, bb1);
+    }
+
+    SgVariableDeclaration* sec_var_decl = buildVariableDeclaration(sec_var_name, buildIntType(), initializer, bb1);
+    appendStatement(sec_var_decl, bb1);
+
+    // while (_section_1 >=0) {}
+    SgWhileStmt * while_stmt = buildWhileStmt(buildGreaterOrEqualOp(buildVarRefExp(sec_var_decl), buildIntVal(0)), buildBasicBlock()); 
+    insertStatementAfter(sec_var_decl, while_stmt);
+    // switch () {}
+    SgSwitchStatement* switch_stmt = buildSwitchStatement (buildExprStatement(buildVarRefExp(sec_var_decl)) , buildBasicBlock()); 
+    appendStatement(switch_stmt, isSgBasicBlock(while_stmt->get_body()));
+    // case 0, case 1, ...
+    for (int i= 0; i<section_count; i++)
+    {
+      SgCaseOptionStmt* option_stmt = buildCaseOptionStmt (buildIntVal(i), buildBasicBlock());
+      // Move SgOmpSectionStatement's body to Case OptionStmt's body
+      SgOmpSectionStatement* section_statement = isSgOmpSectionStatement(section_list[i]);
+      // Sara Royuela (Nov 19th, 2012)
+      // The section statement might not be a Basic Block if there is only one statement and it is not wrapped with braces
+      // In that case, we build here the Basic Block
+      SgBasicBlock * src_bb = isSgBasicBlock(section_statement->get_body());
+      if( src_bb == NULL )
+      {
+          src_bb = ensureBasicBlockAsBodyOfOmpBodyStmt( section_statement );
+      }
+      SgBasicBlock * target_bb =  isSgBasicBlock(option_stmt->get_body());
+      moveStatementsBetweenBlocks(src_bb , target_bb);
+      appendStatement (buildBreakStmt(), target_bb);
+
+      // cout<<"source BB address:"<<isSgBasicBlock(isSgOmpSectionStatement(section_list[i])->get_body())<<endl;
+      // Now we have to delete the source BB since its symbol table is moved into the target BB.
+      SgBasicBlock * fake_src_bb = buildBasicBlock(); 
+      isSgOmpSectionStatement(section_list[i])->set_body(fake_src_bb); 
+      fake_src_bb->set_parent(section_list[i]);
+      delete (src_bb);
+
+      appendStatement (option_stmt,  isSgBasicBlock(switch_stmt->get_body()));
+    } // end case 0, 1, ...  
+    // default option: 
+    SgDefaultOptionStmt* default_stmt = buildDefaultOptionStmt(buildBasicBlock(buildFunctionCallStmt("abort", buildVoidType(), NULL, scope))); 
+    appendStatement (default_stmt,  isSgBasicBlock(switch_stmt->get_body()));
+
+    // save the current section id before checking for next available one
+    // This is only useful to support lastprivate clause
+    if (hasClause(target, V_SgOmpLastprivateClause))
+    {
+      SgStatement* save_stmt = buildAssignStatement (buildVarRefExp(sec_var_decl_save), buildVarRefExp(sec_var_decl)); 
+      appendStatement(save_stmt , isSgBasicBlock(while_stmt->get_body()));
+    }
+    // _section_1 = XOMP_sections_next ();
+    SgStatement* assign_stmt = buildAssignStatement(buildVarRefExp(sec_var_decl), 
+                                 buildFunctionCallExp("XOMP_sections_next", buildIntType(), buildExprListExp(), scope) ); 
+    appendStatement(assign_stmt, isSgBasicBlock(while_stmt->get_body()));
+
+    transOmpVariables(target, bb1, buildIntVal(section_count - 1)); // This should happen before the barrier is inserted.
+
+    // XOMP_sections_end() or XOMP_sections_end_nowait ();
+    SgExprStatement* end_call = NULL; 
+    if (hasClause(target, V_SgOmpNowaitClause))
+      end_call = buildFunctionCallStmt("XOMP_sections_end_nowait", buildVoidType(), NULL, scope);
+    else
+      end_call = buildFunctionCallStmt("XOMP_sections_end", buildVoidType(), NULL, scope);
+
+    appendStatement(end_call,bb1);
+//    removeStatement(target);
+  }
+
+  // Two ways 
+  //1. builtin function TODO
+  //    __sync_fetch_and_add_4(&shared, (unsigned int)local);
+  //2. using atomic runtime call: 
+  //    GOMP_atomic_start (); // void GOMP_atomic_start (void); 
+  //    shared = shared op local;
+  //    GOMP_atomic_end (); // void GOMP_atomic_end (void); 
+  // We use the 2nd method only for now, for simplicity and portability
+  void transOmpAtomic(SgNode* node)
+  {
+    ROSE_ASSERT(node != NULL );
+    SgOmpAtomicStatement* target = isSgOmpAtomicStatement(node);
+    ROSE_ASSERT(target != NULL );
+    SgScopeStatement * scope = target->get_scope();
+    ROSE_ASSERT(scope != NULL );
+    SgStatement * body = target->get_body();
+    ROSE_ASSERT(body != NULL);
+    
+    replaceStatement(target, body, true);
+#ifdef ENABLE_XOMP
+    SgExprStatement* func_call_stmt1 = buildFunctionCallStmt("XOMP_atomic_start", buildVoidType(), NULL, scope);
+    SgExprStatement* func_call_stmt2 = buildFunctionCallStmt("XOMP_atomic_end", buildVoidType(), NULL, scope);
+#else
+    SgExprStatement* func_call_stmt1 = buildFunctionCallStmt("GOMP_atomic_start", buildVoidType(), NULL, scope);
+    SgExprStatement* func_call_stmt2 = buildFunctionCallStmt("GOMP_atomic_end", buildVoidType(), NULL, scope);
+#endif
+    insertStatementBefore(body, func_call_stmt1);
+    // this is actually sensitive to the type of preprocessing Info
+    // In most cases, we want to move up them (such as #ifdef etc)
+    moveUpPreprocessingInfo (func_call_stmt1, body, PreprocessingInfo::before); 
+    insertStatementAfter(body, func_call_stmt2);
+  }
+
+
+  //! Translate omp task
+  /*
+  The translation of omp task is similar to the one for omp parallel
+  Please remember to call patchUpFirstprivateVariables() before this function to make implicit firstprivate
+  variables explicit. 
+  
+  The gomp runtime function for omp task is:
+  extern void GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *), long arg_size, long arg_align, bool if_clause, unsigned flags) 
+      1. void (*fn) (void *): the generated outlined function for the task body
+      2. void *data: the parameters for the outlined function
+      3. void (*cpyfn) (void *, void *): copy function to replace the default memcpy() from function data to each task's data
+      4. long arg_size: specify the size of data
+      5. long arg_align: alignment of the data
+      6. bool if_clause: the value of if_clause. true --> 1, false -->0; default is set to 1 by GCC
+      7. unsigned flags: untied (1) or not (0) 
+
+   Since we use the ROSE outliner to generate the outlined function. The parameters are wrapped into an array of pointers to them
+  So the calculation of data(parameter) size/align is simplified . They are all pointer types.
+  */
+  void transOmpTask(SgNode* node)
+  {
+    ROSE_ASSERT(node != NULL);
+    SgOmpTaskStatement* target = isSgOmpTaskStatement(node);
+    ROSE_ASSERT (target != NULL);
+
+    // Liao 1/24/2011
+    // For Fortran code, we have to insert EXTERNAL OUTLINED_FUNC into 
+    // the function body containing the parallel region
+    // TODO verify this is also necessary for OMP TASK
+    SgFunctionDefinition * func_def = NULL;
+    if (SageInterface::is_Fortran_language() )
+    {
+      func_def = getEnclosingFunctionDefinition(target);
+      ROSE_ASSERT (func_def != NULL);
+    }
+
+    SgStatement * body =  target->get_body();
+    ROSE_ASSERT(body != NULL);
+    // Save preprocessing info as early as possible, avoiding mess up from the outliner
+    AttachedPreprocessingInfoType save_buf1, save_buf2;
+    cutPreprocessingInfo(target, PreprocessingInfo::before, save_buf1) ;
+    cutPreprocessingInfo(target, PreprocessingInfo::after, save_buf2) ;
+
+    // generate and insert an outlined function as a task
+    std::string wrapper_name;
+    ASTtools::VarSymSet_t syms;
+    ASTtools::VarSymSet_t pdSyms3; // store all variables which should be passed by reference
+    std::set<SgInitializedName*> readOnlyVars;
+    SgFunctionDeclaration* outlined_func = generateOutlinedTask (node, wrapper_name, syms, pdSyms3);
+
+    if (SageInterface::is_Fortran_language() )
+    { // EXTERNAL outlined_function , otherwise the function name will be interpreted as a integer/real variable
+      ROSE_ASSERT (func_def != NULL);
+      // There could be an enclosing parallel region
+      //SgBasicBlock * func_body = func_def->get_body();
+      SgBasicBlock * enclosing_body = getEnclosingRegionOrFuncDefinition (target);
+      ROSE_ASSERT (enclosing_body != NULL);
+      SgAttributeSpecificationStatement* external_stmt1 = buildAttributeSpecificationStatement(SgAttributeSpecificationStatement::e_externalStatement)
+;
+      SgFunctionRefExp *func_ref1 = buildFunctionRefExp (outlined_func);
+      external_stmt1->get_parameter_list()->prepend_expression(func_ref1);
+      func_ref1->set_parent(external_stmt1->get_parameter_list());
+      // must put it into the declaration statement part, after possible implicit/include statements, if any
+      SgStatement* l_stmt = findLastDeclarationStatement (enclosing_body);
+      if (l_stmt)
+        insertStatementAfter(l_stmt,external_stmt1);
+      else
+        prependStatement(external_stmt1, enclosing_body);
+    }
+
+
+    SgScopeStatement * p_scope = target->get_scope();
+    ROSE_ASSERT(p_scope != NULL);
+    // Generate a call to it
+   
+    SgExprListExp* parameters =  NULL;
+    //SgStatement* func_call = Outliner::generateCall (outlined_func, syms, readOnlyVars, wrapper_name,p_scope);
+    //ROSE_ASSERT(func_call != NULL);
+
+    // Replace the parallel region with the function call statement
+    // TODO should we introduce another level of scope here?
+    // SageInterface::replaceStatement(target,func_call, true);
+    // hide this from the unparser TODO this call statement is not really necessary, only the call expression is needed
+    //  Sg_File_Info* file_info = type_decl->get_file_info();
+    //      file_info->unsetOutputInCodeGeneration ();
+    //
+    //func_call->get_file_info()->unsetOutputInCodeGeneration (); 
+    SgExpression * parameter_data = NULL;
+    SgExpression * parameter_cpyfn = NULL;
+    SgExpression * parameter_arg_size = NULL;
+    SgExpression * parameter_arg_align = NULL;
+    SgExpression * parameter_if_clause =  NULL;
+    SgExpression * parameter_untied = NULL;
+    SgExpression * parameter_argcount = NULL;
+    size_t parameter_count = syms.size();
+   
+    if (SageInterface::is_Fortran_language())
+    { // Fortran case
+    //  void xomp_task (void (*fn) (void *), void (*cpyfn) (void *, void *), int * arg_size, int * arg_align, 
+    //                  int * if_clause, int * untied, int * argcount, ...)
+      
+        parameter_cpyfn=buildIntVal(0); // no special copy function for array of pointers
+        parameter_arg_size = buildIntVal( parameter_count * sizeof(void*) );
+        //  TODO get right alignment
+        parameter_arg_align = buildIntVal(4);
+    }
+    else // C/C++ case
+    //  void GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *), long arg_size, long arg_align, 
+    //                  bool if_clause, unsigned flags)
+    { 
+      if ( parameter_count == 0) // No parameters to be passed at all
+      {
+        parameter_data = buildIntVal(0);
+        parameter_cpyfn=buildIntVal(0); // no copy function is needed
+        parameter_arg_size = buildIntVal(0);
+        parameter_arg_align = buildIntVal(0);
+      }
+      else
+      {
+        SgVarRefExp * data_ref = buildVarRefExp(wrapper_name, p_scope);
+        ROSE_ASSERT (data_ref != NULL);
+        SgType * data_type = data_ref->get_type();
+        parameter_data =  buildAddressOfOp(data_ref);
+        parameter_cpyfn=buildIntVal(0); // no special copy function for array of pointers
+        // arg size of array of pointers = pointer_count * pointer_size
+        // ROSE does not support cross compilation so sizeof(void*) can use as a workaround for now
+        //we now use a structure containing pointers or non-pointer typed members to wrap parameters
+        parameter_arg_size =  buildSizeOfOp(data_type);
+        //  parameter_arg_size = buildIntVal( parameter_count* sizeof(void*));
+        //  TODO get right alignment
+        parameter_arg_align = buildIntVal(4);
+        //parameter_arg_align = buildIntVal(sizeof(void*));
+      }
+
+    }
+
+    if (hasClause(target, V_SgOmpIfClause))
+    {
+      Rose_STL_Container<SgOmpClause*> clauses = getClause(target, V_SgOmpIfClause);
+      ROSE_ASSERT (clauses.size() ==1); // should only have one if ()
+      SgOmpIfClause * if_clause = isSgOmpIfClause (clauses[0]);
+      ROSE_ASSERT (if_clause->get_expression() != NULL);
+      parameter_if_clause = copyExpression(if_clause->get_expression());
+    }
+    else
+      parameter_if_clause = buildIntVal(1);
+
+    if (hasClause(target, V_SgOmpUntiedClause))
+      parameter_untied = buildIntVal(1);
+    else  
+      parameter_untied = buildIntVal(0);
+
+    
+   // parameters are different between Fortran and C/C++
+   // To support pass-by-value and pass-by-reference in the XOMP runtime
+   // We use a triplet for each parameter to be passed to XOMP
+   // <pass_by_value-ref, value-size, parameter-address>
+   // e.g. if a integer i is intended to be passed by value in the task
+   //   we generate three argument for it: 1, sizeof(int), i
+    // similarly, for an array item[10], passed by reference in the task
+    //   we generate: 0, sizeof(void*), item
+    //   As a result, the variable length argument list is 3 times the count of original parameters long
+    if (SageInterface::is_Fortran_language())
+    {
+      parameters = buildExprListExp(buildFunctionRefExp(outlined_func),
+        parameter_cpyfn, parameter_arg_size, parameter_arg_align, parameter_if_clause, parameter_untied);
+
+      parameter_argcount =  buildIntVal (syms.size()*3);
+      appendExpression (parameters,parameter_argcount);
+      ASTtools::VarSymSet_t::iterator iter = syms.begin();
+      for (; iter!=syms.end(); iter++)
+      {
+        const SgVariableSymbol * sb = *iter;
+        bool b_pass_value = true;
+        // Assumption: 
+        //   transOmpVariables() should already handled most private, reduction variables
+        //    Anything left should be passed by reference by default , except for loop index variables. 
+        // We check if a variable is a loop index, and pass it by value. 
+        //   
+        // TODO more accurate way to decide on pass-by-value or pass-by-reference in patchUpPrivateVariables()
+        //    and patchUpFirstprivateVariables()
+        if (isLoopIndexVariable (sb->get_declaration(), target))
+        {
+          b_pass_value = true;
+          appendExpression (parameters,buildIntVal(1));
+        }
+        else
+        { // all other should be treated as shared variables ( pass-by-reference )
+          b_pass_value = false;
+          appendExpression (parameters,buildIntVal(0));
+        }
+
+        //2nd of the triplet, the size of the parameter type, 
+        // if pass-by-value, the actual size
+        // if pass-by-reference, the pointer size
+        if (b_pass_value)
+        { //TODO accurate calculation of type size for Fortran, assume integer for now
+           // Provide an interface function for this.
+          // Is it feasible to calculate all sizes during compilation time ??
+          SgType * s_type = sb->get_type();
+          if (isSgTypeInt(s_type))
+            appendExpression (parameters,buildIntVal(sizeof(int)));
+          else
+          {
+            printf("Error. transOmpTask(): unhandled Fortran type  (%s) for pass-by-value.\n",s_type->class_name().c_str());
+            ROSE_ASSERT (false);
+          }
+        }
+        else  
+        { // get target platform's pointer size 
+          appendExpression (parameters,buildIntVal(sizeof(void*)));
+        }
+        
+        // the third of the triplet
+        appendExpression (parameters, buildVarRefExp(const_cast<SgVariableSymbol *>(sb)));
+      }
+    }  
+    else
+    {
+      parameters = buildExprListExp(buildFunctionRefExp(outlined_func),
+        parameter_data, parameter_cpyfn, parameter_arg_size, parameter_arg_align, parameter_if_clause, parameter_untied);
+    }
+
+#ifdef ENABLE_XOMP
+    SgExprStatement * s1 = buildFunctionCallStmt("XOMP_task", buildVoidType(), parameters, p_scope);
+#else    
+    SgExprStatement * s1 = buildFunctionCallStmt("GOMP_task", buildVoidType(), parameters, p_scope);
+#endif
+    SageInterface::replaceStatement(target,s1, true);
+
+    // Keep preprocessing information
+    // I have to use cut-paste instead of direct move since 
+    // the preprocessing information may be moved to a wrong place during outlining
+    // while the destination node is unknown until the outlining is done.
+    pastePreprocessingInfo(s1, PreprocessingInfo::before, save_buf1);
+    pastePreprocessingInfo(s1, PreprocessingInfo::after, save_buf2);
+  }
+
+  //! Translate the ordered directive, (not the ordered clause)
+  void transOmpOrdered(SgNode* node)
+  {
+    ROSE_ASSERT(node != NULL );
+    SgOmpOrderedStatement* target = isSgOmpOrderedStatement(node);
+    ROSE_ASSERT(target != NULL );
+    SgScopeStatement * scope = target->get_scope();
+    ROSE_ASSERT(scope != NULL );
+    SgStatement * body = target->get_body();
+    ROSE_ASSERT(body != NULL);
+
+    replaceStatement(target, body,true);
+#ifdef ENABLE_XOMP
+    SgExprStatement* func_call_stmt1 = buildFunctionCallStmt("XOMP_ordered_start", buildVoidType(), NULL, scope);
+    SgExprStatement* func_call_stmt2 = buildFunctionCallStmt("XOMP_ordered_end", buildVoidType(), NULL, scope);
+#else
+    SgExprStatement* func_call_stmt1 = buildFunctionCallStmt("GOMP_ordered_start", buildVoidType(), NULL, scope);
+    SgExprStatement* func_call_stmt2 = buildFunctionCallStmt("GOMP_ordered_end", buildVoidType(), NULL, scope);
+#endif
+    insertStatementBefore(body, func_call_stmt1);
+    insertStatementAfter(body, func_call_stmt2);
+  }
+
+  // Two cases:
+  // unnamed one
+  //   GOMP_critical_start ();
+  //   work()
+  //   GOMP_critical_end ();
+  //
+  // named one: 
+  //  static gomp_mutex_t  &gomp_critical_user_aaa;
+  //  GOMP_critical_name_start (&gomp_critical_user_aaa);
+  //  work()
+  //  GOMP_critical_name_end (&gomp_critical_user_aaa);
+  //
+  void transOmpCritical(SgNode* node)
+  {
+    ROSE_ASSERT(node != NULL );
+    SgOmpCriticalStatement* target = isSgOmpCriticalStatement(node);
+    ROSE_ASSERT(target != NULL );
+    SgScopeStatement * scope = target->get_scope();
+    ROSE_ASSERT(scope != NULL );
+
+    SgStatement * body = target->get_body();
+    ROSE_ASSERT(body != NULL);
+
+    replaceStatement(target, body,true);
+
+    SgExprStatement* func_call_stmt1=NULL, * func_call_stmt2 =NULL;
+    string c_name = target->get_name().getString();
+#ifdef ENABLE_XOMP    
+    // assign a default name for the unnamed critical to simplify the translation
+    // GOMP actually have a dedicated function to support unnamed critical
+    // We generate a default name for it and use the named critical support function instead to
+    // be consistent with OMNI
+      string g_lock_name = "xomp_critical_user_" + c_name;
+      SgGlobal* global = getGlobalScope(target);
+      ROSE_ASSERT(global!=NULL);
+      // the lock variable may already be declared.
+      SgVariableSymbol* sym = lookupVariableSymbolInParentScopes(SgName(g_lock_name),global); 
+      if (sym == NULL)
+      {
+        SgVariableDeclaration* vardecl = buildVariableDeclaration(g_lock_name, buildPointerType(buildVoidType()), NULL, global);
+        setStatic(vardecl);
+        prependStatement(vardecl,global);
+        sym = getFirstVarSym(vardecl);
+      }
+
+      SgExprListExp * param1= buildExprListExp(buildAddressOfOp(buildVarRefExp(sym)));
+      SgExprListExp * param2= buildExprListExp(buildAddressOfOp(buildVarRefExp(sym)));
+
+      func_call_stmt1 = buildFunctionCallStmt("XOMP_critical_start", buildVoidType(), param1, scope);
+      func_call_stmt2 = buildFunctionCallStmt("XOMP_critical_end", buildVoidType(), param2, scope);
+#else    
+    if (c_name.length()==0)
+    {
+      func_call_stmt1 = buildFunctionCallStmt("GOMP_critical_start", buildVoidType(), NULL, scope);
+      func_call_stmt2 = buildFunctionCallStmt("GOMP_critical_end", buildVoidType(), NULL, scope);
+    }
+    else
+    {
+      string g_lock_name = "gomp_critical_user_" + c_name;
+      SgGlobal* global = getGlobalScope(target);
+      ROSE_ASSERT(global!=NULL);
+      // gomp_mutex_t is not declared by the RTL header. We use int instead.
+      SgVariableDeclaration* vardecl = buildVariableDeclaration(g_lock_name, buildPointerType(buildVoidType()), NULL, global);
+      //SgVariableDeclaration* vardecl = buildVariableDeclaration(g_lock_name, buildOpaqueType("gomp_mutex_t",global), NULL, global);
+      setStatic(vardecl);
+      prependStatement(vardecl,global);
+      SgExprListExp * param1= buildExprListExp(buildAddressOfOp(buildVarRefExp(vardecl)));
+      SgExprListExp * param2= buildExprListExp(buildAddressOfOp(buildVarRefExp(vardecl)));
+      func_call_stmt1 = buildFunctionCallStmt("GOMP_critical_name_start", buildVoidType(), param1, scope);
+      func_call_stmt2 = buildFunctionCallStmt("GOMP_critical_name_end", buildVoidType(), param2, scope);
+    }
+#endif    
+
+    insertStatementBefore(body, func_call_stmt1);
+    insertStatementAfter(body, func_call_stmt2);
+  }
+
+  //! Simply replace the pragma with a function call to void GOMP_taskwait(void); 
+  void transOmpTaskwait(SgNode * node)
+  {
+    ROSE_ASSERT(node != NULL );
+    SgOmpTaskwaitStatement* target = isSgOmpTaskwaitStatement(node);
+    ROSE_ASSERT(target != NULL );
+    SgScopeStatement * scope = target->get_scope();
+    ROSE_ASSERT(scope != NULL );
+#ifdef ENABLE_XOMP
+    SgExprStatement* func_call_stmt = buildFunctionCallStmt("XOMP_taskwait", buildVoidType(), NULL, scope);
+#else    
+    SgExprStatement* func_call_stmt = buildFunctionCallStmt("GOMP_taskwait", buildVoidType(), NULL, scope);
+#endif
+    replaceStatement(target, func_call_stmt, true);
+  }
+
+  //! Simply replace the pragma with a function call to void GOMP_barrier (void); 
+  void transOmpBarrier(SgNode * node)
+  {
+    ROSE_ASSERT(node != NULL );
+    SgOmpBarrierStatement* target = isSgOmpBarrierStatement(node);
+    ROSE_ASSERT(target != NULL );
+    SgScopeStatement * scope = target->get_scope();
+    ROSE_ASSERT(scope != NULL );
+
+#ifdef ENABLE_XOMP // test new translation targeting a middle layer of runtime library
+    SgExprStatement* func_call_stmt = buildFunctionCallStmt("XOMP_barrier", buildVoidType(), NULL, scope);
+#else
+    SgExprStatement* func_call_stmt = buildFunctionCallStmt("GOMP_barrier", buildVoidType(), NULL, scope);
+#endif    
+    replaceStatement(target, func_call_stmt, true);
+  }
+
+  //! Simply replace the pragma with a function call to __sync_synchronize ();
+  void transOmpFlush(SgNode * node)
+  {
+    ROSE_ASSERT(node != NULL );
+    SgOmpFlushStatement* target = isSgOmpFlushStatement(node);
+    ROSE_ASSERT(target != NULL );
+    SgScopeStatement * scope = target->get_scope();
+    ROSE_ASSERT(scope != NULL );
+
+#ifdef ENABLE_XOMP
+    SgExprStatement* func_call_stmt = buildFunctionCallStmt("XOMP_flush_all", buildVoidType(), NULL, scope);
+#else
+    SgExprStatement* func_call_stmt = buildFunctionCallStmt("__sync_synchronize", buildVoidType(), NULL, scope);
+#endif
+    replaceStatement(target, func_call_stmt, true);
+  }
+
+// Convey -- Declare the CHtHif class skeleton
+SgClassDeclaration* declareCHtHif(SgGlobal *glob_scope) {
+
+    SgClassDeclaration *htdecl =
+        buildClassDeclaration_nfi( "CHtHif",
+                                   SgClassDeclaration::e_class,
+                                   glob_scope,
+                                   0,
+                                   false,
+                                   new SgTemplateArgumentPtrList);
+        SageInterface::prependStatement(htdecl, glob_scope);
+    return htdecl;
+}
+
+
+SgVariableDeclaration *declareHTUnits(SgClassDeclaration *htdecl,
+                           SgGlobal *glob_scope) 
+{
+    SgArrayType *type = 
+        buildArrayType(buildPointerType(htdecl->get_type()), buildIntVal(16));
+    SgVariableDeclaration *units = 
+        buildVariableDeclaration("__htc_units", type, 0, glob_scope);
+    insertStatementAfter(htdecl, units);
+    return units;
+}
+
+SgVariableDeclaration *declareHTUnitIndex(SgClassDeclaration *htdecl,
+                           SgGlobal *glob_scope) 
+{
+    SgType *type = buildIntType();
+    SgVariableDeclaration *unit_index = 
+        buildVariableDeclaration("__htc_unit_index", type, 0, glob_scope);
+    insertStatementAfter(htdecl, unit_index);
+    return unit_index;
+}
+
+void addUnitCountForLoopTextAroundStmt(SgStatement *S) {
+
+    std::string before_text =
+        "\n   for (__htc_unit_index = 0; __htc_unit_index < __htc_unit_count;\n";
+    before_text += "        __htc_unit_index++) {\n";
+    SageInterface::addTextForUnparser(S, before_text,
+                                      AstUnparseAttribute::e_before);
+    // Dummy call with empty string so the e_after on the next
+    // call will be honored.
+    SageInterface::addTextForUnparser(S, "",
+                                      AstUnparseAttribute::e_after);
+    std::string after_text =
+        "\n    }\n";
+    SageInterface::addTextForUnparser(S, after_text,
+                                      AstUnparseAttribute::e_after);
+
+
+
+}
+
+  //! Simply move the body up and remove omp target directive since nothing to be done at this level
+  void transOmpTarget(SgNode * node)
+  {
+    // Sanity check first
+    ROSE_ASSERT(node != NULL);
+    SgOmpTargetStatement* target = isSgOmpTargetStatement(node);
+    ROSE_ASSERT (target != NULL);
+    SgOmpTargetStatement* target_directive_stmt = target;
+
+    static bool first = true;
+    static SgClassDeclaration *htdecl;
+    SgVariableDeclaration *units;
+    SgVariableDeclaration *unit_index;
+
+    if (first) {
+        HtSageUtils::DeclareFunctionInScope("usleep", 
+                                            buildVoidType(), 
+                                            getGlobalScope(target));
+        htdecl = declareCHtHif(getGlobalScope(target));
+        units = declareHTUnits(htdecl, getGlobalScope(target));
+        unit_index = declareHTUnitIndex(htdecl, getGlobalScope(target));
+
+        std::string before_ht = "\n#ifdef CNY_HTC_HOST";
+        SageInterface::addTextForUnparser(htdecl, 
+                                          before_ht,
+                                          AstUnparseAttribute::e_before);
+
+        // Dummy call with empty string so the e_after on the next
+        // call will be honored.
+        SageInterface::addTextForUnparser(units, "",
+                                          AstUnparseAttribute::e_after);
+        std::string after_units =
+        "\n#endif /* CNY_HTC_HOST */\n";
+        SageInterface::addTextForUnparser(units, after_units,
+                                          AstUnparseAttribute::e_after);
+
+        first = false;
+    }
+
+    // Now we need to ensure that "omp target " has a basic block as its body
+    // so we can insert declarations into an inner block, instead of colliding 
+    // declarations within the scope of "omp target"
+    // This is important since we often have consecutive "omp target" regions 
+    // within one big scope.
+    // We cannot just insert things into that big scope.
+    SgBasicBlock* omp_target_stmt_body_block = 
+        ensureBasicBlockAsBodyOfOmpBodyStmt (target_directive_stmt);
+    ROSE_ASSERT (isSgBasicBlock(target_directive_stmt->get_body()));
+
+    SgStatement * body =  target->get_body();
+    ROSE_ASSERT(body != NULL);
+
+    // Save preprocessing info as early as possible, avoiding mess up 
+    // from the outliner
+    AttachedPreprocessingInfoType save_buf1, save_buf2, save_buf_inside;
+    cutPreprocessingInfo(target, PreprocessingInfo::before, save_buf1) ;
+    cutPreprocessingInfo(target, PreprocessingInfo::after, save_buf2) ;
+
+    // Also handle the last #endif, which is attached inside of the target
+    cutPreprocessingInfo(target, PreprocessingInfo::inside, save_buf_inside) ;
+
+    //-----------------------------------------------------------------
+    // step 1: generated an outlined function
+
+    // Prepare the outliner
+    Outliner::enable_classic = true;
+
+    SgBasicBlock* body_block = Outliner::preprocess(body);
+    // translator OpenMP 3.0 and earlier variables.
+    transOmpVariables (target, body_block);
+
+    // all generated or remaining variables to be passed to the outliner
+    ASTtools::VarSymSet_t all_syms; 
+    // generated or remaining variables should be passed by address
+    ASTtools::VarSymSet_t addressOf_syms; 
+
+    // RANDY:   FIX THIS    
+    transOmpMapVariables (target_directive_stmt, 0, body_block, 
+                          all_syms, addressOf_syms);
+
+#if 0
+    // translation generated per block reduction symbols with name like 
+    // _dev_per_block within the enclosed for loop    
+    ASTtools::VarSymSet_t per_block_reduction_syms; 
+
+    // collect possible per block reduction variables introduced by transOmpTargetLoop()
+    // we rely on the pattern of such variables: _dev_per_block_*     
+    // these variables are arrays already, we pass them by their original types, not addressOf types
+    Rose_STL_Container<SgNode*> nodeList = NodeQuery::querySubTree(body_block,V_SgVarRefExp);
+    for (Rose_STL_Container<SgNode *>::iterator i = nodeList.begin(); i != nodeList.end(); i++)
+    {
+      SgVarRefExp *vRef = isSgVarRefExp((*i));
+      SgName var_name = vRef-> get_symbol()->get_name();
+      string var_name_str = var_name.getString();
+      if (var_name_str.find("_dev_per_block_",0) == 0)
+      {
+        all_syms.insert( vRef-> get_symbol());
+        per_block_reduction_syms.insert (vRef-> get_symbol());
+      }
+    }
+#endif
+
+    string func_name = Outliner::generateFuncName(target);
+    SgGlobal* g_scope = SageInterface::getGlobalScope(body_block);
+    ROSE_ASSERT(g_scope != NULL);
+
+    std::set< SgInitializedName *> restoreVars;
+    SgFunctionDeclaration* result = 
+        HtOmpSupport::generateFunction(body_block, func_name, all_syms, 
+                                       addressOf_syms, restoreVars, NULL, 
+                                       g_scope, false);
+
+    SgFunctionDeclaration* result_decl = 
+        isSgFunctionDeclaration(result->get_firstNondefiningDeclaration());
+    ROSE_ASSERT (result_decl != NULL);
+
+    SgFunctionDeclaration* target_func = const_cast<SgFunctionDeclaration *>
+       (SageInterface::getEnclosingFunctionDeclaration (target));
+    ROSE_ASSERT(target_func!= NULL);
+    insertStatementBefore (target_func, result);
+
+    SgNode *result_body = result->get_definition()->get_body();
+    std::string before_text = "\n#ifdef CNY_HTC_COPROC";
+    SageInterface::addTextForUnparser(result, 
+                                      before_text,
+                                      AstUnparseAttribute::e_before);
+    // Dummy call with empty string so the e_after on the next
+    // call will be honored.
+    SageInterface::addTextForUnparser(result_body, "",
+                                      AstUnparseAttribute::e_after);
+    std::string after_text =
+        "\n#endif /* CNY_HTC_COPROC */\n";
+    SageInterface::addTextForUnparser(result_body, after_text,
+                                      AstUnparseAttribute::e_after);
+
+    // TODO: this really should be done within Outliner::generateFunction()
+    // TODO: we have to patch up first nondefining function declaration 
+    //       since custom insertion is used
+    SgGlobal* glob_scope = getGlobalScope(target);
+    ROSE_ASSERT (glob_scope!= NULL);
+
+    SgScopeStatement * p_scope = omp_target_stmt_body_block;
+    ROSE_ASSERT(p_scope != NULL);
+
+    SgExprListExp* exp_list_exp = SageBuilder::buildExprListExp();
+
+    std::set<SgInitializedName*>  varsUsingOriginalForm; 
+    for (ASTtools::VarSymSet_t::const_iterator iter = all_syms.begin(); 
+         iter != all_syms.end(); iter ++) {
+        const SgVariableSymbol * current_symbol = *iter;
+        if ((addressOf_syms.find(current_symbol) == addressOf_syms.end()) &&
+            (varsUsingOriginalForm.find(current_symbol->get_declaration()) == varsUsingOriginalForm.end())) {
+            varsUsingOriginalForm.insert (current_symbol->get_declaration());
+        }
+    }
+
+    Outliner::appendIndividualFunctionCallArgs (all_syms, 
+                                                varsUsingOriginalForm, 
+                                                exp_list_exp);
+
+    // Convey version
+    SgFunctionCallExp* dispatch_call;
+    SgFunctionCallExp* return_call;
+    SgMemberFunctionSymbol *mf_sym;
+    SgMemberFunctionRefExp *mfr;
+
+    // __htc_units[unit]->SendCall_hello();
+
+    SgMemberFunctionDeclaration *call_function =
+        SageBuilder::buildDefiningMemberFunctionDeclaration (
+            "SendCall_" + func_name, 
+            buildVoidType(), 
+            buildFunctionParameterList_nfi(),
+            htdecl->get_definition());
+    htdecl->get_definition()->append_member(call_function);
+
+    mf_sym = new SgMemberFunctionSymbol(call_function);
+    mfr = buildMemberFunctionRefExp_nfi(mf_sym, false, false);
+    mf_sym->set_parent(mfr);
+
+    dispatch_call = 
+        buildFunctionCallExp(
+            buildArrowExp( 
+                buildPntrArrRefExp(buildVarRefExp(units), 
+                                   buildVarRefExp(unit_index)),
+                mfr),
+            exp_list_exp);
+    dispatch_call->set_parent(p_scope);
+    SgExprStatement *dispatch_stmt = buildExprStatement(dispatch_call);
+    insertStatementBefore (target, dispatch_stmt);
+
+    addUnitCountForLoopTextAroundStmt(dispatch_stmt);
+
+    SgMemberFunctionDeclaration *return_function =
+        SageBuilder::buildDefiningMemberFunctionDeclaration (
+            "RecvReturn_" + func_name, 
+            buildIntType(), 
+            buildFunctionParameterList_nfi(),
+            htdecl->get_definition());
+    htdecl->get_definition()->append_member(return_function);
+
+    mf_sym = new SgMemberFunctionSymbol(return_function);
+    mfr = buildMemberFunctionRefExp_nfi(mf_sym, false, false);
+    mf_sym->set_parent(mfr);
+
+    return_call = 
+        buildFunctionCallExp(
+            buildArrowExp( 
+                buildPntrArrRefExp(buildVarRefExp(units), 
+                                   buildVarRefExp(unit_index)),
+                mfr),
+            buildExprListExp());
+    return_call->set_parent(p_scope);
+
+    SgExpression *not_expr = buildNotOp(return_call);
+
+    SgBasicBlock *while_block = buildBasicBlock();
+
+    SgExprListExp *usleep_args = buildExprListExp();
+    appendExpression(usleep_args, buildIntVal(1000));
+    SgFunctionCallExp *usleep_call = 
+        buildFunctionCallExp("usleep",
+                             buildVoidType(),
+                             usleep_args,
+                             p_scope);
+    SgExprStatement *usleep_stmt = buildExprStatement(usleep_call);
+    prependStatement(usleep_stmt, while_block);
+
+    SgWhileStmt *while_stmt = 
+        buildWhileStmt(not_expr, while_block, 0);
+
+    //    SgExprStatement *return_stmt = buildExprStatement(return_call);
+    insertStatementAfter(dispatch_stmt, while_stmt);
+
+    addUnitCountForLoopTextAroundStmt(while_stmt);
+
+#if 0
+    // insert the beyond block level reduction statement
+    for (ASTtools::VarSymSet_t::const_iterator iter = per_block_reduction_syms.begin(); iter != per_block_reduction_syms.end(); iter ++) {
+        const SgVariableSymbol * current_symbol = *iter;
+        SgPointerType* pointer_type = isSgPointerType(current_symbol->get_type());// must be a pointer to simple type
+        ROSE_ASSERT (pointer_type != NULL);
+        SgType * orig_type = pointer_type->get_base_type();
+        ROSE_ASSERT (orig_type != NULL);
+
+        string per_block_var_name = (current_symbol->get_name()).getString();
+        // get the original var name by stripping of the leading "_dev_per_block_"
+        string leading_pattern = string("_dev_per_block_");
+        string orig_var_name = per_block_var_name.substr(leading_pattern.length(), per_block_var_name.length() - leading_pattern.length());
+        //      cout<<"debug: "<<per_block_var_name <<" after "<< orig_var_name <<endl;
+        SgExprListExp * parameter_list = buildExprListExp (buildVarRefExp(const_cast<SgVariableSymbol*>(current_symbol)), buildVarRefExp("_num_blocks_",target_directive_stmt->get_scope()), buildIntVal(per_block_reduction_map[const_cast<SgVariableSymbol*>(current_symbol)]) );
+        SgFunctionCallExp* func_call_exp = buildFunctionCallExp ("xomp_beyond_block_reduction_"+ orig_type->unparseToString(), buildVoidType(), parameter_list, target_directive_stmt->get_scope()); 
+     //insertStatementBefore (target_directive_stmt, buildExprStatement(func_call_exp));
+        SgStatement* assign_stmt = buildAssignStatement (buildVarRefExp(orig_var_name, omp_target_stmt_body_block )  ,func_call_exp);
+        ROSE_ASSERT (target->get_scope () == target_directive_stmt->get_body()); // there is a block in between 
+        ROSE_ASSERT (omp_target_stmt_body_block  == target_directive_stmt->get_body()); // just to make sure
+        //insertStatementBefore (target_directive_stmt, buildExprStatement(func_call_exp2));
+        insertStatementBefore (target, assign_stmt );
+
+        // insert memory free for the _dev_per_block_variables
+        // TODO: need runtime support to automatically free memory 
+        SgFunctionCallExp* func_call_exp2 = buildFunctionCallExp ("xomp_freeDevice", buildVoidType(), buildExprListExp(buildVarRefExp(const_cast<SgVariableSymbol*>(current_symbol))),  omp_target_stmt_body_block);
+        //insertStatementBefore (target_directive_stmt, buildExprStatement(func_call_exp2));
+        insertStatementBefore (target, buildExprStatement(func_call_exp2));
+    }
+#endif
+
+    //------------now remove omp target since everything within it has been outlined to a function
+    removeStatement (target);
+  }
+
+  //! Simply move the body up and remove omp target data directive since nothing to be done at this level for now
+  //  all map() clauses should already be handled when translating the inner "omp parallel" region
+  // TODO: translate if() and device() clauses
+  void transOmpTargetData(SgNode * node)
+  {
+    ROSE_ASSERT(node != NULL );
+    SgOmpTargetDataStatement* target = isSgOmpTargetDataStatement(node);
+    ROSE_ASSERT(target != NULL );
+
+    SgScopeStatement * scope = target->get_scope();
+    ROSE_ASSERT(scope != NULL );
+
+    SgBasicBlock* body = isSgBasicBlock(target->get_body());
+    ROSE_ASSERT(body != NULL );
+    body->set_parent(NULL);
+    target->set_body(NULL);
+
+    replaceStatement (target, body, true); 
+    attachComment (body, "Translated from #pragma omp target data ...");
+   // removeStatement(target);
+  }
+
+
+  //! Add __thread for each threadprivate variable's declaration statement and remove the #pragma omp threadprivate(...) 
+  void transOmpThreadprivate(SgNode * node)
+  {
+    ROSE_ASSERT(node != NULL );
+    SgOmpThreadprivateStatement* target = isSgOmpThreadprivateStatement(node);
+    ROSE_ASSERT(target != NULL );
+
+    SgVarRefExpPtrList nameList = target->get_variables ();
+    for (size_t i = 0; i<nameList.size(); i++)
+    {
+      SgInitializedName* init_name = nameList[i]->get_symbol()->get_declaration();
+      ROSE_ASSERT(init_name != NULL);
+      SgVariableDeclaration*  decl = isSgVariableDeclaration(init_name-> get_declaration());
+      ROSE_ASSERT (decl != NULL);
+     // cout<<"setting TLS for decl:"<<decl->unparseToString()<< endl;
+      decl->get_declarationModifier().get_storageModifier().set_thread_local_storage(true);
+      // choice between set TLS to declaration or init_name (not working) ?
+     // init_name-> get_storageModifier ().set_thread_local_storage (true); 
+    }
+
+    // 6/8/2010, handling #if attached to #pragma omp threadprivate
+    SgStatement* n_stmt = getNextStatement(target);
+    if (n_stmt == NULL) 
+    {
+      cerr<<"Warning: found an omp threadprivate directive without a following statement."<<endl;
+      cerr<<"Warning: the attached preprocessing information to the directive may get lost during translation!"<<endl;
+    }
+    else
+    {
+      // preserve preprocessing information attached to the pragma,
+      // by moving it to the beginning of the preprocessing info list of the next statement .
+      movePreprocessingInfo(target, n_stmt, PreprocessingInfo::before, PreprocessingInfo::before, true);
+    }
+
+    removeStatement(target);
+  }
+
+
+  //! Collect variables from OpenMP clauses: including private, firstprivate, lastprivate, reduction, etc.
+  SgInitializedNamePtrList collectClauseVariables (SgOmpClauseBodyStatement * clause_stmt, const VariantT & vt)
+  {
+    return collectClauseVariables(clause_stmt, VariantVector(vt));
+  }
+
+  // Collect variables from an OpenMP clause: including private, firstprivate, lastprivate, reduction, etc.
+  SgInitializedNamePtrList collectClauseVariables (SgOmpClauseBodyStatement * clause_stmt, const VariantVector & vvt)
+  {
+    SgInitializedNamePtrList result, result2;
+    ROSE_ASSERT(clause_stmt != NULL);
+    Rose_STL_Container<SgOmpClause*> p_clause =
+      NodeQuery::queryNodeList<SgOmpClause>(clause_stmt->get_clauses(),vvt);
+    for (size_t i =0; i< p_clause.size(); i++) // can have multiple reduction clauses of different reduction operations
+    {  
+      //result2 = isSgOmpVariablesClause(p_clause[i])->get_variables();  
+      // get initialized name from varRefExp
+      SgVarRefExpPtrList refs = isSgOmpVariablesClause(p_clause[i])->get_variables();
+      result2.clear();
+      for (size_t j =0; j< refs.size(); j++)
+         result2.push_back(refs[j]->get_symbol()->get_declaration()); 
+      std::copy(result2.begin(), result2.end(), back_inserter(result));
+    }
+    return result;
+  }
+
+  //! Collect all variables from OpenMP clauses associated with an omp statement: private, reduction, etc 
+  SgInitializedNamePtrList collectAllClauseVariables (SgOmpClauseBodyStatement * clause_stmt)
+  {
+    ROSE_ASSERT(clause_stmt != NULL);
+
+    VariantVector vvt = VariantVector(V_SgOmpCopyinClause);
+    vvt.push_back(V_SgOmpCopyprivateClause);
+    vvt.push_back(V_SgOmpFirstprivateClause);
+    vvt.push_back(V_SgOmpLastprivateClause);
+    vvt.push_back(V_SgOmpPrivateClause);
+    vvt.push_back(V_SgOmpReductionClause);
+    // TODO : do we care about shared(var_list)?
+
+    return collectClauseVariables(clause_stmt, vvt);
+  }
+
+bool isInClauseVariableList(SgInitializedName* var, SgOmpClauseBodyStatement * clause_stmt, const VariantVector& vvt)
+  {
+      bool debug = false;
+
+    SgInitializedNamePtrList var_list = collectClauseVariables (clause_stmt, vvt);
+
+    if (debug) {
+        std::cout << "looking for " << var->get_name().getString() 
+                  << " clause variables are: ";
+    }
+
+    for (SgInitializedNamePtrList::const_iterator j = var_list.begin();
+         j != var_list.end(); ++j) {
+        SgInitializedName* var = *j;
+        if (debug) std::cout << var->get_name().getString() << ", ";
+    }
+
+    if (find(var_list.begin(), var_list.end(), var) != var_list.end() ) {
+        if (debug) std::cout << " FOUND IT" << std::endl;  
+        return true;
+    } else {
+        if (debug) std::cout << " not found" << std::endl;  
+      return false;
+    }
+  }
+
+   //! Return a reduction variable's reduction operation type
+   SgOmpClause::omp_reduction_operator_enum getReductionOperationType(SgInitializedName* init_name, SgOmpClauseBodyStatement* clause_stmt)
+   {
+     SgOmpClause::omp_reduction_operator_enum result = SgOmpClause::e_omp_reduction_unknown;
+     bool found = false;
+     ROSE_ASSERT(init_name != NULL);
+     ROSE_ASSERT(clause_stmt!= NULL);
+     Rose_STL_Container<SgOmpClause*> p_clause =
+       NodeQuery::queryNodeList<SgOmpClause>(clause_stmt->get_clauses(),V_SgOmpReductionClause);
+     ROSE_ASSERT(p_clause.size() >0); // must be have at least reduction clause
+
+     for (size_t i =0; i< p_clause.size(); i++) // can have multiple reduction clauses of different reduction operations
+     {
+       SgOmpReductionClause* r_clause = isSgOmpReductionClause(p_clause[i]);
+       ROSE_ASSERT(r_clause != NULL );
+       SgVarRefExpPtrList refs = isSgOmpVariablesClause(r_clause)->get_variables();
+       SgInitializedNamePtrList var_list ; //= isSgOmpVariablesClause(r_clause)->get_variables();
+       for (size_t j=0; j< refs.size(); j++)
+         var_list.push_back (refs[j]->get_symbol()->get_declaration());
+       SgInitializedNamePtrList::const_iterator iter = find (var_list.begin(), var_list.end(), init_name);
+       if (iter != var_list.end())
+       {
+         result = r_clause->get_operation();
+         found = true;
+         break;
+       }
+     }
+     // Must have a hit
+     ROSE_ASSERT(found == true);
+     return result;
+   }  
+
+   //! Create an initial value according to reduction operator type
+   SgExpression* createInitialValueExp(SgOmpClause::omp_reduction_operator_enum r_operator)
+   {
+     SgExpression * result = NULL;
+     switch (r_operator )
+     {
+       // 0: + - ! ^ ||  ior ieor
+       case SgOmpClause::e_omp_reduction_plus:
+       case SgOmpClause::e_omp_reduction_minus:
+       case SgOmpClause::e_omp_reduction_bitor:
+       case SgOmpClause::e_omp_reduction_bitxor:
+       case SgOmpClause::e_omp_reduction_or:
+       case SgOmpClause::e_omp_reduction_ior:
+       case SgOmpClause::e_omp_reduction_ieor:
+          result = buildIntVal(0);
+          break;
+       // 1: * &&
+       case SgOmpClause::e_omp_reduction_mul:
+       case SgOmpClause::e_omp_reduction_bitand:
+          result = buildIntVal(1);
+          break;
+        // TODO
+       case SgOmpClause::e_omp_reduction_logand:
+       case SgOmpClause::e_omp_reduction_logor:
+       case SgOmpClause::e_omp_reduction_and:
+       case SgOmpClause::e_omp_reduction_eqv:
+       case SgOmpClause::e_omp_reduction_neqv:
+       case SgOmpClause::e_omp_reduction_max:
+       case SgOmpClause::e_omp_reduction_min:
+       case SgOmpClause::e_omp_reduction_iand:
+          
+       case SgOmpClause::e_omp_reduction_unknown:
+       case SgOmpClause::e_omp_reduction_last:
+       default:
+         cerr<<"Illegal or unhandled reduction operator kind: "<< r_operator <<endl;
+         ROSE_ASSERT(false);
+     }
+
+     return result; 
+   }
+
+  //! Check if a variable is in a variable list of a given clause type
+  bool isInClauseVariableList(SgInitializedName* var, SgOmpClauseBodyStatement * clause_stmt, const VariantT& vt)
+  {
+    return isInClauseVariableList(var, clause_stmt, VariantVector(vt));
+  }
+
+ // lastprivate can be used with loop constructs or sections.
+   /* if (i is the last iteration)
+   *   *shared_i_p = local_i
+   *
+   * The judge of last iteration is based on the iteration space increment direction and loop stop conditions
+   * Incremental loops
+   *      < upper:   last iteration ==> i >= upper
+   *      <=     :                      i> upper
+   * Decremental loops     
+   *      > upper:   last iteration ==> i <= upper
+   *      >=     :                      i < upper
+   * AST: Orphaned worksharing OmpStatement is SgOmpForStatement->get_body() is SgForStatement
+   *     
+   *  We use bottom up traversal, the inner omp for loop has already been translated, so we have to get the original upper bound via parameter
+   *
+   *  Another tricky case is that when some threads don't get any iterations to work on, the initial _p_index may still trigger the lastprivate 's 
+   *     if (_p_index>orig_bound) statement
+   *  We add a condition to test if the thread really worked on at least on iteration before compare the _p_index and the original boundary
+   *     if (_p_index != p_lower_ && _p_index>orig_bound) 
+   *       statement
+   *
+   *  Parameters:
+   *    ompStmt: the OpenMP statement node with a lastprivate clause
+   *    end_stmt_list: a list of statement which will be append to the end of bb1. The generated if-stmt will be added to the end of this list
+   *    bb1: the basic block affected by the lastprivate clause
+   *    orig_var: the initialized name for the original lastprivate variable. Necessary since transOmpLoop will replace loop index with changed one
+   *    local_decl: the variable declaration for the local copy of the lastprivate variable
+   *    orig_loop_upper: the worksharing construct's upper limit: 
+   *       for-loop: the loop upper value, 
+   *       sections: the section count - 1
+   *
+   * */
+static void insertOmpLastprivateCopyBackStmts(SgStatement* ompStmt, vector <SgStatement* >& end_stmt_list,  SgBasicBlock* bb1, 
+                              SgInitializedName* orig_var, SgVariableDeclaration* local_decl, SgExpression* orig_loop_upper)
+{
+  SgStatement* save_stmt = NULL;
+  if (isSgOmpForStatement(ompStmt))
+  {
+    ROSE_ASSERT (orig_loop_upper != NULL);
+    Rose_STL_Container <SgNode*> loops = NodeQuery::querySubTree (bb1, V_SgForStatement);
+    ROSE_ASSERT (loops.size() != 0); // there must be 1 for loop under SgOmpForStatement
+    SgForStatement* top_loop = isSgForStatement(loops[0]);
+    ROSE_ASSERT (top_loop != NULL);
+    //Get essential loop information
+    SgInitializedName* loop_index;
+    SgExpression* loop_lower, *loop_upper, *loop_step;
+    SgStatement* loop_body;
+    bool  isIncremental;
+    bool isInclusiveBound;
+    bool isCanonical = SageInterface::isCanonicalForLoop (top_loop, &loop_index, & loop_lower, & loop_upper, & loop_step, &loop_body, & isIncremental, & isInclusiveBound);
+    ROSE_ASSERT (isCanonical == true);
+    SgExpression* if_cond= NULL;
+    SgStatement* if_cond_stmt = NULL;
+    // we need the original upper bound!!
+    if (isIncremental)
+    {
+      if (isInclusiveBound) // <= --> >
+      {
+        if_cond= buildGreaterThanOp(buildVarRefExp(loop_index, bb1), copyExpression(orig_loop_upper));
+      }
+      else // < --> >=
+      {
+        if_cond= buildGreaterOrEqualOp(buildVarRefExp(loop_index, bb1), copyExpression(orig_loop_upper));
+      }
+    }
+    else
+    { // decremental loop
+      if (isInclusiveBound) // >= --> <
+      {
+        if_cond= buildLessThanOp(buildVarRefExp(loop_index, bb1), copyExpression(orig_loop_upper));
+      }
+      else // > --> <=
+      {
+        if_cond= buildLessOrEqualOp(buildVarRefExp(loop_index, bb1), copyExpression(orig_loop_upper));
+      }
+    }
+    // Add (_p_index != _p_lower) as another condition, making sure the current thread really worked on at least one iteration
+    // Otherwise some thread which does not run any iteration may have a big initial _p_index and trigger the if statement's condition
+    if_cond_stmt = buildExprStatement(buildAndOp(buildNotEqualOp(buildVarRefExp(loop_index, bb1), copyExpression(loop_lower)), if_cond)) ;
+    SgStatement* true_body = buildAssignStatement(buildVarRefExp(orig_var, bb1), buildVarRefExp(local_decl));
+    save_stmt = buildIfStmt(if_cond_stmt, true_body, NULL);
+  }
+  else if (isSgOmpSectionsStatement(ompStmt))
+  {
+    ROSE_ASSERT (orig_loop_upper != NULL);
+    Rose_STL_Container <SgNode*> while_stmts = NodeQuery::querySubTree (bb1, V_SgWhileStmt);
+    ROSE_ASSERT  (while_stmts.size()!=0);
+    SgWhileStmt * top_while_stmt = isSgWhileStmt(while_stmts[0]);
+    ROSE_ASSERT(top_while_stmt != NULL);
+    //Get the section id variable from while-stmt  while(section_id >= 0) {}
+    // SgWhileStmt -> SgExprStatement -> SgGreaterOrEqualOp-> SgVarRefExp
+    SgExprStatement* exp_stmt = isSgExprStatement(top_while_stmt->get_condition());
+    ROSE_ASSERT (exp_stmt != NULL);
+    SgGreaterOrEqualOp* ge_op = isSgGreaterOrEqualOp(exp_stmt->get_expression());
+    ROSE_ASSERT (ge_op != NULL);
+    SgVarRefExp* var_ref = isSgVarRefExp(ge_op->get_lhs_operand()); 
+    ROSE_ASSERT (var_ref != NULL);
+    string switch_index_name = (var_ref->get_symbol()->get_name()).getString();
+    SgExpression* if_cond= NULL;
+    SgStatement* if_cond_stmt = NULL;
+    if_cond= buildEqualityOp(buildVarRefExp((switch_index_name+"_save"), bb1), orig_loop_upper);// no need copy orig_loop_upper here
+    if_cond_stmt = buildExprStatement(if_cond) ;
+    SgStatement* true_body = buildAssignStatement(buildVarRefExp(orig_var, bb1), buildVarRefExp(local_decl));
+    save_stmt = buildIfStmt(if_cond_stmt, true_body, NULL);
+  }
+  else  
+  {
+    cerr<<"Illegal SgOmpxx for lastprivate variable: \nOmpStatement is:"<< ompStmt->class_name()<<endl;
+    cerr<<"lastprivate variable is:"<<orig_var->get_name().getString()<<endl;
+    ROSE_ASSERT (false);
+  }
+  end_stmt_list.push_back(save_stmt);
+
+}
+
+  //!Generate copy-back statements for reduction variables
+  // end_stmt_list: the statement lists to be appended
+  // bb1: the affected code block by the reduction clause
+  // orig_var: the reduction variable's original copy
+  // local_decl: the local copy of the reduction variable
+  // Two ways to do the reduction operation: 
+  //1. builtin function TODO
+  //    __sync_fetch_and_add_4(&shared, (unsigned int)local);
+  //2. using atomic runtime call: 
+  //    GOMP_atomic_start ();
+  //    shared = shared op local;
+  //    GOMP_atomic_end ();
+  // We use the 2nd method only for now for simplicity and portability
+static void insertOmpReductionCopyBackStmts (SgOmpClause::omp_reduction_operator_enum r_operator, vector <SgStatement* >& end_stmt_list,  SgBasicBlock* bb1, SgInitializedName* orig_var, SgVariableDeclaration* local_decl)
+{
+
+#ifdef ENABLE_XOMP
+  SgExprStatement* atomic_start_stmt = buildFunctionCallStmt("XOMP_atomic_start", buildVoidType(), NULL, bb1); 
+#else  
+  SgExprStatement* atomic_start_stmt = buildFunctionCallStmt("GOMP_atomic_start", buildVoidType(), NULL, bb1); 
+#endif  
+  end_stmt_list.push_back(atomic_start_stmt);   
+  SgExpression* r_exp = NULL;
+  switch (r_operator) 
+  {
+    case SgOmpClause::e_omp_reduction_plus:
+      r_exp = buildAddOp(buildVarRefExp(orig_var, bb1), buildVarRefExp(local_decl)); 
+      break;
+    case SgOmpClause::e_omp_reduction_mul:
+      r_exp = buildMultiplyOp(buildVarRefExp(orig_var, bb1), buildVarRefExp(local_decl)); 
+      break;
+    case SgOmpClause::e_omp_reduction_minus:
+      r_exp = buildSubtractOp(buildVarRefExp(orig_var, bb1), buildVarRefExp(local_decl)); 
+      break;
+    case SgOmpClause::e_omp_reduction_bitand:
+      r_exp = buildBitAndOp(buildVarRefExp(orig_var, bb1), buildVarRefExp(local_decl)); 
+      break;
+    case SgOmpClause::e_omp_reduction_bitor:
+      r_exp = buildBitOrOp(buildVarRefExp(orig_var, bb1), buildVarRefExp(local_decl)); 
+      break;
+    case SgOmpClause::e_omp_reduction_bitxor: 
+      r_exp = buildBitXorOp(buildVarRefExp(orig_var, bb1), buildVarRefExp(local_decl)); 
+      break;
+    case SgOmpClause::e_omp_reduction_logand:
+      r_exp = buildAndOp(buildVarRefExp(orig_var, bb1), buildVarRefExp(local_decl)); 
+      break;
+    case SgOmpClause::e_omp_reduction_logor:
+      r_exp = buildOrOp(buildVarRefExp(orig_var, bb1), buildVarRefExp(local_decl)); 
+      break;
+      // TODO Fortran operators.   
+    case SgOmpClause::e_omp_reduction_and: // Fortran .and.
+    case SgOmpClause::e_omp_reduction_or: // Fortran .or.
+    case SgOmpClause::e_omp_reduction_eqv: 
+    case SgOmpClause::e_omp_reduction_neqv:
+    case SgOmpClause::e_omp_reduction_max:
+    case SgOmpClause::e_omp_reduction_min:
+    case SgOmpClause::e_omp_reduction_iand:
+    case SgOmpClause::e_omp_reduction_ior:
+    case SgOmpClause::e_omp_reduction_ieor:
+    case SgOmpClause::e_omp_reduction_unknown: 
+    case SgOmpClause::e_omp_reduction_last:
+    default:
+        cerr<<"Illegal or unhandled reduction operator type:"<< r_operator<<endl;
+    }
+    SgStatement* reduction_stmt = buildAssignStatement(buildVarRefExp(orig_var, bb1), r_exp);
+    end_stmt_list.push_back(reduction_stmt);   
+#ifdef ENABLE_XOMP
+    SgExprStatement* atomic_end_stmt = buildFunctionCallStmt("XOMP_atomic_end", buildVoidType(), NULL, bb1);  
+#else    
+    SgExprStatement* atomic_end_stmt = buildFunctionCallStmt("GOMP_atomic_end", buildVoidType(), NULL, bb1);  
+#endif    
+    end_stmt_list.push_back(atomic_end_stmt);   
+  }
+
+//! Liao 2/12/2013. Insert the thread-block inner level reduction statement into the end of the end_stmt_list
+// e.g.  xomp_inner_block_reduction_float (local_error, per_block_error, XOMP_REDUCTION_PLUS);
+static void insertInnerThreadBlockReduction(SgOmpClause::omp_reduction_operator_enum r_operator, vector <SgStatement* >& end_stmt_list,  SgBasicBlock* bb1
+, SgInitializedName* orig_var, SgVariableDeclaration* local_decl, SgVariableDeclaration* per_block_decl)
+{
+   ROSE_ASSERT (bb1 && orig_var && local_decl && per_block_decl);  
+   // the integer value representing different reduction operations, defined within libxomp.h for accelerator model
+   // TODO refactor the code to have a function converting operand types to integers
+  int op_value = -1;
+  switch (r_operator)
+  {
+    case SgOmpClause::e_omp_reduction_plus:
+      op_value = 6;
+      break;
+    case SgOmpClause::e_omp_reduction_minus:
+      op_value = 7;
+      break;
+    case SgOmpClause::e_omp_reduction_mul:
+      op_value = 8;
+      break;
+    case SgOmpClause::e_omp_reduction_bitand:
+      op_value = 9;
+      break;
+    case SgOmpClause::e_omp_reduction_bitor:
+      op_value = 10;
+      break;
+    case SgOmpClause::e_omp_reduction_bitxor:
+      op_value = 11;
+      break;
+    case SgOmpClause::e_omp_reduction_logand:
+      op_value = 12;
+      break;
+    case SgOmpClause::e_omp_reduction_logor:
+      op_value = 13;
+      break;
+      //TODO: more operation types
+    case SgOmpClause::e_omp_reduction_and: // Fortran .and.
+    case SgOmpClause::e_omp_reduction_or: // Fortran .or.
+    case SgOmpClause::e_omp_reduction_eqv:
+    case SgOmpClause::e_omp_reduction_neqv:
+    case SgOmpClause::e_omp_reduction_max:
+    case SgOmpClause::e_omp_reduction_min:
+    case SgOmpClause::e_omp_reduction_iand:
+    case SgOmpClause::e_omp_reduction_ior:
+    case SgOmpClause::e_omp_reduction_ieor:
+    case SgOmpClause::e_omp_reduction_unknown:
+    case SgOmpClause::e_omp_reduction_last:
+    default:
+      cerr<<"Error. insertThreadBlockReduction() in omp_lowering.cpp: Illegal or unhandled reduction operator type:"<< r_operator<<endl;
+  }
+
+  SgVariableSymbol* var_sym = getFirstVarSym(per_block_decl);
+  ROSE_ASSERT (var_sym != NULL);
+  SgPointerType* var_type = isSgPointerType(var_sym->get_type());
+  ROSE_ASSERT (var_type != NULL);
+  //TODO: this could be risky. It is better to have our own conversion function to have full control over it.
+  string type_str = var_type->get_base_type()->unparseToString();
+  per_block_reduction_map[var_sym] = op_value; // save the per block symbol and its corresponding reduction integer value defined in the libxomp.h 
+  SgIntVal* reduction_op = buildIntVal (op_value);
+  SgExprListExp * parameter_list = buildExprListExp (buildVarRefExp(local_decl), buildVarRefExp(per_block_decl), reduction_op);
+  SgStatement* func_call_stmt = buildFunctionCallStmt("xomp_inner_block_reduction_"+type_str, buildVoidType(),parameter_list ,bb1);
+  end_stmt_list.push_back(func_call_stmt);
+}
+   //TODO move to sageInterface advanced transformation ???
+   //! Generate element-by-element assignment from a right-hand array to left_hand array variable. 
+   //
+   //e.g.  for int a[M][N], b[M][N],  a=b is implemented as follows:
+   //
+   //  int element_count = ...;
+   //  int *a_ap = (int *)a;
+   //  int *b_ap = (int *)b;
+   //  int i;
+   //  for (i=0;i<element_count; i++) 
+   //    *(b_ap+i) = *(a_ap+i);
+   //
+   static  SgBasicBlock* generateArrayAssignmentStatements
+   (SgInitializedName* left_operand, SgInitializedName* right_operand, SgScopeStatement* scope)
+   {
+     // parameter validation
+      ROSE_ASSERT(scope != NULL); // enforce top-down AST construction here for simplicity
+      ROSE_ASSERT (left_operand != NULL);
+      ROSE_ASSERT (right_operand != NULL);
+
+      SgType* left_type = left_operand->get_type();
+      SgType* right_type = right_operand->get_type();
+      SgArrayType* left_array_type = isSgArrayType(left_type);
+      SgArrayType* right_array_type = isSgArrayType(right_type);
+
+      ROSE_ASSERT (left_array_type != NULL);
+      ROSE_ASSERT (right_array_type != NULL);
+      // make sure two array are compatible: same dimension, bounds, and element types, etc.
+      ROSE_ASSERT (getElementType(left_array_type) == getElementType(right_array_type));
+      int dim_count = getDimensionCount(left_array_type);
+      ROSE_ASSERT (dim_count == getDimensionCount(right_array_type));
+      int element_count = getArrayElementCount (left_array_type); 
+      ROSE_ASSERT (element_count == (int) getArrayElementCount (right_array_type));
+
+     SgBasicBlock* bb = buildBasicBlock();
+       // front_stmt_list.push_back() will handle this later on.
+       // Keep this will cause duplicated appendStatement()
+      // appendStatement(bb, scope);
+     
+         // int *a_ap = (int*) a;
+      string right_name = right_operand->get_name().getString(); 
+      string right_name_p = right_name+"_ap"; // array pointer (ap)
+      SgType* elementPointerType = buildPointerType(buildIntType());
+      SgAssignInitializer * initor = buildAssignInitializer
+             (buildCastExp(buildVarRefExp(right_operand,scope),elementPointerType),elementPointerType);
+      SgVariableDeclaration* decl_right = buildVariableDeclaration (right_name_p, elementPointerType, initor, bb );
+     appendStatement(decl_right, bb);
+      
+      // int *b_ap = (int*) b;
+      string left_name = left_operand->get_name().getString(); 
+      string left_name_p = left_name+"_ap";
+      SgAssignInitializer * initor2 = buildAssignInitializer
+             (buildCastExp(buildVarRefExp(left_operand,scope),elementPointerType),elementPointerType);
+      SgVariableDeclaration* decl_left = buildVariableDeclaration (left_name_p, elementPointerType, initor2, bb );
+     appendStatement(decl_left, bb);
+   
+     // int i;
+     SgVariableDeclaration* decl_i = buildVariableDeclaration("_p_i", buildIntType(), NULL, bb);
+     appendStatement(decl_i, bb);
+
+   //  for (i=0;i<element_count; i++) 
+   //    *(b_ap+i) = *(a_ap+i);
+    SgStatement* init_stmt = buildAssignStatement(buildVarRefExp(decl_i), buildIntVal(0));
+    SgStatement* test_stmt = buildExprStatement(buildLessThanOp(buildVarRefExp(decl_i),buildIntVal(element_count)));
+    SgExpression* incr_exp = buildPlusPlusOp(buildVarRefExp(decl_i),SgUnaryOp::postfix);
+    SgStatement* loop_body = buildAssignStatement(
+         buildPointerDerefExp(buildAddOp(buildVarRefExp(decl_left),buildVarRefExp(decl_i))),
+         buildPointerDerefExp(buildAddOp(buildVarRefExp(decl_right),buildVarRefExp(decl_i)))
+          );
+    SgForStatement* for_stmt = buildForStatement(init_stmt, test_stmt, incr_exp, loop_body);
+     appendStatement(for_stmt, bb);
+
+     return bb;
+   }
+
+  //SgBasicBlock * getEnclosingRegionOrFuncDefinition(SgBasicBlock *orig_scope)
+  SgBasicBlock * getEnclosingRegionOrFuncDefinition(SgNode *orig_scope)
+  {
+    ROSE_ASSERT (SageInterface::is_Fortran_language() == true);
+    // find the right scope (target body) to insert the declaration, start from the original scope
+    SgBasicBlock* t_body = NULL;
+  
+    //find enclosing parallel region's body
+    SgOmpParallelStatement * omp_stmt = isSgOmpParallelStatement(getEnclosingNode<SgOmpParallelStatement>(orig_scope));
+    if (omp_stmt)
+    {
+      SgBasicBlock * omp_body = isSgBasicBlock(omp_stmt->get_body());
+      ROSE_ASSERT(omp_body != NULL);
+      t_body = omp_body;
+    }
+    else
+    {
+      // Find enclosing function body
+      SgFunctionDefinition* func_def = getEnclosingProcedure (orig_scope);
+      ROSE_ASSERT (func_def != NULL);
+      SgBasicBlock * f_body = func_def->get_body();
+      ROSE_ASSERT(f_body!= NULL);
+      t_body = f_body;
+    }
+    ROSE_ASSERT (t_body != NULL);
+    return t_body;
+  }
+
+//! This is a highly specialized operation which can find the right place to insert a Fortran variable declaration
+//  during OpenMP lowering.
+//
+//  The reasons are: 
+//    1)Fortran (at least F77) requires declaration statements to be consecutive within an enclosing function definition.
+//    The C99-style generation of 'int loop_index' within a SgBasicBlock in the middle of some executable statement is illegal
+//     for Fortran. We have to find the enclosing function body, located the declaration sequence, and add the new declaration 
+//     after it. 
+//
+//    2) When translating OpenMP constructs within a parallel region, the declaration (such as those for private variables of the construct ) 
+//       should be inserted into the declaration part of the body of the parallel region, which will become function body of the outlined
+//       function when translating the region later on.
+//       Insert the declaration to the current enclosing function definition is not correct. 
+//
+// Liao 1/12/2011
+  SgVariableDeclaration * buildAndInsertDeclarationForOmp(const std::string &name, SgType *type, SgInitializer *varInit, SgBasicBlock *orig_scope)
+{
+  ROSE_ASSERT (SageInterface::is_Fortran_language() == true);
+  SgVariableDeclaration * result = NULL;
+
+  // find the right scope (target body) to insert the declaration, start from the original scope
+
+  SgBasicBlock* t_body = NULL; 
+
+#if 0
+  //find enclosing parallel region's body
+  SgOmpParallelStatement * omp_stmt = isSgOmpParallelStatement(getEnclosingNode<SgOmpParallelStatement>(orig_scope));
+  if (omp_stmt)
+  {
+    SgBasicBlock * omp_body = isSgBasicBlock(omp_stmt->get_body());
+    ROSE_ASSERT(omp_body != NULL);
+    t_body = omp_body; 
+  }
+  else
+  {
+    // Find enclosing function body
+    SgFunctionDefinition* func_def = getEnclosingProcedure (orig_scope);
+    ROSE_ASSERT (func_def != NULL);
+    SgBasicBlock * f_body = func_def->get_body();
+    ROSE_ASSERT(f_body!= NULL);
+    t_body = f_body; 
+  }
+  ROSE_ASSERT (t_body != NULL);  
+#else
+   t_body = getEnclosingRegionOrFuncDefinition(orig_scope);
+#endif
+  // Build the required variable declaration
+  result = buildVariableDeclaration (name, type, varInit, t_body);
+
+  // Insert to be the declaration after current declaration sequence, if any
+  insertStatementAfterLastDeclaration (result, t_body);
+
+  ROSE_ASSERT (result != NULL);
+  return result;
+}
+    //! Translate clauses with variable lists, such as private, firstprivate, lastprivate, reduction, etc.
+    //bb1 is the affected code block by the clause.
+    //Command steps are: insert local declarations for the variables:(all)
+    //                   initialize the local declaration:(firstprivate, reduction)
+    //                   variable substitution for the variables:(all)
+    //                   save local copy back to its global one:(reduction, lastprivate)
+    // Note that a variable could be both firstprivate and lastprivate                  
+    // Parameters:
+    //     ompStmt: the OpenMP statement node with variable clauses
+    //     bb1: the translation-generated basic block to implement ompStmt
+    //     orig_loop_upper: 
+    //       if ompStmt is loop construct, pass the original loop upper bound
+    //       if ompStmt is omp sections, pass the section count - 1
+    // This function is later extended to support OpenMP accelerator model. In this model,
+    //    We have no concept of firstprivate or lastprivate
+    //    reduction is implemented using a two-level reduction algorithm
+    void transOmpVariables(SgStatement* ompStmt, SgBasicBlock* bb1, SgExpression * orig_loop_upper/*= NULL*/, bool isAcceleratorModel /*= false*/)
+    {
+      ROSE_ASSERT( ompStmt != NULL);
+      ROSE_ASSERT( bb1 != NULL);
+      SgOmpClauseBodyStatement* clause_stmt = isSgOmpClauseBodyStatement(ompStmt);
+      ROSE_ASSERT( clause_stmt!= NULL);
+
+      // collect variables 
+     SgInitializedNamePtrList var_list = collectAllClauseVariables(clause_stmt);
+     // Only keep the unique ones
+     sort (var_list.begin(), var_list.end());;
+     SgInitializedNamePtrList:: iterator new_end = unique (var_list.begin(), var_list.end());
+     var_list.erase(new_end, var_list.end());
+     VariableSymbolMap_t var_map; 
+     ASTtools::VarSymSet_t var_set;
+
+     vector <SgStatement* > front_stmt_list, end_stmt_list, front_init_list;  
+    
+// this is called by both transOmpTargetParallel and transOmpTargetLoop, we should move this to the correct caller place 
+//      per_block_declarations.clear(); // must reset to empty or wrong reference to stale content generated previously
+     for (size_t i=0; i< var_list.size(); i++)
+     {
+       SgInitializedName* orig_var = var_list[i];
+       ROSE_ASSERT(orig_var != NULL);
+       string orig_name = orig_var->get_name().getString();
+       SgType* orig_type =  orig_var->get_type();
+       SgVariableSymbol* orig_symbol = isSgVariableSymbol(orig_var->get_symbol_from_symbol_table());
+       ROSE_ASSERT(orig_symbol!= NULL);
+
+       VariantVector vvt (V_SgOmpPrivateClause);
+       vvt.push_back(V_SgOmpReductionClause);
+
+      //TODO: No such concept of firstprivate and lastprivate in accelerator model??
+       if (!isAcceleratorModel) // we actually already has enable_accelerator, but it is too global for handling both CPU and GPU translation
+       {
+         vvt.push_back(V_SgOmpFirstprivateClause);
+         vvt.push_back(V_SgOmpLastprivateClause);
+       }
+   
+      // a local private copy
+      SgVariableDeclaration* local_decl = NULL;
+      SgOmpClause::omp_reduction_operator_enum r_operator = SgOmpClause::e_omp_reduction_unknown  ;
+      bool isReductionVar = isInClauseVariableList(orig_var, clause_stmt,V_SgOmpReductionClause);
+
+      // step 1. Insert local declaration for private, firstprivate, lastprivate and reduction
+      // Sara, 5/31/2013: if variable is in Function Scope ( a parameter ) and array, 
+      // we don't want a private copy, since the only thing private is the pointer, not the pointed data
+      // We had a variable passed as private that has to be used as shared
+      // We create a pointer to the variable and replace all the occurrences of the variable by the pointer
+      // Example:
+      // source code: 
+      // void outlining( int M[10][10] ) {
+      //   #pragma omp task firstprivate( M )
+      //   M[0][0] = 4;
+      // }
+      // outlined parameters struct
+      // struct OUT__17__7038___data {
+      //   int (*M)[10UL];
+      // };
+      // outlined function:
+      // static void OUT__17__7038__(void *__out_argv) {
+      //   int (**M)[10UL] = (int (**)[10UL])(&(((struct OUT__17__7038___data *)__out_argv) -> M));
+      //   (*M)[0][0] = 4;
+      // }
+      if (isInClauseVariableList(orig_var, clause_stmt, vvt))
+      {
+        if( !(isSgArrayType(orig_type) && isSgFunctionDefinition (orig_var->get_scope ())) )
+        {
+         SgInitializer * init = NULL;
+         // use copy constructor for firstprivate on C++ class object variables
+         // For simplicity, we handle C and C++ scalar variables the same way
+         //
+         // But here is one exception: an array type firstprivate variable should
+         // be initialized element-by-element
+         // Liao, 4/12/2010
+         if (isInClauseVariableList(orig_var, clause_stmt,V_SgOmpFirstprivateClause) && !isSgArrayType(orig_type))
+         {
+           init = buildAssignInitializer(buildVarRefExp(orig_var, bb1));
+         }
+         string private_name = "_p_"+orig_name;
+
+         if (SageInterface::is_Fortran_language() )
+         {
+           // leading _ is not allowed in Fortran
+           private_name = "i_"+orig_name;
+           nCounter ++; // Fortran does not have basic block as a scope at source level
+           // I have to generated all declarations at the same flat level under function definitions
+           // So a name counter is needed to avoid name collision
+           private_name = private_name + "_" + StringUtility::numberToString(nCounter);
+ 
+           // Special handling for variable declarations in Fortran
+           local_decl = buildAndInsertDeclarationForOmp (private_name, orig_type, init, bb1);
+          }
+          else
+          {
+            private_name = "_p_"+orig_name;
+            // HT does not want the initializer
+            local_decl = buildVariableDeclaration(private_name, orig_type, init, bb1);
+            //local_decl = buildVariableDeclaration(private_name, orig_type, 0, bb1);
+           //ROSE_ASSERT (getFirst);
+           //   prependStatement(local_decl, bb1);
+           front_stmt_list.push_back(local_decl);   
+         }
+        // record the map from old to new symbol
+        var_map.insert( VariableSymbolMap_t::value_type( orig_symbol, getFirstVarSym(local_decl)) ); 
+       }
+        else
+        {
+            var_set.insert(orig_symbol);
+        }
+      }
+      // step 2. Initialize the local copy for array-type firstprivate variables TODO copyin, copyprivate
+#if 1
+      if (isInClauseVariableList(orig_var, clause_stmt,V_SgOmpFirstprivateClause) && 
+          isSgArrayType(orig_type) && !isSgFunctionDefinition (orig_var->get_scope ()))
+      {
+        // SgExprStatement* init_stmt = buildAssignStatement(buildVarRefExp(local_decl), buildVarRefExp(orig_var, bb1));
+        SgInitializedName* leftArray = getFirstInitializedName(local_decl); 
+        SgBasicBlock* arrayAssign = generateArrayAssignmentStatements (leftArray, orig_var, bb1); 
+       front_stmt_list.push_back(arrayAssign);   
+      } 
+#endif    
+      if (isReductionVar) // create initial value assignment for the local reduction variable
+      {
+        r_operator = getReductionOperationType(orig_var, clause_stmt);
+        SgExprStatement* init_stmt = buildAssignStatement(buildVarRefExp(local_decl), createInitialValueExp(r_operator));
+        if (SageInterface::is_Fortran_language() )
+        {
+          // Fortran initialization statements  cannot be interleaved with declaration statements.
+          // We save them here and insert them after all declaration statements are inserted.
+          front_init_list.push_back(init_stmt);
+        }
+        else
+        {
+          front_stmt_list.push_back(init_stmt);   
+        }
+     }
+
+      // Liao, 2/12/2013. For an omp for loop within "omp target". We translate its reduction variable by using 
+      // a two-level reduction method: thread-block level (within kernel) and beyond-block level (done on CPU side).
+      // So we have to insert a pointer to the array of per-block reduction results right before its enclosing "omp target" directive
+      // The insertion point is decided so that the outliner invoked by transOmpTargetParallel() can later catch this newly introduced variable
+      // and handle it in the parameter list properly. 
+      //
+      // e.g. REAL* per_block_results = (REAL *)xomp_deviceMalloc (numBlocks.x* sizeof(REAL));
+       SgVariableDeclaration* per_block_decl = NULL; 
+      if (isReductionVar && isAcceleratorModel)
+      {
+        SgOmpParallelStatement* enclosing_omp_parallel = getEnclosingNode<SgOmpParallelStatement> (ompStmt);
+        ROSE_ASSERT (enclosing_omp_parallel!= NULL);
+        //SgScopeStatement* scope_for_insertion = enclosing_omp_target->get_scope();
+        SgScopeStatement* scope_for_insertion = isSgScopeStatement(enclosing_omp_parallel->get_scope());
+        ROSE_ASSERT (scope_for_insertion != NULL);
+        SgExprListExp* parameter_list = buildExprListExp(buildMultiplyOp( buildVarRefExp("_num_blocks_", scope_for_insertion), buildSizeOfOp(orig_type) ));
+        SgExpression* init_exp = buildCastExp(buildFunctionCallExp(SgName("xomp_deviceMalloc"), buildPointerType(buildVoidType()), parameter_list, scope_for_insertion),  
+                                              buildPointerType(orig_type));
+       // the prefix of "_dev_per_block_" is important for later handling when calling outliner: add them into the parameter list
+        per_block_decl = buildVariableDeclaration ("_dev_per_block_"+orig_name, buildPointerType(orig_type), buildAssignInitializer(init_exp), scope_for_insertion);
+        // this statement refers to _num_blocks_, which will be declared later on when translating "omp parallel" enclosed in "omp target"
+        // so we insert it  later when the kernel launch statement is inserted. 
+        // insertStatementAfter(enclosing_omp_parallel, per_block_decl);
+        per_block_declarations.push_back(per_block_decl);
+        // store all reduction variables at the loop level, they will be used later when translating the enclosing "omp target" to help decide on the variables being passed
+      }
+
+      // step 3. Save the value back for lastprivate and reduction
+      if (isInClauseVariableList(orig_var, clause_stmt,V_SgOmpLastprivateClause))
+      {
+        insertOmpLastprivateCopyBackStmts (ompStmt, end_stmt_list, bb1, orig_var, local_decl, orig_loop_upper);
+      } else if (isReductionVar)
+      {
+        // two-level reduction is used for accelerator model 
+        if (isAcceleratorModel)
+          insertInnerThreadBlockReduction (r_operator, end_stmt_list, bb1, orig_var, local_decl, per_block_decl); 
+        else 
+          insertOmpReductionCopyBackStmts(r_operator, end_stmt_list, bb1, orig_var, local_decl);
+      }
+
+     } // end for (each variable)
+
+   // step 4. Variable replacement for all original bb1
+   replaceVariableReferences(bb1, var_map); 
+   replaceVariablesWithPointerDereference(bb1, var_set); // Variables that must be replaced by a pointer to the variable
+
+   // We delay the insertion of declaration, initialization , and save-back statements until variable replacement is done
+   // in order to avoid replacing variables of these newly generated statements.
+   prependStatementList(front_stmt_list, bb1); 
+   // Fortran: add initialization statements after all front statements are inserted
+  if (SageInterface::is_Fortran_language() )
+  {
+    SgBasicBlock * target_bb = getEnclosingRegionOrFuncDefinition (bb1);
+    insertStatementAfterLastDeclaration (front_init_list, target_bb);
+  }
+   else
+   {
+     ROSE_ASSERT (front_init_list.size() ==0);
+   }
+   appendStatementList(end_stmt_list, bb1); 
+#if 1
+   // Liao 1/7/2010 , add assertion here, useful when generating outlined functions by moving statements to a function body
+   SgStatementPtrList & srcStmts = bb1->get_statements(); 
+   for (SgStatementPtrList::iterator i = srcStmts.begin(); i != srcStmts.end(); i++)
+   {
+     SgDeclarationStatement* declaration = isSgDeclarationStatement(*i);
+     if (declaration != NULL)
+       switch(declaration->variantT())
+       {
+         case V_SgVariableDeclaration:
+           {
+             // Reset the scopes on any SgInitializedName objects.
+             SgVariableDeclaration* varDecl = isSgVariableDeclaration(declaration);
+             SgInitializedNamePtrList & l = varDecl->get_variables();
+             for (SgInitializedNamePtrList::iterator i = l.begin(); i != l.end(); i++)
+             {
+               // This might be an issue for extern variable declaration that have a scope
+               // in a separate namespace of a static class member defined external to
+               // its class, etc. I don't want to worry about those cases right now.
+               ROSE_ASSERT((*i)->get_scope() == bb1);
+             }
+             break;
+           }
+
+         default:
+           break;
+       }
+
+   } // end for
+#endif    
+  } // end void transOmpVariables()
+
+  //  if (omp_get_thread_num () == 0) 
+  //     { ... }
+  //  Or if (XOMP_master())   
+  //     { ...  }
+  void transOmpMaster(SgNode * node)
+  {
+    ROSE_ASSERT(node != NULL );
+    SgOmpMasterStatement* target = isSgOmpMasterStatement(node);
+    ROSE_ASSERT(target != NULL );
+    SgScopeStatement * scope = target->get_scope();
+    ROSE_ASSERT(scope != NULL );
+    bool isLast = isLastStatement(target); // check this now before any transformation
+
+    SgStatement* body = target->get_body();
+    ROSE_ASSERT(body!= NULL );
+
+#ifdef ENABLE_XOMP
+   SgFunctionCallExp * func_call = buildFunctionCallExp("XOMP_master", buildIntType(), NULL, scope); 
+   SgIfStmt* if_stmt = NULL; 
+   if (SageInterface::is_Fortran_language())
+      if_stmt = buildIfStmt(buildEqualityOp(func_call,buildIntVal(1)), body, NULL); 
+   else   
+      if_stmt = buildIfStmt(func_call, body, NULL); 
+#else
+    SgExpression* func_exp = buildFunctionCallExp("omp_get_thread_num", buildIntType(), NULL, scope);
+    SgIfStmt* if_stmt = buildIfStmt(buildEqualityOp(func_exp,buildIntVal(0)), body, NULL); 
+#endif
+    replaceStatement(target, if_stmt,true);
+    moveUpPreprocessingInfo (if_stmt, target, PreprocessingInfo::before);
+    if (isLast) // the preprocessing info after the last statement may be attached to the inside of its parent scope
+    {
+  //    cout<<"Found a last stmt. scope is: "<<scope->class_name()<<endl;
+  //    dumpPreprocInfo(scope);
+  // move preprecessing info. from inside position to an after position    
+      moveUpPreprocessingInfo (if_stmt, scope, PreprocessingInfo::inside, PreprocessingInfo::after);
+    }
+  }
+
+
+  // Two cases: without or with copyprivate clause
+  // without it: 
+  //  if (GOMP_single_start ()) //bool GOMP_single_start (void)
+  //     { ...       }
+  // with it: TODO
+  // TODO other clauses
+  void transOmpSingle(SgNode * node)
+  {
+    ROSE_ASSERT(node != NULL );
+    SgOmpSingleStatement* target = isSgOmpSingleStatement(node);
+    ROSE_ASSERT(target != NULL );
+    SgScopeStatement * scope = target->get_scope();
+    ROSE_ASSERT(scope != NULL );
+
+    SgStatement* body = target->get_body();
+    ROSE_ASSERT(body!= NULL );
+
+   SgIfStmt* if_stmt = NULL; 
+
+   if (SageInterface::is_Fortran_language())
+   {
+#ifdef ENABLE_XOMP
+     SgExpression* func_exp = buildFunctionCallExp("XOMP_single", buildIntType(), NULL, scope);
+#else
+     //     SgExpression* func_exp = buildFunctionCallExp("GOMP_single_start", buildIntType(), NULL, scope);
+     cerr<<"Fortran with Omni runtime is not yet implemented!"<<endl;
+     ROSE_ASSERT (false);
+#endif
+
+     if_stmt = buildIfStmt(buildEqualityOp(func_exp,buildIntVal(1)), body, NULL); 
+   }
+   else // C/C++
+   {
+#ifdef ENABLE_XOMP
+     SgExpression* func_exp = buildFunctionCallExp("XOMP_single", buildBoolType(), NULL, scope);
+#else
+     SgExpression* func_exp = buildFunctionCallExp("GOMP_single_start", buildBoolType(), NULL, scope);
+#endif
+
+     if_stmt = buildIfStmt(func_exp, body, NULL); 
+   }
+
+   replaceStatement(target, if_stmt,true);
+    SgBasicBlock* true_body = ensureBasicBlockAsTrueBodyOfIf (if_stmt);
+   if (SageInterface::is_Fortran_language())
+     insert_libxompf_h (if_stmt); // need prototype for xomp runtime function
+    transOmpVariables(target, true_body);
+    // handle nowait 
+    if (!hasClause(target, V_SgOmpNowaitClause))
+    {
+#ifdef ENABLE_XOMP
+      SgExprStatement* barrier_call= buildFunctionCallStmt("XOMP_barrier", buildVoidType(), NULL, scope);
+#else
+      SgExprStatement* barrier_call= buildFunctionCallStmt("GOMP_barrier", buildVoidType(), NULL, scope);
+#endif
+      insertStatementAfter(if_stmt, barrier_call);
+    }
+  }
+
+  // two cases: omp parallel and  omp task
+  // Reused Outliner for this. 
+  // void SgFunctionDeclaration* generateOutlinedFunction(SgNode* node)
+  // {
+  //   
+  // }
+  //
+  //! Translation driver
+  void translationDriver::visit(SgNode* node)
+  {
+#if 0 // not in use
+    switch (node->variantT())
+    {
+      case V_SgOmpParallelStatement:
+        {
+          transOmpParallel(node);
+          break;
+        }
+      case V_SgOmpForStatement:
+        {
+          transOmpFor(node);
+          break;
+        }
+      case V_SgOmpBarrierStatement:
+        {
+          transOmpBarrier(node);
+          break;
+        }
+      case V_SgOmpSingleStatement:
+        {
+          transOmpSingle(node);
+          break;
+        }
+
+      default:
+        {
+          // do nothing here    
+        }
+    }// switch
+#endif
+
+  }//translationDriver::visit()
+
+ //! Build a non-reduction variable clause for a given OpenMP directive. It directly returns the clause if the clause already exists
+  SgOmpVariablesClause* buildOmpVariableClause(SgOmpClauseBodyStatement * clause_stmt, const VariantT& vt)
+  {
+    SgOmpVariablesClause* result = NULL;
+    ROSE_ASSERT(clause_stmt != NULL);
+    ROSE_ASSERT(vt != V_SgOmpReductionClause);
+    Rose_STL_Container<SgOmpClause*> clauses = getClause(clause_stmt,vt);
+
+    if (clauses.size()==0)
+    {
+      switch(vt)
+      {
+        case V_SgOmpCopyinClause:
+          result = new SgOmpCopyinClause();
+          break;
+        case V_SgOmpCopyprivateClause:
+          result = new SgOmpCopyprivateClause();
+          break;
+        case V_SgOmpFirstprivateClause:
+          result = new SgOmpFirstprivateClause();
+          break;
+        case V_SgOmpLastprivateClause:
+          result = new SgOmpLastprivateClause();
+          break;
+        case V_SgOmpPrivateClause:
+          result = new SgOmpPrivateClause();
+          break;
+        case V_SgOmpSharedClause:
+          result = new SgOmpSharedClause();
+          break;
+        case V_SgOmpReductionClause:
+        default:
+          cerr<<"Unacceptable clause type in OmpSupport::buildOmpVariableClause(): "<<vt<<endl;
+          ROSE_ASSERT(false);
+      }
+    }
+    else
+    {
+      result = isSgOmpVariablesClause(clauses[0]);
+    }
+    ROSE_ASSERT(result != NULL); 
+    setOneSourcePositionForTransformation(result);
+
+    clause_stmt->get_clauses().push_back(result);
+    result->set_parent(clause_stmt); // is This right?
+
+    return result;
+  }
+   
+  //! Add a variable into a non-reduction clause of an OpenMP statement, create the clause transparently if it does not exist
+    void addClauseVariable(SgInitializedName* var, SgOmpClauseBodyStatement * clause_stmt, const VariantT& vt)
+    {
+      ROSE_ASSERT(var != NULL);
+      ROSE_ASSERT(clause_stmt!= NULL);
+      ROSE_ASSERT(vt != V_SgOmpReductionClause);
+      Rose_STL_Container<SgOmpClause*> clauses = getClause(clause_stmt,vt );
+      SgOmpVariablesClause* target_clause = NULL;
+       // create the clause if it does not exist
+      if (clauses.size()==0)
+      {
+        target_clause = buildOmpVariableClause (clause_stmt, vt);
+      }
+      else
+      {
+        target_clause = isSgOmpVariablesClause(clauses[0]);
+      }
+      ROSE_ASSERT(target_clause != NULL);
+
+      // Insert only if the variable is not in the list
+      if (!isInClauseVariableList(var, clause_stmt, vt)) 
+      {
+          // Convey -- neeed to set the parent of the varref.
+          SgVarRefExp *vr = buildVarRefExp(var);
+          vr->set_parent(target_clause);
+          target_clause->get_variables().push_back(vr);
+      }
+    }
+    
+  //! Patch up private variables for omp for. The reason is that loop indices should be private by default and this function will make this explicit. This should happen before the actual translation is done.
+  int patchUpPrivateVariables(SgFile* file)
+  {
+    int result = 0;
+    ROSE_ASSERT(file != NULL);
+    Rose_STL_Container<SgNode*> nodeList = NodeQuery::querySubTree(file, V_SgOmpForStatement);
+    Rose_STL_Container<SgNode*> nodeList2 = NodeQuery::querySubTree(file, V_SgOmpDoStatement);
+    
+    Rose_STL_Container<SgNode*> nodeList_merged (nodeList.size() + nodeList2.size()) ;
+    
+    std::sort(nodeList.begin(), nodeList.end());
+    std::sort(nodeList2.begin(), nodeList2.end());
+    std::merge (nodeList.begin(), nodeList.end(), nodeList2.begin(), nodeList2.end(), nodeList_merged.begin());
+
+    Rose_STL_Container<SgNode*>::iterator nodeListIterator = nodeList_merged.begin();
+    // For each omp for/do statement
+    for ( ;nodeListIterator !=nodeList_merged.end();  ++nodeListIterator)
+    {
+      SgStatement * omp_loop = NULL;
+      SgOmpForStatement* for_node = isSgOmpForStatement(*nodeListIterator);
+      SgOmpDoStatement* do_node = isSgOmpDoStatement(*nodeListIterator);
+      if (for_node)
+        omp_loop = for_node;
+      else if (do_node)
+        omp_loop = do_node;
+      else
+        ROSE_ASSERT (false);
+
+      SgScopeStatement* directive_scope = omp_loop->get_scope();
+      ROSE_ASSERT(directive_scope != NULL);
+      // Collected nested loops and their indices
+      // skip the top level loop?
+      Rose_STL_Container<SgNode*> loops; 
+      if (for_node)
+        loops = NodeQuery::querySubTree(for_node->get_body(), V_SgForStatement);
+      else if (do_node)
+        loops = NodeQuery::querySubTree(do_node->get_body(), V_SgFortranDo);
+      else
+        ROSE_ASSERT (false);
+
+      Rose_STL_Container<SgNode*>::iterator loopIter = loops.begin();
+      for (; loopIter!= loops.end(); loopIter++)
+      {
+        SgInitializedName* index_var = getLoopIndexVariable(*loopIter);
+        ROSE_ASSERT (index_var != NULL);
+        SgScopeStatement* var_scope = index_var->get_scope();
+        // Only loop index variables declared in higher  or the same scopes matter
+        if (isAncestor(var_scope, directive_scope) || var_scope==directive_scope)
+        {
+          // Grab possible enclosing parallel region
+          bool isPrivateInRegion = false; 
+          SgOmpParallelStatement * omp_stmt = isSgOmpParallelStatement(getEnclosingNode<SgOmpParallelStatement>(omp_loop)); 
+          if (omp_stmt)
+          {
+            isPrivateInRegion = isInClauseVariableList(index_var, isSgOmpClauseBodyStatement(omp_stmt), V_SgOmpPrivateClause);
+          }
+          // add it into the private variable list only if it is not specified as private in both the loop and region levels. 
+          if (! isPrivateInRegion && !isInClauseVariableList(index_var, isSgOmpClauseBodyStatement(omp_loop), V_SgOmpPrivateClause)) 
+          {
+            result ++;
+            addClauseVariable(index_var,isSgOmpClauseBodyStatement(omp_loop), V_SgOmpPrivateClause);
+          }
+        }
+
+      } // end for loops
+
+    }// end for omp for statments
+   return result;
+  } // end patchUpPrivateVariables()
+
+   //! Collect threadprivate variables within the current project, return a set to avoid duplicated elements
+   std::set<SgInitializedName*> collectThreadprivateVariables()
+   {
+     // Do the actual collection only once
+     static bool calledOnce = false;
+     static set<SgInitializedName*> result;
+
+     if (calledOnce)
+       return result;
+     calledOnce = true;
+     std::vector<SgOmpThreadprivateStatement*> tp_stmts = getSgNodeListFromMemoryPool<SgOmpThreadprivateStatement> ();
+     std::vector<SgOmpThreadprivateStatement*>::const_iterator c_iter;
+     for (c_iter = tp_stmts.begin(); c_iter != tp_stmts.end(); c_iter ++)
+     {
+       SgVarRefExpPtrList refs = (*c_iter)->get_variables();
+       SgInitializedNamePtrList var_list; // = (*c_iter)->get_variables();
+       for (size_t j =0; j<refs.size(); j++) 
+         var_list.push_back(refs[j]->get_symbol()->get_declaration());
+       std::copy(var_list.begin(), var_list.end(), std::inserter(result, result.end()));
+     }
+     return result;
+   }
+     
+//Check if a variable that is determined to be shared in all enclosing constructs, up to and including the innermost enclosing
+//parallel construct, is shared
+// start_stmt is the start point to find enclosing OpenMP constructs. It is excluded as an enclosing construct for itself.
+// TODO: we only check if it is shared to the innermost enclosing parallel construct for now
+  static bool isSharedInEnclosingConstructs (SgInitializedName* init_var, SgStatement* start_stmt) 
+  {
+    bool result = false;
+    ROSE_ASSERT(init_var != NULL);
+    ROSE_ASSERT(start_stmt != NULL);
+    SgScopeStatement* var_scope = init_var->get_scope();
+//    SgScopeStatement* directive_scope = start_stmt->get_scope();
+    // locally declared variables are private to the start_stmt
+    // We should not do this here. It is irrelevant to this function.
+   // if (isAncestor(start_stmt, init_var))
+   //   return false;
+
+//   cout<<"Debug omp_lowering.cpp isSharedInEnclosingConstructs() SgInitializedName name = "<<init_var->get_name().getString()<<endl;
+    SgOmpParallelStatement* enclosing_par_stmt  = getEnclosingNode<SgOmpParallelStatement> (start_stmt, false);
+    // Lexically nested within a parallel region
+    if (enclosing_par_stmt)
+    {
+      // locally declared variables are private to enclosing_par_stmt
+      SgScopeStatement* enclosing_construct_scope = enclosing_par_stmt->get_scope();
+      ROSE_ASSERT(enclosing_construct_scope != NULL);
+      if (isAncestor(enclosing_construct_scope, var_scope))
+        return false;
+
+      // Explicitly declared as a shared variable
+      if (isInClauseVariableList(init_var, enclosing_par_stmt, V_SgOmpSharedClause))
+        result = true;
+      else
+      {// shared by default
+        VariantVector vv(V_SgOmpPrivateClause);
+        vv.push_back(V_SgOmpFirstprivateClause);
+        vv.push_back(V_SgOmpCopyinClause);
+        vv.push_back(V_SgOmpReductionClause);
+        if (isInClauseVariableList(init_var, enclosing_par_stmt,vv))
+          result = false;
+        else
+          result = true;
+      }
+    }
+    else 
+     //the variable is in an orphaned construct
+     // The variable could be
+     // 1. a function parameter: it is private to its enclosing parallel region
+     // 2. a global variable: either a threadprivate variable or shared by default
+     // 3. is a variable declared within an orphaned function: it is private to its enclosing parallel region
+     // ?? any other cases?? TODO
+    {
+      SgFunctionDefinition* func_def = getEnclosingFunctionDefinition(start_stmt);
+      ROSE_ASSERT (func_def != NULL);
+      if (isSgGlobal(var_scope))
+      {
+        set<SgInitializedName*> tp_vars = collectThreadprivateVariables();
+        if (tp_vars.find(init_var)!= tp_vars.end())
+          result = false; // is threadprivate
+        else 
+          result = true; // otherwise
+      }
+      else if (isSgFunctionParameterList(init_var->get_parent()))
+      {
+        // function parameters are private to its dynamically (non-lexically) nested parallel regions.
+        result = false;
+      }
+      else if (isAncestor(func_def,var_scope))
+      {
+         // declared within an orphaned function, should be private
+          result = false;
+      } else
+      {
+#if 1
+        cerr<<"Error: OmpSupport::isSharedInEnclosingConstructs() \n Unhandled variables within an orphaned construct:"<<endl;
+        cerr<<"SgInitializedName name = "<<init_var->get_name().getString()<<endl;
+        dumpInfo(init_var);
+        init_var->get_file_info()->display("tttt");
+        ROSE_ASSERT(false);
+#endif        
+      }
+    }
+    return result;
+  } // end isSharedInEnclosingConstructs()
+
+//! Patch up firstprivate variables for omp task. The reason is that the specification 3.0 defines rules for implicitly determined data-sharing attributes and this function will make the implicit firstprivate variable of omp task explicit.
+/*
+variables used in task block: 
+
+2.9.1.1 Data-sharing Attribute Rules for Variables Referenced in a Construct
+Ref. OMP 3.0 page 79 
+A variable is firstprivate to the task (default) , if
+** not explicitly specified by default(), shared(),private(), firstprivate() clauses
+** not shared in enclosing constructs
+
+It should also satisfy the restriction defined in specification 3.0 page 93  TODO
+* cannot be a variable which is part of another variable (as an array or structure element)
+* cannot be private, reduction
+* must have an accessible, unambiguous copy constructor for the class type
+* must not have a const-qualified type unless it is of class type with a mutable member
+* must not have an incomplete C/C++ type or a reference type
+*
+I decided to exclude variables which are used by addresses when recognizing firstprivate variables 
+      The reason is that in real code, it is often to have private variables first then use their
+      address later.   Skipping the replacement will result in wrong semantics.
+       e.g. from Allan Porterfield
+          void    create_seq( double seed, double a )
+      {
+             double x, s;
+             int    i, k;
+     
+      #pragma omp parallel private(x,s,i,k)
+         { 
+              // ..... 
+             // here s is private 
+             s = find_my_seed( myid, num_procs,
+                               (long)4*NUM_KEYS, seed, a );
+     
+             for (i=k1; i<k2; i++)
+             {
+                 x = randlc(&s, &a); // here s is used by its address
+     
+             }
+         }
+      }   
+If not, wrong code will be generated later on. The reason follows:
+   * Considering nested omp tasks: 
+         #pragma omp task untied
+            {
+              int j =100;
+              // i is firstprivate, item is shared
+              {
+                for (i = 0; i < LARGE_NUMBER; i++)
+                {
+      #pragma omp task if(1) 
+                  process (item[i],&j);
+                }
+              }
+            }
+   * the variable j will be firstprivate by default 
+   * however, it is used by its address within a nested task (&j)
+   * replacing it with its local copy will not get the right, original address.
+   *
+   * Even worse: the replacement will cause some later translation (outlining) to 
+   * access the address of a parent task's local variable. 
+   * It seems (not 100% certain!!!) that GOMP implements tasks as independent entities.
+   * As a result a parent task's local stack will not be always accessible to its nested tasks.
+   * A segmentation fault will occur when the lexically nested task tries to obtain the address of
+   * its parent task's local variable. 
+   * An example mistaken translation is shown below
+       int main()
+      {
+        GOMP_parallel_start(OUT__3__1527__,0,0);
+        OUT__3__1527__();
+        GOMP_parallel_end();
+        return 0;
+      }
+      
+      void OUT__3__1527__()
+      {
+        if (GOMP_single_start()) {
+          int i;
+          printf(("Using %d threads.\n"),omp_get_num_threads());
+          void *__out_argv2__1527__[1];
+          __out_argv2__1527__[0] = ((void *)(&i));
+          GOMP_task(OUT__2__1527__,&__out_argv2__1527__,0,4,4,1,1);
+          //GOMP_task(OUT__2__1527__,&__out_argv2__1527__,0,4,4,1,0); //untied or not, no difference
+        }
+      }
+      
+      void OUT__2__1527__(void **__out_argv)
+{
+  int *i = (int *)(__out_argv[0]);
+  //  int _p_i;
+  //  _p_i =  *i;
+  //  for (_p_i = 0; _p_i < 1000; _p_i++) {
+  for (*i = 0; *i < 1000; (*i)++) {
+    void *__out_argv1__1527__[1];
+    // cannot access auto variable from the stack of another task instance!!
+    //__out_argv1__1527__[0] = ((void *)(&_p_i));
+    __out_argv1__1527__[0] = ((void *)(&(*i)));// this is the right translation
+    GOMP_task(OUT__1__1527__,&__out_argv1__1527__,0,4,4,1,0);
+  }
+}
+void OUT__1__1527__(void **__out_argv)
+{
+  int *i = (int *)(__out_argv[0]);
+  int _p_i;
+  _p_i =  *i;
+  assert(_p_i>=0);
+  assert(_p_i<10000);
+
+  process((item[_p_i]));
+}
+*
+  */
+int patchUpFirstprivateVariables(SgFile*  file)
+{
+  int result = 0;
+  ROSE_ASSERT(file != NULL);
+  Rose_STL_Container<SgNode*> nodeList = NodeQuery::querySubTree(file, V_SgOmpTaskStatement);
+  Rose_STL_Container<SgNode*>::iterator iter = nodeList.begin();
+  for (; iter != nodeList.end(); iter ++)
+  {
+    SgOmpTaskStatement * target = isSgOmpTaskStatement(*iter);
+    SgScopeStatement* directive_scope = target->get_scope();
+    SgStatement* body = target->get_body();
+    ROSE_ASSERT(body != NULL);
+
+    // Find all variable references from the task's body
+    Rose_STL_Container<SgNode*> refList = NodeQuery::querySubTree(body, V_SgVarRefExp);
+    Rose_STL_Container<SgNode*>::iterator var_iter = refList.begin();
+    for (; var_iter != refList.end(); var_iter ++)
+    {
+      SgVarRefExp * var_ref = isSgVarRefExp(*var_iter);
+      ROSE_ASSERT(var_ref->get_symbol() != NULL);
+      SgInitializedName* init_var = var_ref->get_symbol()->get_declaration();
+      ROSE_ASSERT(init_var != NULL);
+      SgScopeStatement* var_scope = init_var->get_scope();
+      ROSE_ASSERT(var_scope != NULL);
+
+      // Variables with automatic storage duration that are declared in 
+      // a scope inside the construct are private. Skip them
+      if (isAncestor(directive_scope, var_scope))
+        continue;
+
+      if (SageInterface::isUseByAddressVariableRef(var_ref))
+        continue;
+      // Skip variables already with explicit data-sharing attributes
+      VariantVector vv (V_SgOmpDefaultClause);
+      vv.push_back(V_SgOmpPrivateClause);
+      vv.push_back(V_SgOmpSharedClause);
+      vv.push_back(V_SgOmpFirstprivateClause);
+      if (isInClauseVariableList(init_var, target ,vv)) 
+        continue;
+      // Skip variables which are class/structure members: part of another variable
+      if (isSgClassDefinition(init_var->get_scope()))
+        continue;
+      // Skip variables which are shared in enclosing constructs  
+      if(isSharedInEnclosingConstructs(init_var, target))
+        continue;
+      // Now it should be a firstprivate variable   
+      addClauseVariable(init_var, target, V_SgOmpFirstprivateClause);
+      result ++;
+    } // end for each variable reference
+  } // end for each SgOmpTaskStatement
+  return result;
+} // end patchUpFirstprivateVariables()
+
+/*
+* Winnie, Handle collapse clause before openmp and openmp accelerator
+* add new variables inserted by SageInterface::loopCollasping() into mapin clause
+*
+* This function passes target for loop of collpase clause and the collapse factor to the function SageInterface::loopCollapse.
+* After return from SageInterface::loopCollapse, this function will insert new variables(generated by loopCollapse()) into mapin
+* or mapinout clause, if the collapse clause comes with target directive.
+*
+*/
+void transOmpCollapse(SgOmpClauseBodyStatement * node)
+{
+
+    SgStatement * body =  node->get_body();
+    ROSE_ASSERT(body != NULL);
+
+    // The OpenMP syntax requires that the omp for pragma is immediately followed by the for loop.
+    SgForStatement * for_loop = isSgForStatement(body);
+    SgStatement * loop = for_loop;
+
+    if(for_loop == NULL)
+        return;
+        
+    ROSE_ASSERT(getScope(for_loop)->get_parent()->get_parent() != NULL);
+        
+    Rose_STL_Container<SgOmpClause*> collapse_clauses = getClause(node, V_SgOmpCollapseClause);
+    
+    int collapse_factor = atoi(isSgOmpCollapseClause(collapse_clauses[0])->get_expression()->unparseToString().c_str());
+    SgExprListExp * new_var_list = SageInterface::loopCollapsing(for_loop, collapse_factor);
+
+    /*
+    *Winnie, we need to add the new variables into the map in list, if there is a SgOmpTargetStatement
+    */
+    /*For OmpTarget, we need to create SgOmpMapClause if there is no such clause in the original code.
+    *   target_stmt, #pragma omp target
+    *                or, #pragma omp parallel, when is not OmpTarget
+    *   inside this if condition, ompacc=false means there is no map clause, we need to create one
+    *   outside this if condition, ompacc=false means, no need to add new variables in the map in clause
+    */
+    SgStatement * target_stmt = isSgStatement(node->get_parent()->get_parent());
+    if(isSgOmpTargetStatement(target_stmt))
+    {
+
+        Rose_STL_Container<SgOmpClause*> map_clauses;
+        SgOmpMapClause * map_in;
+
+        /*get the data clause of this target statement*/
+        SgOmpClauseBodyStatement * target_clause_body = isSgOmpClauseBodyStatement(target_stmt); 
+
+        map_clauses = target_clause_body->get_clauses();
+        if(map_clauses.size() == 0)
+        {
+            SgOmpTargetDataStatement * target_data_stmt = getEnclosingNode<SgOmpTargetDataStatement>(target_stmt);
+
+            target_clause_body = isSgOmpClauseBodyStatement(target_data_stmt);
+            map_clauses = target_clause_body->get_clauses();
+        }
+
+        assert(map_clauses.size() != 0);
+
+        for(Rose_STL_Container<SgOmpClause*>::const_iterator iter = map_clauses.begin(); iter != map_clauses.end(); iter++)
+        {
+             SgOmpMapClause * temp_map_clause = isSgOmpMapClause(*iter);
+             if(temp_map_clause != NULL) //Winnie, look for the map(in) or map(inout) clause
+             {
+                 SgOmpClause::omp_map_operator_enum map_operator = temp_map_clause->get_operation();
+                 if(map_operator == SgOmpClause::e_omp_map_in || map_operator == SgOmpClause::e_omp_map_inout)
+                 {
+                     map_in = temp_map_clause;
+                     break;
+                 }
+             }
+        }
+        
+        if(map_in == NULL)
+        {
+            cerr <<"prepare to create a map in clause" << endl;
+        }
+        
+        
+        SgVarRefExpPtrList & mapin_var_list = map_in->get_variables();
+        SgExpressionPtrList new_vars = new_var_list->get_expressions();
+        for(int i = 0; i < new_vars.size(); i++)
+        {
+            mapin_var_list.push_back(isSgVarRefExp(new_vars[i]));
+        }
+    }
+}//Winnie, end of loop collapse
+
+
+
+//-------------------------------------------------------------------------
+// Mark all variable symbols that are parameters sith the is_paramater attr.
+//-------------------------------------------------------------------------
+
+void AssignIsParameterAttributes(SgFile *file) {
+
+    Rose_STL_Container<SgNode*> fnList = 
+        NodeQuery::querySubTree(file, V_SgFunctionDeclaration);
+
+    for (int i = 0; i < fnList.size(); i++) {
+        SgFunctionDeclaration *fdecl = isSgFunctionDeclaration(fnList.at(i));
+
+        SgFunctionParameterList *functionParameters =
+            fdecl->get_parameterList();
+        SgInitializedNamePtrList &parameterList = 
+            functionParameters->get_args();
+    
+        SgInitializedNamePtrList::iterator j;
+        for (j = parameterList.begin(); j != parameterList.end(); j++) {
+            SgInitializedName *iname = isSgInitializedName(*j);
+            assert(iname);
+            SgVariableSymbol * sym = isSgVariableSymbol(iname->get_symbol_from_symbol_table());
+            if (sym) {
+                // mark the symbol with the "is_parameter" attribute
+                if (!sym->attributeExists("is_parameter")) {
+                    sym->setAttribute("is_parameter", new AstAttribute);
+                }
+            }
+        }
+    }
+}
+
+
+static void assignEnclosingFunctionAttributes() {
+    map<SgFunctionDeclaration *, SgStatement *>::iterator iter;
+
+    for (iter = enclosing_regions.begin(); 
+         iter != enclosing_regions.end(); 
+         iter++) {
+
+        SgFunctionDeclaration *inner_function = 
+            isSgFunctionDeclaration(iter->first);;
+        SgStatement *outer_region = isSgStatement(iter->second);
+
+        SgFunctionDefinition *fndef =
+            isSgFunctionDefinition(outer_region);
+
+        SgFunctionDeclaration *outer_function;
+
+        if (fndef) {
+            outer_function = fndef->get_declaration();
+        } else {
+            // outer was not region, not a function
+            // get corresponding function
+            outer_function = outlined_regions[outer_region];
+        }
+
+        assert(outer_function);
+
+        setOmpEnclosingFunctionAttribute(inner_function, outer_function);
+    }
+
+    outlined_regions.clear();
+    enclosing_regions.clear();
+
+}
+
+
+class ProcessDeclareTarget : public AstSimpleProcessing {
+
+public:
+    ProcessDeclareTarget() : inTarget(false) {} 
+
+    virtual void visit (SgNode* astNode) {
+
+
+        switch (astNode->variantT()) {
+
+        case V_SgFunctionDefinition:
+            {
+                SgFunctionDefinition* fndef = isSgFunctionDefinition(astNode);
+                SgFunctionDeclaration *fdecl= fndef->get_declaration();
+                SgNode *body = fndef->get_body();
+
+                std::string target = 
+                    inTarget ? "COPROC" : "HOST";
+                std::string before_text = "\n#ifdef CNY_HTC_" + target;
+                SageInterface::addTextForUnparser(fdecl, 
+                                                  before_text,
+                                                  AstUnparseAttribute::e_before);
+                // Dummy call with empty string so the e_after on the next
+                // call will be honored.
+                SageInterface::addTextForUnparser(body, "",
+                                                  AstUnparseAttribute::e_after);
+                std::string after_text =
+                    "\n#endif /* CNY_HTC_" + target + " */\n";
+                SageInterface::addTextForUnparser(body, after_text,
+                                                  AstUnparseAttribute::e_after);
+                break;
+            }
+
+        case V_SgOmpDeclareTargetStatement:
+            {
+                // NOTE: This node will disappear in the unparser
+
+                inTarget = true;
+                break;
+            }
+        case V_SgOmpEndDeclareTargetStatement:
+            {
+                // NOTE: This node will disappear in the unparser
+
+                inTarget = false;
+                break;
+            }
+        default:
+            break;
+        }
+    }
+
+private:
+    bool inTarget;
+};
+
+void handleDeclareTarget(SgNode *node) {
+    ProcessDeclareTarget pdt;
+    pdt.traverse(node, preorder);
+}
+
+
+// Process target and declare target directives for HTC.
+// Mark functions with CNY_HTC_COPROC and CNY_HTC_HOST preprocessing 
+// directives.
+void htc_split(SgSourceFile* file)
+{
+    ROSE_ASSERT(file != NULL);
+
+    AssignIsParameterAttributes(file);
+
+    patchUpPrivateVariables(file); 
+    // The order of these two functions matters! 
+    // We want to patch up private variable first!
+    patchUpFirstprivateVariables(file);
+
+    handleDeclareTarget(file);
+
+    Rose_STL_Container<SgNode*> nodeList = 
+        NodeQuery::querySubTree(file, V_SgStatement);
+    Rose_STL_Container<SgNode*>::reverse_iterator nodeListIterator = 
+        nodeList.rbegin();
+    for ( ;nodeListIterator !=nodeList.rend();  ++nodeListIterator) {
+        SgStatement* node = isSgStatement(*nodeListIterator);
+        ROSE_ASSERT(node != NULL);
+
+        switch (node->variantT()) {
+        case V_SgOmpTargetStatement:
+            {
+                transOmpTarget(node);
+                break;
+            }
+        case V_SgOmpTargetDataStatement:
+            {
+                transOmpTargetData(node);
+                break;
+            }
+            
+        default:
+            {
+                // do nothing here    
+            }
+        }// switch
+    } 
+}  // htc_split
+
+
+//! Bottom-up processing AST tree to translate all OpenMP constructs
+// the major interface of omp_lowering
+// We now operation on scoped OpenMP regions and blocks
+//    SgBasicBlock
+//      /                   #
+//     /                    #
+// SgOmpParallelStatement   #
+//          \               #
+//           \              #
+//           SgBasicBlock   #
+//               \          #
+//                \         #
+//                SgOmpParallelStatement
+void lower_omp(SgSourceFile* file)
+{
+  ROSE_ASSERT(file != NULL);
+
+  if (htc_do_split) {
+      htc_split(file);
+      return;
+  }
+
+  AssignIsParameterAttributes(file);
+
+  patchUpPrivateVariables(file); // the order of these two functions matter! We want to patch up private variable first!
+  patchUpFirstprivateVariables(file);
+  // Liao 12/2/2010, Fortran does not require function prototypes
+#if 0
+  // Convey
+  if (!SageInterface::is_Fortran_language() )
+    insertRTLHeaders(file);
+#endif
+  if (!enable_accelerator)
+   insertRTLinitAndCleanCode(file);
+  //    translationDriver driver;
+  // SgOmpXXXStatment is compiler-generated and has no file info
+  //driver.traverseWithinFile(file,postorder);
+  //  driver.traverse(file,postorder);
+  // AST manipulation with postorder traversal is not reliable,
+  // We record nodes first then do changes to them
+
+  Rose_STL_Container<SgNode*> nodeList = NodeQuery::querySubTree(file, V_SgStatement);
+  Rose_STL_Container<SgNode*>::reverse_iterator nodeListIterator = nodeList.rbegin();
+  for ( ;nodeListIterator !=nodeList.rend();  ++nodeListIterator)
+  {
+    SgStatement* node = isSgStatement(*nodeListIterator);
+    ROSE_ASSERT(node != NULL);
+    //debug the order of the statements
+//    cout<<"Debug lower_omp(). stmt:"<<node<<" "<<node->class_name() <<" "<< node->get_file_info()->get_line()<<endl;
+
+    /*Winnie, handle Collapse clause.*/
+    if(  isSgOmpClauseBodyStatement(node) != NULL && hasClause(isSgOmpClauseBodyStatement(node), V_SgOmpCollapseClause))
+        transOmpCollapse(isSgOmpClauseBodyStatement(node));
+
+    switch (node->variantT())
+    {
+      case V_SgOmpParallelStatement:
+        {
+          // check if this parallel region is under "omp target"
+          SgNode* parent = node->get_parent();
+          ROSE_ASSERT (parent != NULL);
+          if (isSgBasicBlock(parent)) // skip the padding block in between.
+            parent= parent->get_parent();
+          if (isSgOmpTargetStatement(parent)) {
+              // Convey -- target should be handled during splitting for HT
+              //            transOmpTargetParallel(node);
+          }
+          else  
+            transOmpParallel(node);
+          break;
+        }
+      case V_SgOmpSectionsStatement:
+        {
+          transOmpSections(node);
+          break;
+        }
+ 
+      case V_SgOmpTaskStatement:
+        {
+          transOmpTask(node);
+          break;
+        }
+      case V_SgOmpForStatement:
+      case V_SgOmpDoStatement:
+        {
+          // check if the loop is part of the combined "omp parallel for" under the "omp target" directive
+          // TODO: more robust handling of this logic, not just fixed AST form
+          bool is_target_loop = false; 
+          SgNode* parent = node->get_parent();
+          ROSE_ASSERT (parent != NULL);
+          // skip a possible BB between omp parallel and omp for, especially when the omp parallel has multiple omp for loops 
+          if (isSgBasicBlock(parent))
+            parent = parent->get_parent();
+          SgNode* grand_parent = parent->get_parent();
+          ROSE_ASSERT (grand_parent != NULL);
+
+          if (isSgOmpParallelStatement (parent) && isSgOmpTargetStatement(grand_parent) ) 
+            is_target_loop = true;
+            
+          if (is_target_loop) {
+              // Convey -- target should be handled during splitting for HT
+              //            transOmpTargetLoop (node);
+          }
+          else {
+            transOmpLoop(node);
+          }
+          break;
+        }
+        //          {
+        //            transOmpDo(node);
+        //            break;
+        //          }
+      case V_SgOmpBarrierStatement:
+        {
+          transOmpBarrier(node);
+          break;
+        }
+      case V_SgOmpFlushStatement:
+        {
+          transOmpFlush(node);
+          break;
+        }
+
+      case V_SgOmpThreadprivateStatement:
+        {
+          transOmpThreadprivate(node);
+          break;
+        }
+      case V_SgOmpTaskwaitStatement:
+        {
+          transOmpTaskwait(node);
+          break;
+        }
+      case V_SgOmpSingleStatement:
+        {
+          transOmpSingle(node);
+          break;
+        }
+      case V_SgOmpMasterStatement:
+        {
+          transOmpMaster(node);
+          break;
+        }
+      case V_SgOmpAtomicStatement:
+        {
+          transOmpAtomic(node);
+          break;
+        }
+      case V_SgOmpOrderedStatement:
+        {
+          transOmpOrdered(node);
+          break;
+        }
+      case V_SgOmpCriticalStatement:
+        {
+          transOmpCritical(node);
+          break;
+        }
+      case V_SgOmpTargetStatement:
+        {
+            // Convey -- target handled during splitting for HT
+            //           transOmpTarget(node);
+          break;
+        }
+      case V_SgOmpTargetDataStatement:
+        {
+            // Convey -- target handled during splitting for HT
+            //           transOmpTargetData(node);
+          break;
+        }
+
+      default:
+        {
+          // do nothing here    
+        }
+    }// switch
+
+  } 
+
+#if 0
+  //3. Special handling for files with main() 
+  // rename main() to user_main()
+  SgFunctionDeclaration * mainFunc = findMain(cur_file);
+  if (mainFunc) 
+  {
+    renameMainToUserMain(mainFunc);
+  }
+#endif
+
+  assignEnclosingFunctionAttributes();
+
+}
+
+} // end namespace
+#else
+// stub for linking librose
+#include "sage3basic.h"
+namespace HtOmpSupport
+{ 
+    void lower_omp(SgSourceFile* file) {
+    }
+} // end namespace
+
+#endif
